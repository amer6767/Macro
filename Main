--[[
    ╔═══════════════════════════════════════════════════════════════════════════╗
    ║                     AXIORA ULTIMATE v6.0 - DELTA OPTIMIZED                ║
    ║                        Complete Rewrite for Stability                      ║
    ║                                                                            ║
    ║  Features: Recording, Playback, Strategy Loading, Visual HUD, UI          ║
    ║  Optimized for: Delta Executor (with fallbacks for other executors)       ║
    ╚═══════════════════════════════════════════════════════════════════════════╝
]]

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 1: ENVIRONMENT SETUP & CAPABILITY DETECTION
-- ═══════════════════════════════════════════════════════════════════════════════

local Axiora = {}
Axiora._VERSION = "6.0.0"
Axiora._BUILD = "DELTA-STABLE"

-- Safe function to get global environment
local function getEnv()
    if getgenv then return getgenv() end
    if getfenv then return getfenv(0) end
    return _G
end

local Root = getEnv()

-- Prevent multiple loads
if Root.Axiora and Root.Axiora._LOADED then
    warn("[Axiora] Already loaded, skipping re-initialization")
    return Root.Axiora
end

-- Safe service getter with caching
local Services = setmetatable({}, {
    __index = function(self, serviceName)
        local success, service = pcall(function()
            return game:GetService(serviceName)
        end)
        if success and service then
            -- Use cloneref if available for security
            if typeof(cloneref) == "function" then
                service = cloneref(service)
            end
            rawset(self, serviceName, service)
            return service
        end
        return nil
    end
})

-- Pre-cache commonly used services
local Players = Services.Players
local RunService = Services.RunService
local UserInputService = Services.UserInputService
local TweenService = Services.TweenService
local HttpService = Services.HttpService
local Workspace = Services.Workspace
local CoreGui = Services.CoreGui
local GuiService = Services.GuiService
local VirtualInputManager = Services.VirtualInputManager

-- Get local player safely
local function getLocalPlayer()
    return Players and Players.LocalPlayer
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- CAPABILITY DETECTION
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Capabilities = {
    -- Executor detection
    IsDelta = typeof(Root.delta) == "table" or typeof(Root.Delta) == "table",
    Executor = "Unknown",
    
    -- File system
    ReadFile = typeof(readfile) == "function",
    WriteFile = typeof(writefile) == "function",
    MakeFolder = typeof(makefolder) == "function",
    IsFile = typeof(isfile) == "function",
    IsFolder = typeof(isfolder) == "function",
    
    -- Input capabilities
    MouseMoveAbs = typeof(mousemoveabs) == "function",
    MouseClick = typeof(mouse1click) == "function",
    KeyPress = typeof(keypress) == "function",
    KeyRelease = typeof(keyrelease) == "function",
    VirtualInput = VirtualInputManager ~= nil,
    
    -- Metatable capabilities
    GetRawMetatable = typeof(getrawmetatable) == "function",
    SetReadonly = typeof(setreadonly) == "function",
    NewCClosure = typeof(newcclosure) == "function",
    
    -- Drawing
    Drawing = typeof(Drawing) == "table" or typeof(Drawing) == "userdata",
    
    -- Other
    GetNamecallMethod = typeof(getnamecallmethod) == "function",
    SetClipboard = typeof(setclipboard) == "function",
    Request = typeof(request) == "function" or typeof(http_request) == "function",
    
    -- Identity level (estimated)
    IdentityLevel = 2
}

-- Detect executor
local function detectExecutor()
    local executors = {
        {check = function() return Root.delta or Root.Delta end, name = "Delta"},
        {check = function() return syn and syn.protect_gui end, name = "Synapse X"},
        {check = function() return KRNL_LOADED end, name = "KRNL"},
        {check = function() return fluxus end, name = "Fluxus"},
        {check = function() return Hydrogen end, name = "Hydrogen"},
        {check = function() return getexecutorname and getexecutorname() end, name = nil},
    }
    
    for _, exec in ipairs(executors) do
        local success, result = pcall(exec.check)
        if success and result then
            return exec.name or tostring(result)
        end
    end
    return "Unknown"
end

Axiora.Capabilities.Executor = detectExecutor()

-- Check identity level
pcall(function()
    if getidentity then
        Axiora.Capabilities.IdentityLevel = getidentity()
    elseif getthreadcontext then
        Axiora.Capabilities.IdentityLevel = getthreadcontext()
    end
end)

-- File system verified check
Axiora.Capabilities.FileSystemVerified = false
if Axiora.Capabilities.WriteFile and Axiora.Capabilities.ReadFile then
    local testSuccess = pcall(function()
        writefile("Axiora/_test.tmp", "test")
        local content = readfile("Axiora/_test.tmp")
        if Axiora.Capabilities.IsFile then
            if isfile("Axiora/_test.tmp") then
                delfile("Axiora/_test.tmp")
            end
        end
        return content == "test"
    end)
    Axiora.Capabilities.FileSystemVerified = testSuccess
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 2: CORE STATE & EVENT SYSTEM
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.State = {
    Status = "IDLE", -- IDLE, RECORDING, PLAYING, PAUSED
    Buffer = {},
    StartTime = 0,
    Connections = {},
    Threads = {},
    SecurityConnections = {},
    InitTime = os.clock()
}

Axiora.Settings = {
    -- Recording
    SmartRecording = true,
    MinMoveDistance = 0.5,
    MinClickInterval = 0.05,
    RecordUIClicks = true,
    RecordCamera = true,
    MaxBufferSize = 50000,
    
    -- Playback
    TimeScale = 1.0,
    NavigationTimeout = 10,
    NavigationRetries = 3,
    
    -- Input offsets (calibration)
    XOffset = 0,
    YOffset = 0,
    
    -- Features
    AntiAFK = true,
    AntiKick = false,
    ClickRipple = true,
    AutoSave = false,
    AutoSaveInterval = 300,
    
    -- Visuals
    Theme = "default",
    HUDEnabled = true,
    PerformanceMode = false
}

-- Simple event system
Axiora.Events = {
    _listeners = {}
}

function Axiora.Events:Connect(eventName, callback)
    if not self._listeners[eventName] then
        self._listeners[eventName] = {}
    end
    local id = #self._listeners[eventName] + 1
    self._listeners[eventName][id] = callback
    
    return {
        Disconnect = function()
            self._listeners[eventName][id] = nil
        end
    }
end

function Axiora.Events:Fire(eventName, ...)
    if not self._listeners[eventName] then return end
    for _, callback in pairs(self._listeners[eventName]) do
        if typeof(callback) == "function" then
            task.spawn(function(...)
                pcall(callback, ...)
            end, ...)
        end
    end
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 3: MATH UTILITIES
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Math = {
    Screen = {
        Viewport = Vector2.new(1920, 1080),
        AbsoluteSize = Vector2.new(1920, 1080),
        GuiInset = Vector2.new(0, 0),
        Initialized = false
    }
}

function Axiora.Math.UpdateScreenMetrics()
    local success = pcall(function()
        local cam = Workspace.CurrentCamera
        if cam then
            Axiora.Math.Screen.Viewport = cam.ViewportSize
        end
        
        if GuiService and GuiService.GetGuiInset then
            Axiora.Math.Screen.GuiInset = GuiService:GetGuiInset()
        end
        
        local vp = Axiora.Math.Screen.Viewport
        local inset = Axiora.Math.Screen.GuiInset
        Axiora.Math.Screen.AbsoluteSize = Vector2.new(vp.X, vp.Y + inset.Y)
        Axiora.Math.Screen.Initialized = true
    end)
    return success
end

-- Wait for screen metrics to be valid
function Axiora.Math.WaitForInit(timeout)
    timeout = timeout or 2
    local start = os.clock()
    
    while (os.clock() - start) < timeout do
        Axiora.Math.UpdateScreenMetrics()
        if Axiora.Math.Screen.Viewport.X > 100 then
            return true
        end
        task.wait(0.1)
    end
    return false
end

-- Convert relative coords (0-1) to absolute screen position
function Axiora.Math.GetAbsoluteInput(relX, relY)
    local screen = Axiora.Math.Screen.AbsoluteSize
    if screen.X < 10 then screen = Vector2.new(1920, 1080) end
    
    local x = relX * screen.X + (Axiora.Settings.XOffset or 0)
    local y = relY * screen.Y + (Axiora.Settings.YOffset or 0)
    
    x = math.clamp(x, 0, screen.X)
    y = math.clamp(y, 0, screen.Y)
    
    return Vector2.new(x, y)
end

-- Convert absolute screen position to relative coords (0-1)
function Axiora.Math.GetRelativeInput(absX, absY)
    local screen = Axiora.Math.Screen.AbsoluteSize
    if screen.X < 10 then screen = Vector2.new(1920, 1080) end
    
    return {
        x = math.clamp(absX / screen.X, 0, 1),
        y = math.clamp(absY / screen.Y, 0, 1)
    }
end

-- Serialize Vector3 to compact array
function Axiora.Math.SerializeVec(v)
    if not v then return {0, 0, 0} end
    return {
        math.floor(v.X * 100) / 100,
        math.floor(v.Y * 100) / 100,
        math.floor(v.Z * 100) / 100
    }
end

-- Deserialize array to Vector3
function Axiora.Math.DeserializeVec(t)
    if not t or type(t) ~= "table" then return Vector3.zero end
    return Vector3.new(t[1] or 0, t[2] or 0, t[3] or 0)
end

-- Serialize CFrame to component array
function Axiora.Math.SerializeCF(cf)
    if not cf then return nil end
    local components = {cf:GetComponents()}
    for i, v in ipairs(components) do
        components[i] = math.floor(v * 1000) / 1000
    end
    return components
end

-- Deserialize array to CFrame
function Axiora.Math.DeserializeCF(t)
    if not t or type(t) ~= "table" or #t ~= 12 then return nil end
    local success, result = pcall(function()
        return CFrame.new(table.unpack(t))
    end)
    return success and result or nil
end

-- Initialize screen metrics
task.spawn(function()
    task.wait(0.5)
    Axiora.Math.WaitForInit(3)
end)

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 4: INPUT SYSTEM (Multi-Executor Compatible)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Input = {
    Method = "VIM", -- Delta, Native, VIM
    ClickDelay = 0.02
}

-- Detect best input method
local function detectInputMethod()
    -- Check for Delta's native input
    if Axiora.Capabilities.IsDelta then
        local deltaGlobal = Root.delta or Root.Delta
        if deltaGlobal and typeof(deltaGlobal.input) == "table" then
            Axiora.Input.Method = "Delta"
            Axiora.Input._deltaInput = deltaGlobal.input
            return
        end
    end
    
    -- Check for native mouse functions
    if Axiora.Capabilities.MouseMoveAbs and Axiora.Capabilities.MouseClick then
        Axiora.Input.Method = "Native"
        return
    end
    
    -- Fallback to VirtualInputManager
    Axiora.Input.Method = "VIM"
end

detectInputMethod()

-- Universal click function
function Axiora.Input.Click(x, y, nonBlocking)
    local startTime = os.clock()
    
    -- Delta method (fastest)
    if Axiora.Input.Method == "Delta" and Axiora.Input._deltaInput then
        local success = pcall(function()
            if Axiora.Input._deltaInput.mouse_move then
                Axiora.Input._deltaInput.mouse_move(x, y)
            end
            task.wait(0.01)
            if Axiora.Input._deltaInput.mouse_click then
                Axiora.Input._deltaInput.mouse_click()
            end
        end)
        if success then return true, os.clock() - startTime end
    end
    
    -- Native method
    if Axiora.Input.Method == "Native" then
        local success = pcall(function()
            mousemoveabs(x, y)
            if not nonBlocking then task.wait(Axiora.Input.ClickDelay) end
            mouse1click()
        end)
        if success then return true, os.clock() - startTime end
    end
    
    -- VIM fallback
    if VirtualInputManager then
        if nonBlocking then
            task.spawn(function()
                pcall(function()
                    VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 1)
                    task.wait(0.03)
                    VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 1)
                end)
            end)
            return true, 0
        else
            local success = pcall(function()
                VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 1)
                task.wait(0.03)
                VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 1)
            end)
            return success, os.clock() - startTime
        end
    end
    
    return false, 0
end

-- Universal key press function
function Axiora.Input.KeyPress(keyCode, duration)
    duration = duration or 0.05
    
    -- Delta method
    if Axiora.Input.Method == "Delta" and Axiora.Input._deltaInput then
        local success = pcall(function()
            if Axiora.Input._deltaInput.key_press then
                Axiora.Input._deltaInput.key_press(keyCode)
                task.wait(duration)
                Axiora.Input._deltaInput.key_release(keyCode)
            end
        end)
        if success then return true end
    end
    
    -- Native method
    if Axiora.Capabilities.KeyPress and Axiora.Capabilities.KeyRelease then
        local success = pcall(function()
            keypress(keyCode)
            task.wait(duration)
            keyrelease(keyCode)
        end)
        if success then return true end
    end
    
    -- VIM fallback
    if VirtualInputManager then
        pcall(function()
            VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
            task.wait(duration)
            VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
        end)
        return true
    end
    
    return false
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 5: RECORDING ENGINE
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Recording = {
    Active = false,
    StartTime = 0,
    LastNodeTime = 0,
    NodeCount = 0,
    LastPos = Vector3.zero,
    LastCamCF = CFrame.new(),
    LastClickPos = Vector2.zero,
    LastClickTime = 0
}

-- Clean disconnect all recording connections
local function cleanupRecordingConnections()
    for key, conn in pairs(Axiora.State.Connections) do
        if typeof(conn) == "RBXScriptConnection" then
            pcall(function() conn:Disconnect() end)
        end
    end
    Axiora.State.Connections = {}
end

-- Add a node with optimization
local function addNode(node)
    if #Axiora.State.Buffer >= Axiora.Settings.MaxBufferSize then
        Axiora.Stop()
        Axiora.Events:Fire("BufferFull")
        return false
    end
    
    table.insert(Axiora.State.Buffer, node)
    Axiora.Recording.NodeCount = Axiora.Recording.NodeCount + 1
    return true
end

-- Check if we should record this position (smart filtering)
local function shouldRecordPosition(currentPos, timeSinceLastNode)
    if not Axiora.Settings.SmartRecording then return true end
    
    local distance = (currentPos - Axiora.Recording.LastPos).Magnitude
    if distance < Axiora.Settings.MinMoveDistance then
        return false
    end
    
    if timeSinceLastNode < 0.05 then
        return false
    end
    
    return true
end

function Axiora.Record()
    Axiora.Stop()
    
    -- Wait for math initialization
    Axiora.Math.WaitForInit(2)
    
    local LP = getLocalPlayer()
    if not LP then
        Axiora.Events:Fire("Error", {Message = "No local player"})
        return false
    end
    
    -- Initialize state
    Axiora.State.Status = "RECORDING"
    Axiora.State.Buffer = {}
    Axiora.State.StartTime = os.clock()
    Axiora.Recording.Active = true
    Axiora.Recording.StartTime = os.clock()
    Axiora.Recording.LastNodeTime = os.clock()
    Axiora.Recording.NodeCount = 0
    Axiora.Recording.LastPos = Vector3.zero
    Axiora.Recording.LastCamCF = CFrame.new()
    Axiora.Recording.LastClickPos = Vector2.zero
    Axiora.Recording.LastClickTime = 0
    
    -- Movement recording
    Axiora.State.Connections.Move = RunService.Heartbeat:Connect(function()
        local char = LP.Character
        if not char then return end
        
        local root = char:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChildOfClass("Humanoid")
        if not root or not hum then return end
        
        local pos = root.Position
        local now = os.clock()
        local timeSinceLastNode = now - Axiora.Recording.LastNodeTime
        
        local camChanged = false
        local cam = Workspace.CurrentCamera
        if Axiora.Settings.RecordCamera and cam then
            local camRotDiff = math.abs((cam.CFrame.LookVector - Axiora.Recording.LastCamCF.LookVector).Magnitude)
            if camRotDiff > 0.05 then
                camChanged = true
            end
        end
        
        if shouldRecordPosition(pos, timeSinceLastNode) or hum.Jump or (camChanged and timeSinceLastNode > 0.1) then
            local node = {
                t = 1, -- Movement type
                d = now - Axiora.State.StartTime, -- Delay from start
                p = Axiora.Math.SerializeVec(pos),
            }
            
            if hum.Jump then
                node.j = true
            end
            
            if Axiora.Settings.RecordCamera and cam and camChanged then
                node.c = Axiora.Math.SerializeCF(cam.CFrame)
                Axiora.Recording.LastCamCF = cam.CFrame
            end
            
            addNode(node)
            Axiora.Recording.LastPos = pos
            Axiora.Recording.LastNodeTime = now
        end
    end)
    
    -- Input recording (clicks and keys)
    Axiora.State.Connections.Input = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed and not Axiora.Settings.RecordUIClicks then return end
        
        local now = os.clock()
        
        -- Mouse/Touch clicks
        if input.UserInputType == Enum.UserInputType.MouseButton1 or
           input.UserInputType == Enum.UserInputType.Touch then
            
            -- Get click position
            local clickPos
            if input.Position then
                clickPos = Vector2.new(input.Position.X, input.Position.Y)
            else
                clickPos = UserInputService:GetMouseLocation()
            end
            
            -- Get relative coordinates
            local rel = Axiora.Math.GetRelativeInput(clickPos.X, clickPos.Y)
            
            -- Filter duplicate clicks
            local clickDist = math.abs(rel.x - Axiora.Recording.LastClickPos.X) + 
                             math.abs(rel.y - Axiora.Recording.LastClickPos.Y)
            local timeSinceLastClick = now - Axiora.Recording.LastClickTime
            
            if clickDist < 0.01 and timeSinceLastClick < Axiora.Settings.MinClickInterval then
                return -- Skip duplicate
            end
            
            local node = {
                t = 2, -- Click type
                d = now - Axiora.State.StartTime,
                x = rel.x,
                y = rel.y,
                ui = gameProcessed or nil
            }
            
            addNode(node)
            Axiora.Recording.LastClickPos = Vector2.new(rel.x, rel.y)
            Axiora.Recording.LastClickTime = now
            
            -- Visual feedback
            if Axiora.Settings.ClickRipple and Axiora.Visuals and Axiora.Visuals.Ripple then
                Axiora.Visuals.Ripple(clickPos.X, clickPos.Y)
            end
            
        -- Keyboard
        elseif input.UserInputType == Enum.UserInputType.Keyboard then
            local node = {
                t = 3, -- Key type
                d = now - Axiora.State.StartTime,
                k = input.KeyCode.Name
            }
            addNode(node)
        end
    end)
    
    Axiora.Events:Fire("RecordingStarted", {
        Mode = Axiora.Settings.SmartRecording and "Smart" or "Full"
    })
    
    return true
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 6: PLAYBACK ENGINE
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Playback = {
    Active = false,
    Paused = false,
    CurrentIndex = 0,
    LoopCount = 0,
    Speed = 1.0,
    Mode = "normal" -- normal, fast, precise
}

-- Navigate to a position with retry logic
local function navigateToPosition(hum, root, targetPos, timeout, retries)
    timeout = timeout or Axiora.Settings.NavigationTimeout
    retries = retries or Axiora.Settings.NavigationRetries
    
    local attempt = 0
    
    while attempt < retries do
        if Axiora.State.Status ~= "PLAYING" then return false end
        
        local distance = (root.Position - targetPos).Magnitude
        if distance <= 3 then return true end
        
        hum:MoveTo(targetPos)
        
        local arrived = false
        local startTime = os.clock()
        
        local conn
        conn = hum.MoveToFinished:Connect(function(reached)
            arrived = true
            if reached then distance = 0 end
            if conn then conn:Disconnect() end
        end)
        
        while not arrived and (os.clock() - startTime) < timeout do
            if Axiora.State.Status ~= "PLAYING" then
                if conn then conn:Disconnect() end
                return false
            end
            if (root.Position - targetPos).Magnitude <= 3 then
                arrived = true
                break
            end
            task.wait(0.1)
        end
        
        if conn then conn:Disconnect() end
        
        if (root.Position - targetPos).Magnitude <= 5 then
            return true
        end
        
        -- Retry with jump
        attempt = attempt + 1
        if attempt < retries then
            hum.Jump = true
            task.wait(0.5)
        end
    end
    
    return false
end

function Axiora.Play(loop)
    if #Axiora.State.Buffer == 0 then
        Axiora.Events:Fire("Error", {Message = "No macro loaded"})
        return false
    end
    
    Axiora.Stop()
    Axiora.Math.WaitForInit(2)
    
    local LP = getLocalPlayer()
    if not LP then
        Axiora.Events:Fire("Error", {Message = "No local player"})
        return false
    end
    
    -- Initialize state
    Axiora.State.Status = "PLAYING"
    Axiora.Playback.Active = true
    Axiora.Playback.Paused = false
    Axiora.Playback.CurrentIndex = 0
    Axiora.Playback.LoopCount = 0
    
    -- Determine loop settings
    local loopMode = "once"
    local loopTarget = 1
    
    if loop == true then
        loopMode = "infinite"
    elseif type(loop) == "number" then
        loopMode = "count"
        loopTarget = loop
    end
    
    -- Create snapshot of buffer
    local buffer = {}
    for i, node in ipairs(Axiora.State.Buffer) do
        buffer[i] = node
    end
    local bufferSize = #buffer
    
    -- Playback thread
    local playbackThread = task.spawn(function()
        while Axiora.State.Status == "PLAYING" do
            -- Wait for character
            if not LP.Character then
                LP.CharacterAdded:Wait()
                task.wait(1)
            end
            
            local hum = LP.Character:WaitForChild("Humanoid", 5)
            local root = LP.Character:WaitForChild("HumanoidRootPart", 5)
            
            if not hum or not root then
                Axiora.Events:Fire("Error", {Message = "Character not found"})
                break
            end
            
            -- Navigate to start position
            local firstNode = buffer[1]
            if firstNode and firstNode.p then
                local startPos = Axiora.Math.DeserializeVec(firstNode.p)
                if (root.Position - startPos).Magnitude > 5 then
                    navigateToPosition(hum, root, startPos)
                    task.wait(0.5)
                end
            end
            
            local startTime = os.clock()
            
            -- Execute buffer
            for i, node in ipairs(buffer) do
                if Axiora.State.Status ~= "PLAYING" then break end
                
                -- Handle pause
                while Axiora.Playback.Paused do
                    if Axiora.State.Status ~= "PLAYING" then break end
                    task.wait(0.1)
                end
                
                Axiora.Playback.CurrentIndex = i
                
                -- Wait for timestamp
                local now = os.clock() - startTime
                local targetTime = (node.d or 0) / Axiora.Settings.TimeScale / Axiora.Playback.Speed
                
                if now < targetTime then
                    task.wait(targetTime - now)
                end
                
                if Axiora.State.Status ~= "PLAYING" then break end
                
                -- Execute node based on type
                if node.t == 1 then
                    -- Movement
                    local dest = Axiora.Math.DeserializeVec(node.p)
                    if dest then
                        hum:MoveTo(dest)
                    end
                    if node.j then
                        hum.Jump = true
                    end
                    -- Camera sync
                    if node.c and Axiora.Settings.RecordCamera then
                        local camCF = Axiora.Math.DeserializeCF(node.c)
                        if camCF and Workspace.CurrentCamera then
                            pcall(function()
                                Workspace.CurrentCamera.CFrame = camCF
                            end)
                        end
                    end
                    
                elseif node.t == 2 then
                    -- Click
                    local abs = Axiora.Math.GetAbsoluteInput(node.x, node.y)
                    Axiora.Input.Click(abs.X, abs.Y)
                    
                    if Axiora.Settings.ClickRipple and Axiora.Visuals and Axiora.Visuals.Ripple then
                        Axiora.Visuals.Ripple(abs.X, abs.Y)
                    end
                    
                elseif node.t == 3 then
                    -- Keyboard
                    local keyCode = Enum.KeyCode[node.k]
                    if keyCode then
                        Axiora.Input.KeyPress(keyCode)
                    end
                end
                
                -- Progress event every 10 nodes
                if i % 10 == 0 then
                    Axiora.Events:Fire("PlaybackProgress", {
                        Current = i,
                        Total = bufferSize,
                        Percent = math.floor(i / bufferSize * 100)
                    })
                end
            end
            
            -- Loop logic
            Axiora.Playback.LoopCount = Axiora.Playback.LoopCount + 1
            
            local shouldContinue = false
            if loopMode == "infinite" then
                shouldContinue = true
            elseif loopMode == "count" then
                shouldContinue = Axiora.Playback.LoopCount < loopTarget
            end
            
            if not shouldContinue then break end
            
            task.wait(1)
        end
        
        Axiora.Events:Fire("PlaybackComplete", {
            NodesPlayed = Axiora.Playback.CurrentIndex,
            TotalNodes = bufferSize,
            Loops = Axiora.Playback.LoopCount
        })
        
        Axiora.Stop()
    end)
    
    table.insert(Axiora.State.Threads, playbackThread)
    
    Axiora.Events:Fire("PlaybackStarted", {
        Nodes = bufferSize,
        Loop = loopMode
    })
    
    return true
end

function Axiora.Pause()
    if Axiora.State.Status == "PLAYING" then
        Axiora.Playback.Paused = not Axiora.Playback.Paused
        Axiora.Events:Fire("PlaybackPauseToggled", Axiora.Playback.Paused)
        return Axiora.Playback.Paused
    end
    return false
end

function Axiora.Resume()
    if Axiora.State.Status == "PLAYING" and Axiora.Playback.Paused then
        Axiora.Playback.Paused = false
        return true
    end
    return false
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 7: STOP & CLEANUP
-- ═══════════════════════════════════════════════════════════════════════════════

function Axiora.Stop()
    local wasPlaying = Axiora.State.Status == "PLAYING"
    local wasRecording = Axiora.State.Status == "RECORDING"
    
    Axiora.State.Status = "IDLE"
    Axiora.Recording.Active = false
    Axiora.Playback.Active = false
    Axiora.Playback.Paused = false
    
    -- Disconnect regular connections
    for key, conn in pairs(Axiora.State.Connections) do
        if typeof(conn) == "RBXScriptConnection" then
            pcall(function() conn:Disconnect() end)
        end
    end
    Axiora.State.Connections = {}
    
    -- Cancel threads
    for _, t in pairs(Axiora.State.Threads) do
        pcall(function() task.cancel(t) end)
    end
    Axiora.State.Threads = {}
    
    -- Clear visuals
    if Axiora.Visuals and Axiora.Visuals.Clear then
        pcall(function() Axiora.Visuals.Clear() end)
    end
    
    Axiora.Events:Fire("Stopped", {
        WasRecording = wasRecording,
        WasPlaying = wasPlaying
    })
end

function Axiora.FullStop()
    Axiora.Stop()
    
    -- Also clear security connections
    for _, conn in pairs(Axiora.State.SecurityConnections) do
        pcall(function() conn:Disconnect() end)
    end
    Axiora.State.SecurityConnections = {}
    
    Axiora.Events:Fire("FullStopped")
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 8: VISUAL SYSTEM (Notifications, HUD, Ripples)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Visuals = {
    ScreenGui = nil,
    HUDFrame = nil,
    NotificationContainer = nil,
    Objects = {},
    Folder = nil,
    NotificationQueue = {},
    NotificationCooldown = false
}

-- Theme colors
Axiora.Visuals.Themes = {
    default = {
        Name = "Axiora Quantum",
        Primary = Color3.fromRGB(0, 180, 255),
        Secondary = Color3.fromRGB(0, 120, 180),
        Background = Color3.fromRGB(18, 18, 25),
        Surface = Color3.fromRGB(25, 25, 35),
        Text = Color3.fromRGB(245, 245, 255),
        TextDim = Color3.fromRGB(150, 150, 170),
        Success = Color3.fromRGB(0, 200, 100),
        Warning = Color3.fromRGB(255, 180, 0),
        Error = Color3.fromRGB(255, 60, 80),
        Info = Color3.fromRGB(100, 200, 255)
    },
    crimson = {
        Name = "Crimson Pulse",
        Primary = Color3.fromRGB(220, 50, 80),
        Secondary = Color3.fromRGB(180, 30, 60),
        Background = Color3.fromRGB(20, 15, 18),
        Surface = Color3.fromRGB(30, 22, 26),
        Text = Color3.fromRGB(255, 245, 248),
        TextDim = Color3.fromRGB(180, 150, 160),
        Success = Color3.fromRGB(50, 200, 120),
        Warning = Color3.fromRGB(255, 200, 0),
        Error = Color3.fromRGB(255, 80, 100),
        Info = Color3.fromRGB(220, 100, 150)
    },
    emerald = {
        Name = "Emerald Matrix",
        Primary = Color3.fromRGB(0, 200, 100),
        Secondary = Color3.fromRGB(0, 150, 75),
        Background = Color3.fromRGB(12, 20, 16),
        Surface = Color3.fromRGB(18, 28, 22),
        Text = Color3.fromRGB(240, 255, 245),
        TextDim = Color3.fromRGB(140, 170, 150),
        Success = Color3.fromRGB(0, 255, 130),
        Warning = Color3.fromRGB(255, 200, 50),
        Error = Color3.fromRGB(255, 80, 80),
        Info = Color3.fromRGB(100, 220, 180)
    }
}

function Axiora.Visuals.GetTheme()
    return Axiora.Visuals.Themes[Axiora.Settings.Theme] or Axiora.Visuals.Themes.default
end

function Axiora.Visuals.SetTheme(themeName)
    if Axiora.Visuals.Themes[themeName] then
        Axiora.Settings.Theme = themeName
        Axiora.Events:Fire("ThemeChanged", themeName)
        return true
    end
    return false
end

-- Initialize screen GUI
function Axiora.Visuals.Init()
    if Axiora.Visuals.ScreenGui then
        pcall(function() Axiora.Visuals.ScreenGui:Destroy() end)
    end
    
    local sg = Instance.new("ScreenGui")
    sg.Name = "AxioraVisuals"
    sg.IgnoreGuiInset = true
    sg.ResetOnSpawn = false
    sg.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    -- Try CoreGui first, fallback to PlayerGui
    local success = pcall(function()
        sg.Parent = CoreGui
    end)
    if not success then
        local LP = getLocalPlayer()
        if LP and LP:FindFirstChild("PlayerGui") then
            sg.Parent = LP.PlayerGui
        end
    end
    
    Axiora.Visuals.ScreenGui = sg
    
    -- Create notification container
    local notifContainer = Instance.new("Frame")
    notifContainer.Name = "Notifications"
    notifContainer.BackgroundTransparency = 1
    notifContainer.Size = UDim2.new(0, 320, 1, 0)
    notifContainer.Position = UDim2.new(1, -330, 0, 10)
    notifContainer.AnchorPoint = Vector2.new(0, 0)
    notifContainer.Parent = sg
    
    local layout = Instance.new("UIListLayout")
    layout.SortOrder = Enum.SortOrder.LayoutOrder
    layout.Padding = UDim.new(0, 8)
    layout.VerticalAlignment = Enum.VerticalAlignment.Top
    layout.Parent = notifContainer
    
    Axiora.Visuals.NotificationContainer = notifContainer
    
    return sg
end

-- Notification function
function Axiora.Visuals.Notify(title, message, duration, notifType)
    duration = duration or 3
    notifType = notifType or "info"
    
    if not Axiora.Visuals.NotificationContainer then
        Axiora.Visuals.Init()
    end
    
    if Axiora.Visuals.NotificationCooldown then
        -- Queue it
        table.insert(Axiora.Visuals.NotificationQueue, {
            title = title, message = message, duration = duration, notifType = notifType
        })
        return
    end
    
    Axiora.Visuals.NotificationCooldown = true
    
    local theme = Axiora.Visuals.GetTheme()
    local typeColors = {
        success = theme.Success,
        warning = theme.Warning,
        error = theme.Error,
        info = theme.Info
    }
    local accentColor = typeColors[notifType] or theme.Primary
    
    -- Create notification frame
    local notif = Instance.new("Frame")
    notif.Name = "Notification"
    notif.BackgroundColor3 = theme.Surface
    notif.BackgroundTransparency = 0.1
    notif.Size = UDim2.new(1, 0, 0, 65)
    notif.Position = UDim2.new(1, 0, 0, 0) -- Start off-screen
    notif.BorderSizePixel = 0
    notif.ClipsDescendants = true
    notif.LayoutOrder = os.clock() * 1000
    notif.Parent = Axiora.Visuals.NotificationContainer
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = notif
    
    -- Accent bar
    local accent = Instance.new("Frame")
    accent.Name = "Accent"
    accent.BackgroundColor3 = accentColor
    accent.Size = UDim2.new(0, 4, 1, 0)
    accent.BorderSizePixel = 0
    accent.Parent = notif
    
    -- Title
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "Title"
    titleLabel.BackgroundTransparency = 1
    titleLabel.Size = UDim2.new(1, -20, 0, 22)
    titleLabel.Position = UDim2.new(0, 15, 0, 8)
    titleLabel.Text = title or "Axiora"
    titleLabel.TextColor3 = theme.Text
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.TextSize = 14
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.Parent = notif
    
    -- Message
    local msgLabel = Instance.new("TextLabel")
    msgLabel.Name = "Message"
    msgLabel.BackgroundTransparency = 1
    msgLabel.Size = UDim2.new(1, -20, 0, 30)
    msgLabel.Position = UDim2.new(0, 15, 0, 30)
    msgLabel.Text = message or ""
    msgLabel.TextColor3 = theme.TextDim
    msgLabel.Font = Enum.Font.Gotham
    msgLabel.TextSize = 12
    msgLabel.TextXAlignment = Enum.TextXAlignment.Left
    msgLabel.TextTruncate = Enum.TextTruncate.AtEnd
    msgLabel.TextWrapped = true
    msgLabel.Parent = notif
    
    -- Slide in animation
    local tweenIn = TweenService:Create(notif, TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {
        Position = UDim2.new(0, 0, 0, 0)
    })
    tweenIn:Play()
    
    -- Auto-dismiss
    task.delay(duration, function()
        if notif and notif.Parent then
            local tweenOut = TweenService:Create(notif, TweenInfo.new(0.25, Enum.EasingStyle.Quart), {
                Position = UDim2.new(1, 10, 0, 0),
                BackgroundTransparency = 1
            })
            tweenOut:Play()
            tweenOut.Completed:Wait()
            pcall(function() notif:Destroy() end)
        end
    end)
    
    -- Cooldown then process queue
    task.delay(0.3, function()
        Axiora.Visuals.NotificationCooldown = false
        if #Axiora.Visuals.NotificationQueue > 0 then
            local queued = table.remove(Axiora.Visuals.NotificationQueue, 1)
            Axiora.Visuals.Notify(queued.title, queued.message, queued.duration, queued.notifType)
        end
    end)
end

-- Ripple effect for clicks
function Axiora.Visuals.Ripple(x, y)
    if Axiora.Settings.PerformanceMode then return end
    if not Axiora.Visuals.ScreenGui then return end
    
    local theme = Axiora.Visuals.GetTheme()
    
    local r = Instance.new("Frame")
    r.Position = UDim2.fromOffset(x, y)
    r.Size = UDim2.fromOffset(0, 0)
    r.AnchorPoint = Vector2.new(0.5, 0.5)
    r.BackgroundColor3 = theme.Primary
    r.BackgroundTransparency = 0.4
    r.BorderSizePixel = 0
    r.ZIndex = 10
    r.Parent = Axiora.Visuals.ScreenGui
    
    Instance.new("UICorner", r).CornerRadius = UDim.new(1, 0)
    
    local tween = TweenService:Create(r, TweenInfo.new(0.5, Enum.EasingStyle.Quad), {
        Size = UDim2.fromOffset(80, 80),
        BackgroundTransparency = 1
    })
    tween:Play()
    tween.Completed:Connect(function()
        pcall(function() r:Destroy() end)
    end)
end

-- Create simple HUD
function Axiora.Visuals.CreateHUD()
    if not Axiora.Settings.HUDEnabled then return end
    
    if not Axiora.Visuals.ScreenGui then
        Axiora.Visuals.Init()
    end
    
    -- Remove old HUD
    if Axiora.Visuals.HUDFrame then
        pcall(function() Axiora.Visuals.HUDFrame:Destroy() end)
    end
    
    local theme = Axiora.Visuals.GetTheme()
    
    local hud = Instance.new("Frame")
    hud.Name = "HUD"
    hud.BackgroundColor3 = theme.Background
    hud.BackgroundTransparency = 0.15
    hud.Size = UDim2.new(0, 180, 0, 100)
    hud.Position = UDim2.new(0, 15, 0, 50)
    hud.BorderSizePixel = 0
    hud.Parent = Axiora.Visuals.ScreenGui
    
    Instance.new("UICorner", hud).CornerRadius = UDim.new(0, 10)
    
    local stroke = Instance.new("UIStroke")
    stroke.Color = theme.Primary
    stroke.Transparency = 0.5
    stroke.Thickness = 1.5
    stroke.Parent = hud
    
    -- Title
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.BackgroundTransparency = 1
    title.Size = UDim2.new(1, 0, 0, 25)
    title.Text = "AXIORA v" .. Axiora._VERSION
    title.TextColor3 = theme.Primary
    title.Font = Enum.Font.GothamBlack
    title.TextSize = 12
    title.Parent = hud
    
    -- Status
    local status = Instance.new("TextLabel")
    status.Name = "Status"
    status.BackgroundTransparency = 1
    status.Size = UDim2.new(1, 0, 0, 20)
    status.Position = UDim2.new(0, 0, 0, 28)
    status.Text = "IDLE"
    status.TextColor3 = theme.TextDim
    status.Font = Enum.Font.GothamBold
    status.TextSize = 11
    status.Parent = hud
    
    -- Buffer info
    local bufferInfo = Instance.new("TextLabel")
    bufferInfo.Name = "BufferInfo"
    bufferInfo.BackgroundTransparency = 1
    bufferInfo.Size = UDim2.new(1, 0, 0, 20)
    bufferInfo.Position = UDim2.new(0, 0, 0, 50)
    bufferInfo.Text = "Buffer: 0 nodes"
    bufferInfo.TextColor3 = theme.TextDim
    bufferInfo.Font = Enum.Font.Gotham
    bufferInfo.TextSize = 10
    status.Parent = hud
    
    -- Executor info
    local execInfo = Instance.new("TextLabel")
    execInfo.Name = "ExecInfo"
    execInfo.BackgroundTransparency = 1
    execInfo.Size = UDim2.new(1, 0, 0, 20)
    execInfo.Position = UDim2.new(0, 0, 0, 72)
    execInfo.Text = "Executor: " .. Axiora.Capabilities.Executor
    execInfo.TextColor3 = theme.TextDim
    execInfo.Font = Enum.Font.Gotham
    execInfo.TextSize = 9
    execInfo.Parent = hud
    
    Axiora.Visuals.HUDFrame = hud
    
    -- Update loop
    local hudThread = task.spawn(function()
        while hud and hud.Parent do
            if Axiora.State.Status then
                status.Text = Axiora.State.Status
                status.TextColor3 = Axiora.State.Status == "PLAYING" and theme.Success
                    or Axiora.State.Status == "RECORDING" and theme.Error
                    or Axiora.State.Status == "PAUSED" and theme.Warning
                    or theme.TextDim
            end
            bufferInfo.Text = "Buffer: " .. #Axiora.State.Buffer .. " nodes"
            task.wait(0.5)
        end
    end)
    table.insert(Axiora.State.Threads, hudThread)
    
    -- Dragging
    local dragging = false
    local dragStart, startPos
    
    hud.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = UserInputService:GetMouseLocation()
            startPos = hud.Position
        end
    end)
    
    hud.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local current = UserInputService:GetMouseLocation()
            local delta = current - dragStart
            hud.Position = UDim2.new(
                startPos.X.Scale, startPos.X.Offset + delta.X,
                startPos.Y.Scale, startPos.Y.Offset + delta.Y
            )
        end
    end)
    
    return hud
end

-- Show/Hide HUD
function Axiora.Visuals.ToggleHUD()
    if Axiora.Visuals.HUDFrame then
        Axiora.Visuals.HUDFrame.Visible = not Axiora.Visuals.HUDFrame.Visible
        return Axiora.Visuals.HUDFrame.Visible
    end
    return false
end

-- Clear visual objects
function Axiora.Visuals.Clear()
    for _, obj in ipairs(Axiora.Visuals.Objects) do
        pcall(function()
            if obj and obj.Parent then obj:Destroy() end
        end)
    end
    Axiora.Visuals.Objects = {}
    
    if Axiora.Visuals.Folder then
        pcall(function() Axiora.Visuals.Folder:Destroy() end)
        Axiora.Visuals.Folder = nil
    end
end

-- Render path visualization
function Axiora.Visuals.RenderPath(mode)
    Axiora.Visuals.Clear()
    
    if #Axiora.State.Buffer == 0 then return end
    
    mode = mode or "simple"
    local theme = Axiora.Visuals.GetTheme()
    
    local folder = Instance.new("Folder")
    folder.Name = "Axiora_PathVisual"
    folder.Parent = Workspace
    Axiora.Visuals.Folder = folder
    
    local spacing = Axiora.Settings.PerformanceMode and 5 or 2
    
    for i = 1, #Axiora.State.Buffer, spacing do
        local node = Axiora.State.Buffer[i]
        if node and node.t == 1 and node.p then
            local pos = Axiora.Math.DeserializeVec(node.p)
            
            local part = Instance.new("Part")
            part.Name = "Node_" .. i
            part.Size = Vector3.new(0.4, 0.4, 0.4)
            part.Shape = Enum.PartType.Ball
            part.Anchored = true
            part.CanCollide = false
            part.Material = Enum.Material.Neon
            part.Color = theme.Primary
            part.Transparency = 0.5
            part.Position = pos
            part.CastShadow = false
            part.Parent = folder
            
            table.insert(Axiora.Visuals.Objects, part)
        end
        
        -- Yield every 50 objects to prevent lag
        if i % 50 == 0 then task.wait() end
    end
    
    Axiora.Visuals.Notify("Render", #Axiora.Visuals.Objects .. " nodes rendered", 2, "success")
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 9: FILE SYSTEM
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Files = {
    BaseFolder = "Axiora",
    SaveFolder = "Axiora/Saves",
    SettingsFile = "Axiora/settings.json"
}

function Axiora.Files.EnsureFolder(path)
    if not Axiora.Capabilities.MakeFolder then return false end
    
    local success = pcall(function()
        if Axiora.Capabilities.IsFolder and not isfolder(path) then
            makefolder(path)
        elseif not Axiora.Capabilities.IsFolder then
            makefolder(path)
        end
    end)
    return success
end

function Axiora.Files.Init()
    Axiora.Files.EnsureFolder(Axiora.Files.BaseFolder)
    Axiora.Files.EnsureFolder(Axiora.Files.SaveFolder)
end

function Axiora.Save(name)
    if not Axiora.Capabilities.WriteFile then
        Axiora.Visuals.Notify("Save", "File system not available", 3, "error")
        return false
    end
    
    if #Axiora.State.Buffer == 0 then
        Axiora.Visuals.Notify("Save", "No macro to save", 2, "warning")
        return false
    end
    
    Axiora.Files.EnsureFolder(Axiora.Files.SaveFolder)
    
    name = name or ("macro_" .. os.time())
    local filename = Axiora.Files.SaveFolder .. "/" .. name .. ".axr"
    
    local data = {
        version = Axiora._VERSION,
        name = name,
        savedAt = os.time(),
        placeId = game.PlaceId,
        nodeCount = #Axiora.State.Buffer,
        buffer = Axiora.State.Buffer
    }
    
    local success, err = pcall(function()
        local json = HttpService:JSONEncode(data)
        writefile(filename, json)
    end)
    
    if success then
        Axiora.Visuals.Notify("Save", "Saved: " .. name, 2, "success")
        return true
    else
        Axiora.Visuals.Notify("Save", "Failed to save", 3, "error")
        return false
    end
end

function Axiora.Load(name)
    if not Axiora.Capabilities.ReadFile then
        Axiora.Visuals.Notify("Load", "File system not available", 3, "error")
        return false
    end
    
    local filename = Axiora.Files.SaveFolder .. "/" .. name .. ".axr"
    
    local success, data = pcall(function()
        local json = readfile(filename)
        return HttpService:JSONDecode(json)
    end)
    
    if success and data and data.buffer then
        Axiora.State.Buffer = data.buffer
        Axiora.Visuals.Notify("Load", "Loaded: " .. (data.name or name) .. " (" .. #data.buffer .. " nodes)", 3, "success")
        Axiora.Events:Fire("MacroLoaded", {Name = data.name, Nodes = #data.buffer})
        return true
    else
        Axiora.Visuals.Notify("Load", "Failed to load file", 3, "error")
        return false
    end
end

function Axiora.ListSaves()
    if not Axiora.Capabilities.ReadFile then return {} end
    
    local saves = {}
    local success = pcall(function()
        if listfiles then
            local files = listfiles(Axiora.Files.SaveFolder)
            for _, file in ipairs(files) do
                if file:match("%.axr$") then
                    local name = file:match("([^/\\]+)%.axr$")
                    if name then
                        table.insert(saves, name)
                    end
                end
            end
        end
    end)
    return saves
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 10: STRATEGY LOADER (URL Loading)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.StrategyLoader = {
    Current = nil,
    Loading = false,
    TrustedDomains = {
        "pastebin.com",
        "raw.githubusercontent.com",
        "gist.githubusercontent.com"
    }
}

-- Universal HTTP request function
local function httpGet(url)
    -- Try request() first (most compatible)
    if typeof(request) == "function" then
        local response = request({Url = url, Method = "GET"})
        if response and response.Success then
            return response.Body
        end
    end
    
    if typeof(http_request) == "function" then
        local response = http_request({Url = url, Method = "GET"})
        if response and response.Success then
            return response.Body
        end
    end
    
    -- Synapse X
    if typeof(syn) == "table" and typeof(syn.request) == "function" then
        local response = syn.request({Url = url, Method = "GET"})
        if response and response.Success then
            return response.Body
        end
    end
    
    -- game:HttpGet fallback
    if game.HttpGet then
        return game:HttpGet(url)
    end
    
    error("No HTTP method available")
end

-- Sanitize URL for raw content
local function sanitizeURL(url)
    if not url or type(url) ~= "string" then return nil end
    
    url = url:gsub("^%s+", ""):gsub("%s+$", "")
    
    if not url:find("^https?://") then
        url = "https://" .. url
    end
    
    -- Pastebin: convert to raw
    if url:find("pastebin.com/") and not url:find("pastebin.com/raw/") then
        local id = url:match("pastebin%.com/([%w]+)$")
        if id then url = "https://pastebin.com/raw/" .. id end
    end
    
    return url
end

function Axiora.StrategyLoader.FetchFromURL(url, options)
    options = options or {}
    
    if Axiora.StrategyLoader.Loading then
        Axiora.Visuals.Notify("Loader", "Already loading...", 2, "warning")
        return false
    end
    
    url = sanitizeURL(url)
    if not url then
        Axiora.Visuals.Notify("Loader", "Invalid URL", 2, "error")
        return false
    end
    
    Axiora.StrategyLoader.Loading = true
    Axiora.Visuals.Notify("Loader", "Fetching strategy...", 2, "info")
    
    task.spawn(function()
        local success, response = pcall(function()
            return httpGet(url)
        end)
        
        if not success or not response then
            Axiora.StrategyLoader.Loading = false
            Axiora.Visuals.Notify("Loader", "Failed to fetch URL", 3, "error")
            return
        end
        
        -- Try to parse as JSON
        local data = nil
        local parseSuccess = pcall(function()
            data = HttpService:JSONDecode(response)
        end)
        
        if not parseSuccess or not data then
            Axiora.StrategyLoader.Loading = false
            Axiora.Visuals.Notify("Loader", "Failed to parse data", 3, "error")
            return
        end
        
        -- Convert to Axiora format
        local convertSuccess = Axiora.StrategyLoader.Convert(data)
        
        Axiora.StrategyLoader.Loading = false
        
        if convertSuccess then
            Axiora.StrategyLoader.Current = {
                Data = data,
                URL = url,
                LoadedAt = os.clock()
            }
            Axiora.Events:Fire("StrategyLoaded", Axiora.StrategyLoader.Current)
        end
    end)
    
    return true
end

-- Convert external format to Axiora buffer
function Axiora.StrategyLoader.Convert(data)
    if not data then return false end
    
    local nodes = {}
    local timeOffset = 0
    
    -- Check for Axiora native format
    if data.buffer or data.nodes then
        Axiora.State.Buffer = data.buffer or data.nodes
        Axiora.Visuals.Notify("Loader", "Loaded " .. #Axiora.State.Buffer .. " nodes", 3, "success")
        return true
    end
    
    -- Check for actions array (Stratz-like format)
    local actions = data.actions or data.events or data
    if type(actions) ~= "table" then
        Axiora.Visuals.Notify("Loader", "Unknown format", 3, "error")
        return false
    end
    
    for i, act in ipairs(actions) do
        if type(act) == "table" then
            local delay = tonumber(act.delay) or tonumber(act.wait) or 0
            timeOffset = timeOffset + delay
            
            local eventType = (act.event or act.type or act.action or ""):lower()
            
            if eventType == "click" or eventType == "tap" then
                local x = tonumber(act.x) or 0
                local y = tonumber(act.y) or 0
                
                -- Normalize if values seem like absolute coords
                if x > 1 or y > 1 then
                    local res = data.resolution or {width = 1920, height = 1080}
                    x = x / (res.width or 1920)
                    y = y / (res.height or 1080)
                end
                
                table.insert(nodes, {
                    t = 2,
                    d = timeOffset,
                    x = x,
                    y = y
                })
                
            elseif eventType == "key" or eventType == "keyboard" then
                table.insert(nodes, {
                    t = 3,
                    d = timeOffset,
                    k = act.key or act.keycode
                })
                
            elseif eventType == "move" or eventType == "position" then
                local pos = act.position or {x = act.x, y = act.y, z = act.z}
                table.insert(nodes, {
                    t = 1,
                    d = timeOffset,
                    p = {pos.x or 0, pos.y or 0, pos.z or 0}
                })
            end
        end
    end
    
    if #nodes > 0 then
        Axiora.State.Buffer = nodes
        Axiora.Visuals.Notify("Loader", "Converted " .. #nodes .. " nodes", 3, "success")
        return true
    end
    
    Axiora.Visuals.Notify("Loader", "No valid actions found", 3, "warning")
    return false
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 11: HOTKEY SYSTEM
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Hotkeys = {
    Enabled = true,
    Bindings = {
        Record = Enum.KeyCode.F1,
        Play = Enum.KeyCode.F2,
        Stop = Enum.KeyCode.F3,
        ToggleUI = Enum.KeyCode.F4,
        ToggleHUD = Enum.KeyCode.F8
    },
    Connection = nil,
    LastTrigger = {},
    Cooldown = 0.3
}

function Axiora.Hotkeys.CanTrigger(keyCode)
    local now = os.clock()
    local last = Axiora.Hotkeys.LastTrigger[keyCode] or 0
    if (now - last) < Axiora.Hotkeys.Cooldown then
        return false
    end
    Axiora.Hotkeys.LastTrigger[keyCode] = now
    return true
end

function Axiora.Hotkeys.Init()
    if Axiora.Hotkeys.Connection then
        pcall(function() Axiora.Hotkeys.Connection:Disconnect() end)
    end
    
    Axiora.Hotkeys.Connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not Axiora.Hotkeys.Enabled then return end
        if gameProcessed then return end
        if input.UserInputType ~= Enum.UserInputType.Keyboard then return end
        
        local keyCode = input.KeyCode
        
        if not Axiora.Hotkeys.CanTrigger(keyCode) then return end
        
        if keyCode == Axiora.Hotkeys.Bindings.Record then
            if Axiora.State.Status == "RECORDING" then
                Axiora.Stop()
            else
                Axiora.Record()
            end
            
        elseif keyCode == Axiora.Hotkeys.Bindings.Play then
            if Axiora.State.Status == "PLAYING" then
                Axiora.Pause()
            else
                Axiora.Play(true)
            end
            
        elseif keyCode == Axiora.Hotkeys.Bindings.Stop then
            Axiora.Stop()
            
        elseif keyCode == Axiora.Hotkeys.Bindings.ToggleUI then
            if Axiora.UI and Axiora.UI.Toggle then
                Axiora.UI.Toggle()
            end
            
        elseif keyCode == Axiora.Hotkeys.Bindings.ToggleHUD then
            Axiora.Visuals.ToggleHUD()
        end
    end)
    
    Axiora.State.SecurityConnections.Hotkeys = Axiora.Hotkeys.Connection
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 12: SECURITY (Anti-AFK, Anti-Kick)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Security = {
    AntiAFKActive = false,
    AntiKickActive = false
}

function Axiora.Security.EnableAntiAFK()
    if Axiora.Security.AntiAFKActive then return end
    
    local LP = getLocalPlayer()
    if not LP then return end
    
    local success = pcall(function()
        local vu = LP:FindFirstChildOfClass("VirtualUser")
        if not vu then
            vu = Instance.new("VirtualUser")
            vu.Parent = LP
        end
        
        local afkConn = Players.LocalPlayer.Idled:Connect(function()
            vu:CaptureController()
            vu:ClickButton2(Vector2.zero)
        end)
        
        Axiora.State.SecurityConnections.AntiAFK = afkConn
        Axiora.Security.AntiAFKActive = true
    end)
    
    if success then
        Axiora.Visuals.Notify("Security", "Anti-AFK enabled", 2, "success")
    end
end

function Axiora.Security.DisableAntiAFK()
    if Axiora.State.SecurityConnections.AntiAFK then
        pcall(function()
            Axiora.State.SecurityConnections.AntiAFK:Disconnect()
        end)
        Axiora.State.SecurityConnections.AntiAFK = nil
    end
    Axiora.Security.AntiAFKActive = false
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 13: SEQUENCE MANAGER (Multi-Macro Queue)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Sequences = {
    Queue = {},
    CurrentIndex = 0,
    Repeat = false,
    Running = false,
    _connection = nil
}

function Axiora.Sequences.Add(name, buffer, options)
    options = options or {}
    
    local seq = {
        Name = name or ("Sequence_" .. (#Axiora.Sequences.Queue + 1)),
        Buffer = buffer or table.clone(Axiora.State.Buffer),
        Delay = options.delay or 1,
        LoopCount = options.loopCount or 1,
        WaitForCompletion = options.waitForCompletion ~= false
    }
    
    table.insert(Axiora.Sequences.Queue, seq)
    Axiora.Visuals.Notify("Sequences", "Added: " .. seq.Name .. " (" .. #seq.Buffer .. " nodes)", 2, "success")
    Axiora.Events:Fire("SequenceAdded", seq)
    return #Axiora.Sequences.Queue
end

function Axiora.Sequences.AddCurrentBuffer(name, options)
    if #Axiora.State.Buffer == 0 then
        Axiora.Visuals.Notify("Sequences", "Buffer is empty", 2, "warning")
        return nil
    end
    return Axiora.Sequences.Add(name, table.clone(Axiora.State.Buffer), options)
end

function Axiora.Sequences.Remove(index)
    if index <= 0 or index > #Axiora.Sequences.Queue then return false end
    local removed = table.remove(Axiora.Sequences.Queue, index)
    Axiora.Visuals.Notify("Sequences", "Removed: " .. removed.Name, 2, "info")
    return true
end

function Axiora.Sequences.Clear()
    Axiora.Sequences.Queue = {}
    Axiora.Sequences.CurrentIndex = 0
    Axiora.Visuals.Notify("Sequences", "Queue cleared", 2, "info")
end

function Axiora.Sequences.GetQueue()
    local list = {}
    for i, seq in ipairs(Axiora.Sequences.Queue) do
        table.insert(list, {
            Index = i,
            Name = seq.Name,
            Nodes = #seq.Buffer,
            Delay = seq.Delay
        })
    end
    return list
end

function Axiora.Sequences.ExecuteQueue()
    if #Axiora.Sequences.Queue == 0 then
        Axiora.Visuals.Notify("Sequences", "Queue is empty", 2, "warning")
        return false
    end
    
    if Axiora.Sequences.Running then
        Axiora.Visuals.Notify("Sequences", "Already running", 2, "warning")
        return false
    end
    
    Axiora.Sequences.Running = true
    Axiora.Sequences.CurrentIndex = 0
    
    local function executeNext()
        if not Axiora.Sequences.Running then return end
        
        Axiora.Sequences.CurrentIndex = Axiora.Sequences.CurrentIndex + 1
        
        if Axiora.Sequences.CurrentIndex > #Axiora.Sequences.Queue then
            if Axiora.Sequences.Repeat then
                Axiora.Sequences.CurrentIndex = 0
                task.wait(2)
                executeNext()
            else
                Axiora.Sequences.Running = false
                Axiora.Visuals.Notify("Sequences", "Queue completed!", 3, "success")
                Axiora.Events:Fire("QueueCompleted")
            end
            return
        end
        
        local seq = Axiora.Sequences.Queue[Axiora.Sequences.CurrentIndex]
        
        Axiora.Visuals.Notify("Sequence", "Playing: " .. seq.Name .. " (" .. Axiora.Sequences.CurrentIndex .. "/" .. #Axiora.Sequences.Queue .. ")", 3, "info")
        
        -- Load and play
        Axiora.State.Buffer = seq.Buffer
        Axiora.Play(seq.LoopCount > 1)
        
        if seq.WaitForCompletion then
            Axiora.Sequences._connection = Axiora.Events:Connect("Stopped", function()
                if Axiora.Sequences._connection then
                    Axiora.Sequences._connection.Disconnect()
                    Axiora.Sequences._connection = nil
                end
                task.wait(seq.Delay)
                executeNext()
            end)
        else
            task.wait(seq.Delay)
            executeNext()
        end
    end
    
    Axiora.Visuals.Notify("Sequences", "Starting queue (" .. #Axiora.Sequences.Queue .. " sequences)", 2, "info")
    executeNext()
    return true
end

function Axiora.Sequences.StopQueue()
    Axiora.Sequences.Running = false
    if Axiora.Sequences._connection then
        pcall(function() Axiora.Sequences._connection.Disconnect() end)
        Axiora.Sequences._connection = nil
    end
    Axiora.Stop()
    Axiora.Visuals.Notify("Sequences", "Queue stopped", 2, "info")
end

function Axiora.Sequences.SaveQueue(name)
    if not Axiora.Capabilities.WriteFile then return false end
    
    Axiora.Files.EnsureFolder("Axiora/Queues")
    
    local data = {
        Version = Axiora._VERSION,
        QueueName = name,
        Sequences = Axiora.Sequences.Queue,
        Repeat = Axiora.Sequences.Repeat,
        SavedAt = os.time()
    }
    
    local success = pcall(function()
        writefile("Axiora/Queues/" .. name .. ".queue", HttpService:JSONEncode(data))
    end)
    
    if success then
        Axiora.Visuals.Notify("Sequences", "Queue saved: " .. name, 2, "success")
    end
    return success
end

function Axiora.Sequences.LoadQueue(name)
    if not Axiora.Capabilities.ReadFile then return false end
    
    local success, data = pcall(function()
        return HttpService:JSONDecode(readfile("Axiora/Queues/" .. name .. ".queue"))
    end)
    
    if success and data and data.Sequences then
        Axiora.Sequences.Queue = data.Sequences
        Axiora.Sequences.Repeat = data.Repeat or false
        Axiora.Visuals.Notify("Sequences", "Loaded: " .. name, 2, "success")
        return true
    end
    return false
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 14: AUTO-RESTART SYSTEM
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.AutoRestart = {
    Enabled = false,
    OnDeath = true,
    MaxRestarts = 10,
    RestartCount = 0,
    RestartDelay = 5,
    LastRestartTime = 0,
    RestartCooldown = 10,
    _initialized = false,
    _characterConnection = nil,
    _deathConnection = nil
}

function Axiora.AutoRestart.Enable()
    if Axiora.AutoRestart.Enabled then return end
    
    Axiora.AutoRestart.Enabled = true
    Axiora.AutoRestart.RestartCount = 0
    Axiora.AutoRestart.LastRestartTime = 0
    
    -- Clean up old connections
    if Axiora.AutoRestart._characterConnection then
        pcall(function() Axiora.AutoRestart._characterConnection:Disconnect() end)
    end
    if Axiora.AutoRestart._deathConnection then
        pcall(function() Axiora.AutoRestart._deathConnection:Disconnect() end)
    end
    
    local LP = getLocalPlayer()
    if not LP then return end
    
    -- Setup character listener
    Axiora.AutoRestart._characterConnection = LP.CharacterAdded:Connect(function(char)
        -- Wait for humanoid
        local hum = char:WaitForChild("Humanoid", 5)
        if not hum then return end
        
        -- Clean up old death connection
        if Axiora.AutoRestart._deathConnection then
            pcall(function() Axiora.AutoRestart._deathConnection:Disconnect() end)
        end
        
        -- Setup death listener
        Axiora.AutoRestart._deathConnection = hum.Died:Connect(function()
            if not Axiora.AutoRestart.Enabled then return end
            if not Axiora.AutoRestart.OnDeath then return end
            if Axiora.AutoRestart.RestartCount >= Axiora.AutoRestart.MaxRestarts then
                Axiora.Visuals.Notify("Auto-Restart", "Max restarts reached", 3, "warning")
                Axiora.AutoRestart.Disable()
                return
            end
            
            local now = os.clock()
            if (now - Axiora.AutoRestart.LastRestartTime) < Axiora.AutoRestart.RestartCooldown then
                return
            end
            
            if Axiora.State.Status ~= "PLAYING" and #Axiora.State.Buffer == 0 then
                return
            end
            
            Axiora.AutoRestart.RestartCount = Axiora.AutoRestart.RestartCount + 1
            Axiora.AutoRestart.LastRestartTime = now
            
            Axiora.Visuals.Notify("Auto-Restart", 
                "Restarting in " .. Axiora.AutoRestart.RestartDelay .. "s... (" .. 
                Axiora.AutoRestart.RestartCount .. "/" .. Axiora.AutoRestart.MaxRestarts .. ")", 
                Axiora.AutoRestart.RestartDelay, "warning")
            
            task.delay(Axiora.AutoRestart.RestartDelay, function()
                if not Axiora.AutoRestart.Enabled then return end
                
                -- Wait for respawn
                local waitStart = os.clock()
                while (os.clock() - waitStart) < 15 do
                    if LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") then
                        break
                    end
                    task.wait(0.5)
                end
                
                task.wait(1)
                Axiora.Play(true)
            end)
        end)
    end)
    
    -- Also setup for current character
    if LP.Character then
        local hum = LP.Character:FindFirstChildOfClass("Humanoid")
        if hum and hum.Health > 0 then
            -- Trigger same logic
            Axiora.AutoRestart._deathConnection = hum.Died:Connect(function()
                -- Same death handling
                if not Axiora.AutoRestart.Enabled or not Axiora.AutoRestart.OnDeath then return end
                if Axiora.AutoRestart.RestartCount >= Axiora.AutoRestart.MaxRestarts then return end
                
                Axiora.AutoRestart.RestartCount = Axiora.AutoRestart.RestartCount + 1
                Axiora.Visuals.Notify("Auto-Restart", "Restarting...", 3, "warning")
                
                task.delay(Axiora.AutoRestart.RestartDelay, function()
                    if not Axiora.AutoRestart.Enabled then return end
                    LP.CharacterAdded:Wait()
                    task.wait(2)
                    Axiora.Play(true)
                end)
            end)
        end
    end
    
    Axiora.AutoRestart._initialized = true
    Axiora.Visuals.Notify("Auto-Restart", "Enabled", 2, "success")
    Axiora.Events:Fire("AutoRestartEnabled")
end

function Axiora.AutoRestart.Disable()
    Axiora.AutoRestart.Enabled = false
    
    if Axiora.AutoRestart._characterConnection then
        pcall(function() Axiora.AutoRestart._characterConnection:Disconnect() end)
        Axiora.AutoRestart._characterConnection = nil
    end
    if Axiora.AutoRestart._deathConnection then
        pcall(function() Axiora.AutoRestart._deathConnection:Disconnect() end)
        Axiora.AutoRestart._deathConnection = nil
    end
    
    Axiora.AutoRestart._initialized = false
    Axiora.Visuals.Notify("Auto-Restart", "Disabled", 2, "info")
    Axiora.Events:Fire("AutoRestartDisabled")
end

function Axiora.AutoRestart.Toggle()
    if Axiora.AutoRestart.Enabled then
        Axiora.AutoRestart.Disable()
    else
        Axiora.AutoRestart.Enable()
    end
    return Axiora.AutoRestart.Enabled
end

function Axiora.AutoRestart.ResetCount()
    Axiora.AutoRestart.RestartCount = 0
end

function Axiora.AutoRestart.GetStatus()
    return {
        Enabled = Axiora.AutoRestart.Enabled,
        RestartCount = Axiora.AutoRestart.RestartCount,
        MaxRestarts = Axiora.AutoRestart.MaxRestarts,
        Delay = Axiora.AutoRestart.RestartDelay
    }
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 15: CONDITIONAL PLAYBACK (IF/THEN Logic)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Conditions = {
    _timers = {},
    _variables = {}
}

-- Condition checks
Axiora.Conditions.Checks = {
    CharacterExists = function()
        local LP = getLocalPlayer()
        return LP and LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") ~= nil
    end,
    
    IsAlive = function()
        local LP = getLocalPlayer()
        if not LP or not LP.Character then return false end
        local hum = LP.Character:FindFirstChildOfClass("Humanoid")
        return hum and hum.Health > 0
    end,
    
    HealthAbove = function(percent)
        local LP = getLocalPlayer()
        if not LP or not LP.Character then return false end
        local hum = LP.Character:FindFirstChildOfClass("Humanoid")
        if not hum then return false end
        return (hum.Health / hum.MaxHealth) * 100 >= (percent or 50)
    end,
    
    HealthBelow = function(percent)
        local LP = getLocalPlayer()
        if not LP or not LP.Character then return false end
        local hum = LP.Character:FindFirstChildOfClass("Humanoid")
        if not hum then return false end
        return (hum.Health / hum.MaxHealth) * 100 < (percent or 50)
    end,
    
    DistanceFromPosition = function(pos, maxDistance)
        local LP = getLocalPlayer()
        if not Axiora.Conditions.Checks.CharacterExists() then return false end
        
        local target
        if typeof(pos) == "Vector3" then
            target = pos
        elseif type(pos) == "table" then
            target = Vector3.new(pos.x or pos[1] or 0, pos.y or pos[2] or 0, pos.z or pos[3] or 0)
        else
            return false
        end
        
        local hrp = LP.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        return (hrp.Position - target).Magnitude <= (maxDistance or 50)
    end,
    
    PartExists = function(partName, parent)
        local searchIn = parent and game:FindFirstChild(parent) or Workspace
        if not searchIn then return false end
        return searchIn:FindFirstChild(partName, true) ~= nil
    end,
    
    TimePassed = function(seconds, timerKey)
        timerKey = timerKey or "_default"
        if not Axiora.Conditions._timers[timerKey] then
            Axiora.Conditions._timers[timerKey] = os.clock()
            return false
        end
        return (os.clock() - Axiora.Conditions._timers[timerKey]) >= (seconds or 0)
    end,
    
    ResetTimer = function(timerKey)
        timerKey = timerKey or "_default"
        Axiora.Conditions._timers[timerKey] = os.clock()
        return true
    end,
    
    RandomChance = function(percent)
        return math.random(1, 100) <= (percent or 50)
    end,
    
    Always = function() return true end,
    Never = function() return false end
}

-- Actions
Axiora.Actions = {
    Wait = function(duration)
        task.wait(duration or 1)
        return duration or 1
    end,
    
    MoveTo = function(position)
        local LP = getLocalPlayer()
        if not Axiora.Conditions.Checks.CharacterExists() then return 0 end
        
        local target
        if typeof(position) == "Vector3" then
            target = position
        elseif type(position) == "table" then
            target = Vector3.new(position.x or position[1] or 0, position.y or position[2] or 0, position.z or position[3] or 0)
        else
            return 0
        end
        
        LP.Character.Humanoid:MoveTo(target)
        return 0
    end,
    
    Click = function(x, y)
        local abs = Axiora.Math.GetAbsoluteInput(x, y)
        Axiora.Input.Click(abs.X, abs.Y)
        return 0.05
    end,
    
    Jump = function()
        local LP = getLocalPlayer()
        if Axiora.Conditions.Checks.CharacterExists() then
            local hum = LP.Character:FindFirstChildOfClass("Humanoid")
            if hum then hum.Jump = true end
        end
        return 0
    end,
    
    Notify = function(message, duration)
        Axiora.Visuals.Notify("Condition", message, duration or 2, "info")
        return 0
    end,
    
    SetVariable = function(name, value)
        Axiora.Conditions._variables[name] = value
        return 0
    end,
    
    GetVariable = function(name, defaultValue)
        return Axiora.Conditions._variables[name] or defaultValue
    end,
    
    Stop = function()
        Axiora.Stop()
        return 0
    end,
    
    Pause = function(duration)
        Axiora.Playback.Paused = true
        task.wait(duration or 5)
        Axiora.Playback.Paused = false
        return duration or 5
    end
}

-- Create conditional node helper
function Axiora.Conditions.CreateNode(config)
    return {
        t = 4, -- Conditional type
        d = config.delay or 0,
        condition = config.condition,
        conditionArgs = config.conditionArgs or {},
        action = config.action,
        actionArgs = config.actionArgs or {},
        elseAction = config.elseAction,
        elseActionArgs = config.elseActionArgs or {}
    }
end

-- Evaluate a condition
function Axiora.Conditions.Evaluate(conditionName, args)
    local check = Axiora.Conditions.Checks[conditionName]
    if not check then return false end
    
    local success, result = pcall(function()
        if args and #args > 0 then
            return check(table.unpack(args))
        else
            return check()
        end
    end)
    
    return success and result
end

-- Execute an action
function Axiora.Actions.Execute(actionName, args)
    local action = Axiora.Actions[actionName]
    if not action then return 0 end
    
    local success, duration = pcall(function()
        if args and #args > 0 then
            return action(table.unpack(args))
        else
            return action()
        end
    end)
    
    return success and (duration or 0) or 0
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 16: MARKED POSITIONS
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.MarkedPositions = {}

function Axiora.MarkPosition(name)
    local LP = getLocalPlayer()
    if not LP or not LP.Character or not LP.Character:FindFirstChild("HumanoidRootPart") then
        Axiora.Visuals.Notify("Mark", "No character found", 2, "error")
        return false
    end
    
    local hrp = LP.Character.HumanoidRootPart
    local pos = hrp.Position
    local cam = Workspace.CurrentCamera
    
    name = name or ("pos_" .. os.date("%H%M%S"))
    
    Axiora.MarkedPositions[name] = {
        x = pos.X,
        y = pos.Y,
        z = pos.Z,
        timestamp = os.time(),
        cameraLook = cam and {
            x = cam.CFrame.LookVector.X,
            y = cam.CFrame.LookVector.Y,
            z = cam.CFrame.LookVector.Z
        } or nil,
        placeId = game.PlaceId
    }
    
    Axiora.Visuals.Notify("Mark", "Saved: " .. name, 2, "success")
    Axiora.Events:Fire("PositionMarked", {Name = name, Position = pos})
    return true
end

function Axiora.GetMarkedPosition(name)
    local data = Axiora.MarkedPositions[name]
    if not data then return nil end
    return Vector3.new(data.x, data.y, data.z)
end

function Axiora.TeleportToMark(name)
    local pos = Axiora.GetMarkedPosition(name)
    if not pos then
        Axiora.Visuals.Notify("Mark", "Position not found: " .. tostring(name), 2, "error")
        return false
    end
    
    local LP = getLocalPlayer()
    if not LP or not LP.Character or not LP.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    LP.Character.HumanoidRootPart.CFrame = CFrame.new(pos)
    Axiora.Visuals.Notify("Mark", "Teleported to: " .. name, 2, "success")
    return true
end

function Axiora.MoveToMark(name, timeout)
    local pos = Axiora.GetMarkedPosition(name)
    if not pos then return false end
    
    local LP = getLocalPlayer()
    if not LP or not LP.Character then return false end
    
    local hum = LP.Character:FindFirstChildOfClass("Humanoid")
    if not hum then return false end
    
    hum:MoveTo(pos)
    
    if timeout then
        local conn
        local reached = false
        conn = hum.MoveToFinished:Connect(function()
            reached = true
            if conn then conn:Disconnect() end
        end)
        
        local start = os.clock()
        while not reached and (os.clock() - start) < timeout do
            task.wait(0.1)
        end
        if conn then conn:Disconnect() end
    end
    
    return true
end

function Axiora.ListMarkedPositions()
    local list = {}
    for name, data in pairs(Axiora.MarkedPositions) do
        table.insert(list, {
            Name = name,
            Position = Vector3.new(data.x, data.y, data.z),
            Timestamp = data.timestamp
        })
    end
    return list
end

function Axiora.ClearMarkedPositions()
    Axiora.MarkedPositions = {}
    Axiora.Visuals.Notify("Mark", "All positions cleared", 2, "info")
end

function Axiora.SaveMarkedPositions()
    if not Axiora.Capabilities.WriteFile then return false end
    
    local success = pcall(function()
        writefile("Axiora/markers.json", HttpService:JSONEncode(Axiora.MarkedPositions))
    end)
    
    if success then
        Axiora.Visuals.Notify("Mark", "Positions saved", 2, "success")
    end
    return success
end

function Axiora.LoadMarkedPositions()
    if not Axiora.Capabilities.ReadFile then return false end
    
    local success, data = pcall(function()
        return HttpService:JSONDecode(readfile("Axiora/markers.json"))
    end)
    
    if success and data then
        Axiora.MarkedPositions = data
        local count = 0
        for _ in pairs(data) do count = count + 1 end
        Axiora.Visuals.Notify("Mark", "Loaded " .. count .. " positions", 2, "success")
        return true
    end
    return false
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 17: ANALYTICS
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Analytics = {
    StartTime = os.clock(),
    Recording = {
        TotalSessions = 0,
        TotalNodes = 0,
        TotalDuration = 0,
        LastSessionNodes = 0,
        LastSessionDuration = 0
    },
    Playback = {
        TotalExecutions = 0,
        TotalLoops = 0,
        SuccessfulCompletions = 0,
        FailedExecutions = 0,
        TotalPlaybackTime = 0
    },
    Errors = {
        Total = 0,
        LastError = nil,
        LastErrorTime = 0
    }
}

-- Track recording
Axiora.Events:Connect("RecordingStarted", function()
    Axiora.Analytics.Recording.TotalSessions = Axiora.Analytics.Recording.TotalSessions + 1
end)

Axiora.Events:Connect("Stopped", function(data)
    if data and data.WasRecording then
        Axiora.Analytics.Recording.LastSessionNodes = #Axiora.State.Buffer
        Axiora.Analytics.Recording.TotalNodes = Axiora.Analytics.Recording.TotalNodes + #Axiora.State.Buffer
    end
end)

-- Track playback
Axiora.Events:Connect("PlaybackStarted", function()
    Axiora.Analytics.Playback.TotalExecutions = Axiora.Analytics.Playback.TotalExecutions + 1
end)

Axiora.Events:Connect("PlaybackComplete", function(data)
    if data then
        Axiora.Analytics.Playback.TotalLoops = Axiora.Analytics.Playback.TotalLoops + (data.Loops or 1)
        if data.NodesPlayed >= (data.TotalNodes or 1) * 0.9 then
            Axiora.Analytics.Playback.SuccessfulCompletions = Axiora.Analytics.Playback.SuccessfulCompletions + 1
        else
            Axiora.Analytics.Playback.FailedExecutions = Axiora.Analytics.Playback.FailedExecutions + 1
        end
    end
end)

-- Track errors
Axiora.Events:Connect("Error", function(data)
    Axiora.Analytics.Errors.Total = Axiora.Analytics.Errors.Total + 1
    Axiora.Analytics.Errors.LastError = data and data.Message or "Unknown"
    Axiora.Analytics.Errors.LastErrorTime = os.clock()
end)

function Axiora.Analytics.GetUptime()
    return os.clock() - Axiora.Analytics.StartTime
end

function Axiora.Analytics.GetUptimeFormatted()
    local uptime = Axiora.Analytics.GetUptime()
    local hours = math.floor(uptime / 3600)
    local mins = math.floor((uptime % 3600) / 60)
    local secs = math.floor(uptime % 60)
    return string.format("%02d:%02d:%02d", hours, mins, secs)
end

function Axiora.Analytics.GetSuccessRate()
    local total = Axiora.Analytics.Playback.SuccessfulCompletions + Axiora.Analytics.Playback.FailedExecutions
    if total == 0 then return 100 end
    return math.floor((Axiora.Analytics.Playback.SuccessfulCompletions / total) * 100)
end

function Axiora.Analytics.GetReport()
    return {
        System = {
            Uptime = Axiora.Analytics.GetUptime(),
            UptimeFormatted = Axiora.Analytics.GetUptimeFormatted(),
            Executor = Axiora.Capabilities.Executor,
            InputMethod = Axiora.Input.Method
        },
        Recording = Axiora.Analytics.Recording,
        Playback = {
            TotalExecutions = Axiora.Analytics.Playback.TotalExecutions,
            TotalLoops = Axiora.Analytics.Playback.TotalLoops,
            SuccessfulCompletions = Axiora.Analytics.Playback.SuccessfulCompletions,
            FailedExecutions = Axiora.Analytics.Playback.FailedExecutions,
            SuccessRatePercent = Axiora.Analytics.GetSuccessRate()
        },
        Errors = Axiora.Analytics.Errors,
        CurrentState = {
            Status = Axiora.State.Status,
            BufferSize = #Axiora.State.Buffer,
            SequenceQueueSize = #Axiora.Sequences.Queue
        }
    }
end

function Axiora.Analytics.Print()
    local report = Axiora.Analytics.GetReport()
    print("========== AXIORA ANALYTICS ==========")
    print("Uptime: " .. report.System.UptimeFormatted)
    print("Executor: " .. report.System.Executor)
    print("")
    print("Recording Sessions: " .. report.Recording.TotalSessions)
    print("Total Nodes Recorded: " .. report.Recording.TotalNodes)
    print("")
    print("Playback Executions: " .. report.Playback.TotalExecutions)
    print("Success Rate: " .. report.Playback.SuccessRatePercent .. "%")
    print("Total Loops: " .. report.Playback.TotalLoops)
    print("")
    print("Total Errors: " .. report.Errors.Total)
    print("Current Buffer: " .. report.CurrentState.BufferSize .. " nodes")
    print("=======================================")
end

function Axiora.Analytics.Export()
    if not Axiora.Capabilities.WriteFile then
        Axiora.Visuals.Notify("Analytics", "Cannot export - no file system", 3, "error")
        return false
    end
    
    local report = Axiora.Analytics.GetReport()
    local filename = "Axiora/analytics_" .. os.time() .. ".json"
    
    local success = pcall(function()
        writefile(filename, HttpService:JSONEncode(report))
    end)
    
    if success then
        Axiora.Visuals.Notify("Analytics", "Exported to: " .. filename, 3, "success")
    end
    return success
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 18: CALIBRATION
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Calibration = {
    Active = false,
    XOffset = 0,
    YOffset = 0
}

function Axiora.Calibration.SetOffsets(x, y)
    Axiora.Settings.XOffset = x or 0
    Axiora.Settings.YOffset = y or 0
    Axiora.Calibration.XOffset = x or 0
    Axiora.Calibration.YOffset = y or 0
    Axiora.Visuals.Notify("Calibration", "Offsets set: X=" .. x .. ", Y=" .. y, 2, "success")
end

function Axiora.Calibration.GetOffsets()
    return {
        X = Axiora.Settings.XOffset,
        Y = Axiora.Settings.YOffset
    }
end

function Axiora.Calibration.Reset()
    Axiora.Settings.XOffset = 0
    Axiora.Settings.YOffset = 0
    Axiora.Calibration.XOffset = 0
    Axiora.Calibration.YOffset = 0
    Axiora.Visuals.Notify("Calibration", "Offsets reset to 0", 2, "info")
end

function Axiora.Calibration.AutoDetect()
    -- Simple auto-detection based on screen size
    Axiora.Math.UpdateScreenMetrics()
    local screen = Axiora.Math.Screen.Viewport
    
    -- Some common resolution adjustments
    if screen.X < 1280 then
        -- Lower resolution - might need offset
        Axiora.Calibration.SetOffsets(0, 0)
    elseif screen.X > 1920 then
        -- Higher resolution
        Axiora.Calibration.SetOffsets(0, 0)
    else
        -- Standard 1080p
        Axiora.Calibration.SetOffsets(0, 0)
    end
    
    Axiora.Visuals.Notify("Calibration", "Auto-detected for " .. math.floor(screen.X) .. "x" .. math.floor(screen.Y), 2, "info")
end

function Axiora.Calibration.SaveCalibration()
    if not Axiora.Capabilities.WriteFile then return false end
    
    local data = {
        XOffset = Axiora.Settings.XOffset,
        YOffset = Axiora.Settings.YOffset,
        PlaceId = game.PlaceId,
        Resolution = {
            X = Axiora.Math.Screen.Viewport.X,
            Y = Axiora.Math.Screen.Viewport.Y
        }
    }
    
    return pcall(function()
        writefile("Axiora/calibration.json", HttpService:JSONEncode(data))
    end)
end

function Axiora.Calibration.LoadCalibration()
    if not Axiora.Capabilities.ReadFile then return false end
    
    local success, data = pcall(function()
        return HttpService:JSONDecode(readfile("Axiora/calibration.json"))
    end)
    
    if success and data then
        Axiora.Calibration.SetOffsets(data.XOffset or 0, data.YOffset or 0)
        return true
    end
    return false
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 19: SIMPLE UI INTERFACE
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.UI = {
    ScreenGui = nil,
    MainFrame = nil,
    IsOpen = false
}

function Axiora.UI.Create()
    if Axiora.UI.ScreenGui then
        pcall(function() Axiora.UI.ScreenGui:Destroy() end)
    end
    
    local theme = Axiora.Visuals.GetTheme()
    
    local sg = Instance.new("ScreenGui")
    sg.Name = "AxioraUI"
    sg.IgnoreGuiInset = true
    sg.ResetOnSpawn = false
    sg.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    local success = pcall(function()
        sg.Parent = CoreGui
    end)
    if not success then
        local LP = getLocalPlayer()
        if LP and LP:FindFirstChild("PlayerGui") then
            sg.Parent = LP.PlayerGui
        end
    end
    
    Axiora.UI.ScreenGui = sg
    
    -- Main window
    local main = Instance.new("Frame")
    main.Name = "Main"
    main.BackgroundColor3 = theme.Background
    main.BackgroundTransparency = 0.05
    main.Size = UDim2.new(0, 380, 0, 340)
    main.Position = UDim2.new(0.5, 0, 0.5, 0)
    main.AnchorPoint = Vector2.new(0.5, 0.5)
    main.BorderSizePixel = 0
    main.ClipsDescendants = true
    main.Parent = sg
    
    Instance.new("UICorner", main).CornerRadius = UDim.new(0, 12)
    
    local stroke = Instance.new("UIStroke")
    stroke.Color = theme.Primary
    stroke.Transparency = 0.5
    stroke.Thickness = 1.5
    stroke.Parent = main
    
    -- Title bar
    local titleBar = Instance.new("Frame")
    titleBar.Name = "TitleBar"
    titleBar.BackgroundColor3 = theme.Surface
    titleBar.Size = UDim2.new(1, 0, 0, 40)
    titleBar.BorderSizePixel = 0
    titleBar.Parent = main
    
    local title = Instance.new("TextLabel")
    title.BackgroundTransparency = 1
    title.Size = UDim2.new(1, -50, 1, 0)
    title.Position = UDim2.new(0, 15, 0, 0)
    title.Text = "AXIORA v" .. Axiora._VERSION .. " FULL"
    title.TextColor3 = theme.Primary
    title.Font = Enum.Font.GothamBlack
    title.TextSize = 16
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.Parent = titleBar
    
    -- Close button
    local closeBtn = Instance.new("TextButton")
    closeBtn.BackgroundTransparency = 1
    closeBtn.Size = UDim2.new(0, 40, 1, 0)
    closeBtn.Position = UDim2.new(1, -40, 0, 0)
    closeBtn.Text = "✕"
    closeBtn.TextColor3 = theme.TextDim
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.TextSize = 16
    closeBtn.Parent = titleBar
    closeBtn.MouseButton1Click:Connect(function()
        Axiora.UI.Toggle()
    end)
    
    -- Content area with scroll
    local content = Instance.new("ScrollingFrame")
    content.Name = "Content"
    content.BackgroundTransparency = 1
    content.Size = UDim2.new(1, -20, 1, -60)
    content.Position = UDim2.new(0, 10, 0, 50)
    content.CanvasSize = UDim2.new(0, 0, 0, 450)
    content.ScrollBarThickness = 4
    content.ScrollBarImageColor3 = theme.Primary
    content.Parent = main
    
    local layout = Instance.new("UIListLayout")
    layout.Padding = UDim.new(0, 6)
    layout.Parent = content
    
    -- Helper to create buttons
    local function createButton(text, color, callback)
        local btn = Instance.new("TextButton")
        btn.BackgroundColor3 = color
        btn.BackgroundTransparency = 0.15
        btn.Size = UDim2.new(1, 0, 0, 34)
        btn.Text = text
        btn.TextColor3 = theme.Text
        btn.Font = Enum.Font.GothamBold
        btn.TextSize = 12
        btn.AutoButtonColor = false
        btn.Parent = content
        Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)
        
        btn.MouseEnter:Connect(function()
            TweenService:Create(btn, TweenInfo.new(0.15), {BackgroundTransparency = 0}):Play()
        end)
        btn.MouseLeave:Connect(function()
            TweenService:Create(btn, TweenInfo.new(0.15), {BackgroundTransparency = 0.15}):Play()
        end)
        btn.MouseButton1Click:Connect(callback)
        
        return btn
    end
    
    -- Buttons
    createButton("🔴 RECORD (F1)", theme.Error, function()
        if Axiora.State.Status == "RECORDING" then
            Axiora.Stop()
        else
            Axiora.Record()
        end
    end)
    
    createButton("▶️ PLAY (F2)", theme.Success, function()
        if Axiora.State.Status == "PLAYING" then
            Axiora.Pause()
        else
            Axiora.Play(true)
        end
    end)
    
    createButton("⏹ STOP (F3)", theme.Secondary, function()
        Axiora.Stop()
    end)
    
    createButton("💾 SAVE MACRO", theme.Info, function()
        Axiora.Save()
    end)
    
    createButton("📂 LIST SAVES", theme.Info, function()
        local saves = Axiora.ListSaves()
        if #saves > 0 then
            Axiora.Visuals.Notify("Saves", table.concat(saves, ", "), 5, "info")
        else
            Axiora.Visuals.Notify("Saves", "No saved macros found", 2, "warning")
        end
    end)
    
    createButton("🎯 RENDER PATH", theme.Primary, function()
        Axiora.Visuals.RenderPath()
    end)
    
    createButton("📍 MARK POSITION", theme.Success, function()
        Axiora.MarkPosition()
    end)
    
    createButton("➕ ADD TO QUEUE", theme.Warning, function()
        Axiora.Sequences.AddCurrentBuffer()
    end)
    
    createButton("⚡ RUN QUEUE", theme.Warning, function()
        Axiora.Sequences.ExecuteQueue()
    end)
    
    createButton("🔄 AUTO-RESTART TOGGLE", theme.Error, function()
        Axiora.AutoRestart.Toggle()
    end)
    
    createButton("📊 PRINT ANALYTICS", theme.Secondary, function()
        Axiora.Analytics.Print()
    end)
    
    -- Status display
    local statusBar = Instance.new("Frame")
    statusBar.BackgroundTransparency = 1
    statusBar.Size = UDim2.new(1, 0, 0, 40)
    statusBar.Parent = content
    
    local statusLabel = Instance.new("TextLabel")
    statusLabel.BackgroundTransparency = 1
    statusLabel.Size = UDim2.new(1, 0, 1, 0)
    statusLabel.Text = "Status: IDLE | Buffer: 0 nodes\nQueue: 0 | Uptime: 00:00:00"
    statusLabel.TextColor3 = theme.TextDim
    statusLabel.Font = Enum.Font.Gotham
    statusLabel.TextSize = 10
    statusLabel.TextWrapped = true
    statusLabel.Parent = statusBar
    
    -- Update status
    local statusThread = task.spawn(function()
        while sg and sg.Parent do
            statusLabel.Text = "Status: " .. Axiora.State.Status .. " | Buffer: " .. #Axiora.State.Buffer .. " nodes\n" ..
                "Queue: " .. #Axiora.Sequences.Queue .. " | Uptime: " .. Axiora.Analytics.GetUptimeFormatted()
            task.wait(0.5)
        end
    end)
    table.insert(Axiora.State.Threads, statusThread)
    
    -- Dragging
    local dragging = false
    local dragStart, startPos
    
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = UserInputService:GetMouseLocation()
            startPos = main.Position
        end
    end)
    
    titleBar.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local current = UserInputService:GetMouseLocation()
            local delta = current - dragStart
            main.Position = UDim2.new(
                startPos.X.Scale, startPos.X.Offset + delta.X,
                startPos.Y.Scale, startPos.Y.Offset + delta.Y
            )
        end
    end)
    
    Axiora.UI.MainFrame = main
    Axiora.UI.IsOpen = true
    
    return sg
end

function Axiora.UI.Toggle()
    if Axiora.UI.MainFrame then
        Axiora.UI.IsOpen = not Axiora.UI.IsOpen
        Axiora.UI.MainFrame.Visible = Axiora.UI.IsOpen
    else
        Axiora.UI.Create()
    end
end

function Axiora.UI.Destroy()
    if Axiora.UI.ScreenGui then
        pcall(function() Axiora.UI.ScreenGui:Destroy() end)
        Axiora.UI.ScreenGui = nil
        Axiora.UI.MainFrame = nil
        Axiora.UI.IsOpen = false
    end
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 20: INITIALIZATION & EXPORTS
-- ═══════════════════════════════════════════════════════════════════════════════

function Axiora.Init()
    -- Mark as loaded
    Axiora._LOADED = true
    
    -- Initialize screen metrics
    Axiora.Math.WaitForInit(3)
    
    -- Initialize file system
    Axiora.Files.Init()
    
    -- Try to load saved calibration
    Axiora.Calibration.LoadCalibration()
    
    -- Try to load saved markers
    Axiora.LoadMarkedPositions()
    
    -- Initialize visuals
    Axiora.Visuals.Init()
    
    -- Create HUD
    if Axiora.Settings.HUDEnabled then
        task.delay(0.5, function()
            Axiora.Visuals.CreateHUD()
        end)
    end
    
    -- Initialize hotkeys
    Axiora.Hotkeys.Init()
    
    -- Enable Anti-AFK if configured
    if Axiora.Settings.AntiAFK then
        Axiora.Security.EnableAntiAFK()
    end
    
    -- Create UI
    task.delay(0.3, function()
        Axiora.UI.Create()
        Axiora.Visuals.Notify("Axiora", "v" .. Axiora._VERSION .. " FULL loaded!", 4, "success")
    end)
    
    -- Log capabilities
    print("═══════════════════════════════════════════")
    print("[Axiora] v" .. Axiora._VERSION .. " - " .. Axiora._BUILD .. " FULL")
    print("[Axiora] Executor: " .. Axiora.Capabilities.Executor)
    print("[Axiora] Input Method: " .. Axiora.Input.Method)
    print("[Axiora] File System: " .. (Axiora.Capabilities.FileSystemVerified and "OK" or "Limited"))
    print("[Axiora] Hotkeys: F1=Record, F2=Play, F3=Stop, F4=UI, F8=HUD")
    print("═══════════════════════════════════════════")
    print("[Axiora] Features Loaded:")
    print("  ✓ Recording & Playback")
    print("  ✓ Save/Load Macros")
    print("  ✓ Strategy Loader (URL)")
    print("  ✓ Sequence Queue Manager")
    print("  ✓ Auto-Restart System")
    print("  ✓ Conditional Playback")
    print("  ✓ Marked Positions")
    print("  ✓ Analytics Tracking")
    print("  ✓ Calibration System")
    print("  ✓ Visual HUD & Notifications")
    print("═══════════════════════════════════════════")
end

-- Export to global
Root.Axiora = Axiora

-- Auto-initialize
Axiora.Init()

return Axiora
