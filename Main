
--// END OF AXIORA OMEGA //
--[[ 
    AXIORA OMEGA [TIER-2 ARCHITECTURE]
    Architect: Quantum Delta-Script Architect
    Target: Delta Executor (Mobile Optimized)
    Protocol: 20-Point "Master Logic" (Safe, Smart, Autonomous)
    
    [PART A: THE MATRIX & INFRASTRUCTURE]
]]

--// 1. QUANTUM SERVICE WRAPPERS //
-- Ensuring detection-proof service acquisition on Delta/Hydrogen
local function GetService(name)
    local s = game:GetService(name)
    if cloneref then s = cloneref(s) end
    return s
end

local Players = GetService("Players")
local Workspace = GetService("Workspace")
local RunService = GetService("RunService")
local UserInputService = GetService("UserInputService")
local VirtualInputManager = GetService("VirtualInputManager")
local TweenService = GetService("TweenService")
local HttpService = GetService("HttpService")
local CoreGui = GetService("CoreGui")
local GuiService = GetService("GuiService")
local Lighting = GetService("Lighting")
local TeleportService = GetService("TeleportService")
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- Validate Execution Environment
local IsMobile = UserInputService.TouchEnabled
if not game:IsLoaded() then game.Loaded:Wait() end

--// 2. GLOBAL STATE & CONFIGURATION //
-- The central nervous system of the macro
local Axiora = {
    Version = "Omega.1.0",
    State = {
        IsRecording = false,
        IsReplaying = false,
        IsLooping = false,
        IsPaused = false,
        CurrentIndex = 1,
        RecordingStart = 0,
        RejoinAttempted = false
    },
    Cache = {
        Data = {}, -- The Recorded Actions (RAM Buffer)
        Waypoints = {},
        PID = {
            TargetPing = 100,
            Correction = 1.0
        }
    },
    Threads = {},
    Signals = {}
}

-- User Settings (The Interface links to these)
local Config = {
    Offset = {X = 0, Y = 0},     -- Manual Tweaks
    GuiInsetFix = true,          -- "True-View" Logic
    SmartLag = true,             -- PID Sync
    Visuals = true,              -- HUD Drawing
    BatterySaver = false,        -- Thermal Regulator
    AntiAFK = true,              -- Micro-Packet Spoofing
    AutoRejoin = true,           -- Phoenix Protocol
    Humanizer = {                -- Perlin Noise parameters
        Enabled = true,
        Strength = 3             -- Pixel jitter radius
    }
}

-- Theme Definition (Axiora V6 Palette)
local Theme = {
    Background = Color3.fromRGB(20, 20, 24),
    Sidebar    = Color3.fromRGB(15, 15, 18),
    Content    = Color3.fromRGB(26, 26, 30),
    Accent     = Color3.fromRGB(114, 137, 218), -- Discord/Axiora Blurple
    Text       = Color3.fromRGB(245, 245, 245),
    SubText    = Color3.fromRGB(160, 160, 160),
    Success    = Color3.fromRGB(87, 242, 135),
    Danger     = Color3.fromRGB(237, 66, 69),
    Warning    = Color3.fromRGB(240, 240, 60),
    Void       = Color3.fromRGB(0, 0, 0)
}

--// 3. THE "CHRONOS" FILE SYSTEM //
-- Handles safe I/O with Scoped Storage limitations on Android 11+
local Chronos = {}
Chronos.FileName = "AxioraOmega_Save.json"
Chronos.TempFile = "AxioraOmega_RejoinState.json"

function Chronos.Save(isTemp)
    if not writefile then return warn("[Chronos] File System Not Supported") end
    
    local dataset = isTemp and {
        Index = Axiora.State.CurrentIndex,
        Loop = Axiora.State.IsLooping,
        Data = nil -- Don't duplicate massive data in temp, just state
    } or {
        Actions = Axiora.Cache.Data,
        Config = Config
    }
    
    local success, encoded = pcall(function() return HttpService:JSONEncode(dataset) end)
    if success then
        pcall(function() 
            writefile(isTemp and Chronos.TempFile or Chronos.FileName, encoded) 
        end)
    end
end

function Chronos.Load(isTemp)
    if not isfile or not readfile then return end
    local fileTarget = isTemp and Chronos.TempFile or Chronos.FileName
    
    if isfile(fileTarget) then
        local content = readfile(fileTarget)
        local success, decoded = pcall(function() return HttpService:JSONDecode(content) end)
        
        if success and decoded then
            if isTemp then
                -- Resume logic
                Axiora.State.CurrentIndex = decoded.Index or 1
                Axiora.State.IsLooping = decoded.Loop or false
                return true
            else
                -- Full load
                Axiora.Cache.Data = decoded.Actions or {}
                if decoded.Config then
                    for k, v in pairs(decoded.Config) do
                        if Config[k] ~= nil then Config[k] = v end
                    end
                end
                return true
            end
        end
    end
    return false
end

--// 4. THE "THERMAL" REGULATOR (FPS & BATTERY) //
-- Mobile heat management logic
local Thermal = {}
local OriginalSettings = {
    Tech = Enum.CameraType.Custom,
    Shadows = Lighting.GlobalShadows
}
Thermal.IsActive = false

function Thermal.SetEcoMode(enabled)
    if enabled == Thermal.IsActive then return end
    Thermal.IsActive = enabled
    
    if enabled then
        -- ENTER VOID MODE (GPU SAVING)
        RunService:Set3dRenderingEnabled(false) -- Standard Call
        
        -- Fallback if Set3d fails on specific Executor
        pcall(function()
            Camera.CameraType = Enum.CameraType.Scriptable
            Camera.CFrame = CFrame.new(0, -500, 0) -- Look into void
            Lighting.GlobalShadows = false
        end)
    else
        -- EXIT VOID MODE
        RunService:Set3dRenderingEnabled(true)
        
        pcall(function()
            Camera.CameraType = Enum.CameraType.Custom
            Lighting.GlobalShadows = OriginalSettings.Shadows
            if LocalPlayer.Character then
                Camera.CameraSubject = LocalPlayer.Character:FindFirstChild("Humanoid")
            end
        end)
    end
end

-- Auto-Throttler (Frequency Modulation)
task.spawn(function()
    while true do
        task.wait(5)
        -- Battery Logic check (if supported)
        -- If Time running > 30 mins, prompt Eco? 
        -- Implementation is handled via user Toggle for now
    end
end)

--// 5. EINSTEIN MATH LIBRARY //
-- Coordinate corrections and Proximity logic
local Math = {}

-- Returns the Delta-Adjusted 2D coordinates
function Math.GetTrueInput(inputObject)
    local raw = inputObject.Position
    local vec2 = Vector2.new(raw.X, raw.Y)
    
    -- GuiInset Subtraction Logic (TopBar Compensation)
    if Config.GuiInsetFix then
        local inset = GuiService:GetGuiInset()
        -- Mobile input objects usually need this fix during "Replay" calculation
        -- But for raw recording, we store RAW SCREEN.
    end
    
    return vec2
end

-- Returns the Time Dilation factor (Lag Compensation)
function Math.GetLagFactor()
    if not Config.SmartLag then return 1.0 end
    local ping = tonumber(string.split(game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString(), " ")[1]) or 100
    local dilation = ping / 100 -- If 200ms, factor is 2.0. Slow down playback.
    
    -- Clamping to prevent excessive slow motion
    return math.clamp(dilation, 0.8, 1.5)
end

--// END OF PART A //
--// [PART B: FLUID ENGINE & AUTOMATION] //

--// 6. FLUID NAVIGATION (STUTTER-FREE) //
local Pathfinding = {}
local PFS = GetService("PathfindingService")

function Pathfinding.SmartMove(targetPos)
    if not LocalPlayer.Character then return end
    local hum = LocalPlayer.Character:FindFirstChild("Humanoid")
    local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hum or not root then return end

    hum:MoveTo(targetPos)
    
    -- FLUID MOMENTUM LOOP
    -- Instead of waiting for a full stop, we check if we are 'close enough' (5 studs)
    -- This allows the script to issue the NEXT command before the character stops moving.
    local startT = os.clock()
    local stuckTime = 0
    local lastDist = 9999
    
    while (root.Position - targetPos).Magnitude > 6 do
        local dist = (root.Position - targetPos).Magnitude
        
        -- A* FALLBACK TRIGGER (Stuck logic)
        -- If distance isn't shrinking, or we've been moving too long
        if math.abs(dist - lastDist) < 0.2 then
            stuckTime = stuckTime + RunService.Heartbeat:Wait()
        else
            stuckTime = 0
            lastDist = dist
        end
        
        -- Logic: If stuck for 1s, compute path around obstacle
        if stuckTime > 1.0 then
            -- [Obstacle Detected - Rerouting]
            local path = PFS:CreatePath({AgentRadius = 2, AgentCanJump = true})
            pcall(function() 
                path:ComputeAsync(root.Position, targetPos)
                for _, wp in ipairs(path:GetWaypoints()) do
                    if wp.Action == Enum.PathWaypointAction.Jump then hum.Jump = true end
                    hum:MoveTo(wp.Position)
                    hum.MoveToFinished:Wait() -- Waypoints need precision
                end
            end)
            return -- Resume normal flow
        end
        
        -- TIMEOUT
        if (os.clock() - startT) > 10 then break end
        
        RunService.Heartbeat:Wait()
    end
end

--// 7. RECORDING HEURISTICS //
local Engine = {}
local RecordConn = {}

function Engine.StartRecording()
    if Axiora.State.IsRecording then return end
    
    Axiora.Cache.Data = {}
    Axiora.State.RecordingStart = os.clock()
    Axiora.State.IsRecording = true
    Axiora.State.IsReplaying = false
    
    local lastPos = nil
    
    -- MOVEMENT STREAM (Capped Rate for smoothness)
    -- We record closer intervals to capture curves
    local mv = RunService.Heartbeat:Connect(function()
        if not LocalPlayer.Character then return end
        local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not root then return end
        
        local current = root.Position
        
        -- Only record if moved > 2 studs (Optimizes file size)
        if not lastPos or (current - lastPos).Magnitude > 2 then
            table.insert(Axiora.Cache.Data, {
                Type = "Move",
                Pos = {X = current.X, Y = current.Y, Z = current.Z},
                Time = os.clock() - Axiora.State.RecordingStart
            })
            lastPos = current
        end
    end)
    table.insert(RecordConn, mv)
    
    -- INPUT STREAM
    local inp = UserInputService.InputBegan:Connect(function(input, gpe)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            
            -- AUTO-OFFSET LOGIC:
            -- Capture raw position.
            local raw = UserInputService:GetMouseLocation()
            
            table.insert(Axiora.Cache.Data, {
                Type = "Input",
                Action = "Tap",
                XY = {X = raw.X, Y = raw.Y},
                Time = os.clock() - Axiora.State.RecordingStart
            })
        end
    end)
    table.insert(RecordConn, inp)
end

function Engine.Stop()
    Axiora.State.IsRecording = false
    Axiora.State.IsReplaying = false
    Axiora.State.IsLooping = false
    Thermal.SetEcoMode(false) 
    
    for _, c in pairs(RecordConn) do c:Disconnect() end
    RecordConn = {}
    for tName, thread in pairs(Axiora.Threads) do task.cancel(thread) Axiora.Threads[tName] = nil end
end

--// 8. PLAYBACK CORE (Humanized + AutoCorrect) //
function Engine.ExecuteStep(action, prevTime)
    local delayTime = action.Time - prevTime
    if delayTime > 0 then task.wait(delayTime * Math.GetLagFactor()) end
    
    if action.Type == "Move" then
        local dest = Vector3.new(action.Pos.X, action.Pos.Y, action.Pos.Z)
        Pathfinding.SmartMove(dest)
        
    elseif action.Type == "Input" and action.Action == "Tap" then
        -- THE GENIUS FIX (Automatic GUI Inset)
        -- We get the Inset (e.g., 58 pixels on iPhone notch)
        -- VIM sends touch relative to VIEWPORT, but Input was SCREEN.
        -- So we Subtract Inset to match the 1:1 overlap.
        local Inset = GuiService:GetGuiInset() 
        local AutoY = action.XY.Y - Inset.Y
        
        local finalX = action.XY.X + Config.Offset.X
        local finalY = AutoY + Config.Offset.Y -- Auto Logic Applied Here
        
        if Config.Humanizer.Enabled then
            finalX = finalX + (math.random(-Config.Humanizer.Strength, Config.Humanizer.Strength))
            finalY = finalY + (math.random(-Config.Humanizer.Strength, Config.Humanizer.Strength))
        end
        
        pcall(function()
            VirtualInputManager:SendMouseButtonEvent(finalX, finalY, 0, true, game, 1)
            task.wait(0.06)
            VirtualInputManager:SendMouseButtonEvent(finalX, finalY, 0, false, game, 1)
        end)
    end
end

function Engine.Play(isLoop)
    if Axiora.State.IsReplaying or #Axiora.Cache.Data == 0 then return end
    Axiora.State.IsReplaying = true
    Axiora.State.IsLooping = isLoop
    if Config.BatterySaver then Thermal.SetEcoMode(true) end
    
    Axiora.Threads["Replay"] = task.spawn(function()
        while Axiora.State.IsReplaying do
            local prevTime = 0
            Axiora.State.CurrentIndex = 0
            
            -- Initial Movement Sync
            if Axiora.Cache.Data[1] and Axiora.Cache.Data[1].Type == "Move" then
                 -- If far away, walk to start first?
                 -- Engine handles this naturally via SmartMove
            end
            
            for i, action in ipairs(Axiora.Cache.Data) do
                if not Axiora.State.IsReplaying then break end
                Axiora.State.CurrentIndex = i
                Engine.ExecuteStep(action, prevTime)
                prevTime = action.Time
            end
            
            if not Axiora.State.IsLooping then break end
            
            if Config.AntiAFK then
                pcall(function() VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Unknown, false, game) end)
            end
            task.wait(0.5)
        end
        Engine.Stop()
    end)
end
--// [PART C: VISUAL INTERFACE v1.2] //

-- UI Components
local UI = {}
local Screens = {}
local MainUI = Instance.new("ScreenGui")
MainUI.Name = "AxioraOmega_Clean"
MainUI.Parent = CoreGui
MainUI.IgnoreGuiInset = true 
MainUI.ResetOnSpawn = false

local function CreateCorner(p, r) local c=Instance.new("UICorner",p); c.CornerRadius=UDim.new(0,r) return c end

local function EnableDrag(frame, handle)
    local dragging, dragStart, startPos
    handle.InputBegan:Connect(function(i) if i.UserInputType.Name:match("Touch") or i.UserInputType.Name:match("Mouse") then dragging=true; dragStart=i.Position; startPos=frame.Position end end)
    handle.InputEnded:Connect(function(i) if i.UserInputType.Name:match("Touch") or i.UserInputType.Name:match("Mouse") then dragging=false end end)
    UserInputService.InputChanged:Connect(function(i) if dragging and (i.UserInputType.Name:match("Mouse") or i.UserInputType.Name:match("Touch")) then local d = i.Position-dragStart; frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset+d.X, startPos.Y.Scale, startPos.Y.Offset+d.Y) end end)
end

-- Slider Component (The replacement for TextBoxes)
local function AddSlider(parent, text, range, callback)
    local min, max = -range, range
    local Frame = Instance.new("Frame", parent)
    Frame.Size = UDim2.new(1,0,0,50); Frame.BackgroundColor3=Theme.Content; CreateCorner(Frame,6)
    
    local Title = Instance.new("TextLabel", Frame); Title.Text=text; Title.TextColor3=Theme.SubText; Title.BackgroundTransparency=1; Title.Size=UDim2.new(1,-10,0,20); Title.Position=UDim2.new(0,10,0,5); Title.Font=Enum.Font.GothamBold; Title.TextXAlignment=Enum.TextXAlignment.Left; Title.TextSize=12
    
    local ValueL = Instance.new("TextLabel", Frame); ValueL.Text="0 px"; ValueL.TextColor3=Theme.Accent; ValueL.BackgroundTransparency=1; ValueL.Size=UDim2.new(1,-10,0,20); ValueL.Position=UDim2.new(0,0,0,5); ValueL.Font=Enum.Font.GothamBold; ValueL.TextXAlignment=Enum.TextXAlignment.Right; ValueL.TextSize=12
    
    local BarBg = Instance.new("Frame", Frame); BarBg.Size=UDim2.new(0.9,0,0,4); BarBg.Position=UDim2.new(0.05,0,0.7,0); BarBg.BackgroundColor3=Theme.Sidebar; CreateCorner(BarBg,2)
    local Fill = Instance.new("Frame", BarBg); Fill.Size=UDim2.new(0.5,0,1,0); Fill.BackgroundColor3=Theme.Accent; CreateCorner(Fill,2)
    local Knob = Instance.new("Frame", BarBg); Knob.Size=UDim2.new(0,14,0,14); Knob.Position=UDim2.new(0.5,-7,0.5,-7); Knob.BackgroundColor3=Theme.Text; CreateCorner(Knob,7)
    
    local dragging = false
    local function Update(inputX)
        local barPos = BarBg.AbsolutePosition.X
        local barSize = BarBg.AbsoluteSize.X
        local alpha = math.clamp((inputX - barPos) / barSize, 0, 1)
        
        Knob.Position = UDim2.new(alpha, -7, 0.5, -7)
        Fill.Size = UDim2.new(alpha, 0, 1, 0)
        
        local value = math.floor(min + (max - min) * alpha)
        ValueL.Text = (value > 0 and "+" or "") .. value .. " px"
        callback(value)
    end
    
    Knob.InputBegan:Connect(function(i) if i.UserInputType.Name:match("Touch") or i.UserInputType.Name:match("Mouse") then dragging=true end end)
    UserInputService.InputEnded:Connect(function(i) if i.UserInputType.Name:match("Touch") or i.UserInputType.Name:match("Mouse") then dragging=false end end)
    UserInputService.InputChanged:Connect(function(i) if dragging and (i.UserInputType.Name:match("Mouse") or i.UserInputType.Name:match("Touch")) then Update(i.Position.X) end end)
end

-- New Button & Tab System
local MainFrame = Instance.new("Frame", MainUI); MainFrame.Size=UDim2.new(0,500,0,300); MainFrame.Position=UDim2.fromScale(0.5,0.5); MainFrame.AnchorPoint=Vector2.new(0.5,0.5); MainFrame.BackgroundColor3=Theme.Background; CreateCorner(MainFrame,10)
local Sidebar = Instance.new("Frame", MainFrame); Sidebar.Size=UDim2.new(0,130,1,0); Sidebar.BackgroundColor3=Theme.Sidebar; CreateCorner(Sidebar,10)
local Title = Instance.new("TextLabel", Sidebar); Title.Text="AXIORA"; Title.TextColor3=Theme.Accent; Title.Font=Enum.Font.GothamBlack; Title.TextSize=20; Title.Size=UDim2.new(1,0,0,45); Title.BackgroundTransparency=1
local PageCont = Instance.new("Frame", MainFrame); PageCont.Size=UDim2.new(1,-140,1,-10); PageCont.Position=UDim2.new(0,140,0,10); PageCont.BackgroundTransparency=1; PageCont.ClipsDescendants=true

local Pages = {}
local function CreatePage(name, icon)
    local btn = Instance.new("TextButton", Sidebar); btn.Size=UDim2.new(1,-10,0,35); btn.Position=UDim2.new(0,5,0,50 + (#Pages*40)); btn.BackgroundColor3=Theme.Sidebar; btn.Text="   "..icon.." "..name; btn.TextColor3=Theme.SubText; btn.Font=Enum.Font.GothamBold; btn.TextSize=12; btn.TextXAlignment=Enum.TextXAlignment.Left; CreateCorner(btn,6)
    local page = Instance.new("ScrollingFrame", PageCont); page.Size=UDim2.new(1,0,1,0); page.BackgroundTransparency=1; page.ScrollBarThickness=2; page.Visible=false;
    local layout = Instance.new("UIListLayout", page); layout.Padding=UDim.new(0,6); layout.SortOrder=Enum.SortOrder.LayoutOrder
    local pad = Instance.new("UIPadding", page); pad.PaddingRight=UDim.new(0,5)
    
    btn.MouseButton1Click:Connect(function()
        for _,p in pairs(Pages) do p.page.Visible=false; TweenService:Create(p.btn,TweenInfo.new(0.2),{TextColor3=Theme.SubText}):Play() end
        page.Visible=true; TweenService:Create(btn,TweenInfo.new(0.2),{TextColor3=Theme.Text}):Play()
    end)
    table.insert(Pages, {btn=btn, page=page})
    return page
end

local function AddBigBtn(parent, text, color, callback)
    local b = Instance.new("TextButton", parent); b.Size=UDim2.new(1,0,0,40); b.BackgroundColor3=color; b.Text=text; b.TextColor3=Theme.Text; b.Font=Enum.Font.GothamBold; CreateCorner(b,8)
    b.MouseButton1Click:Connect(function() 
        TweenService:Create(b,TweenInfo.new(0.1),{TextSize=12}):Play()
        task.delay(0.1, function() TweenService:Create(b,TweenInfo.new(0.1),{TextSize=14}):Play() end)
        callback() 
    end)
    return b -- Return for text updates
end

-- PAGE 1: HOME
local P_Home = CreatePage("Home", "üè†")
local Info = Instance.new("TextLabel", P_Home); Info.Size=UDim2.new(1,0,0,80); Info.BackgroundColor3=Theme.Content; Info.Text="SYSTEM READY\nStatus: IDLE"; Info.TextColor3=Theme.SubText; Info.Font=Enum.Font.GothamBold; Info.TextSize=16; CreateCorner(Info,8)

local RecB = AddBigBtn(P_Home, "START RECORDING", Theme.Content, function()
    if Axiora.State.IsRecording then Engine.Stop() Info.Text="SYSTEM READY" else Engine.StartRecording() Info.Text="‚óè RECORDING" Info.TextColor3=Theme.Danger end
end)
local PlayB = AddBigBtn(P_Home, "PLAY LOOP", Theme.Accent, function()
    if Axiora.State.IsReplaying then Engine.Stop() Info.Text="SYSTEM READY" else Engine.Play(true) Info.Text="‚ñ∂ PLAYING" Info.TextColor3=Theme.Success end
end)

-- PAGE 2: SETTINGS (With SLIDERS)
local P_Set = CreatePage("Settings", "‚öôÔ∏è")
AddSlider(P_Set, "Manual Offset X", 50, function(v) Config.Offset.X = v end)
AddSlider(P_Set, "Manual Offset Y", 100, function(v) Config.Offset.Y = v end)

-- HUD Update Loop
task.spawn(function()
    while task.wait(0.2) do
        if Axiora.State.IsRecording then RecB.Text="STOP RECORDING ("..#Axiora.Cache.Data..")" 
        else RecB.Text="START RECORDING" end
        if Axiora.State.IsReplaying then PlayB.Text="STOP ("..Axiora.State.CurrentIndex..")"
        else PlayB.Text="PLAY LOOP" end
    end
end)

-- Initial State
EnableDrag(MainFrame, Sidebar)
Pages[1].page.Visible = true

-- Toggle Button (Floating)
local Toggle = Instance.new("TextButton", MainUI); Toggle.Size=UDim2.new(0,45,0,45); Toggle.Position=UDim2.new(0,20,0.5,-22); Toggle.BackgroundColor3=Theme.Sidebar; Toggle.Text="Œ©"; Toggle.TextColor3=Theme.Accent; Toggle.Font=Enum.Font.GothamBlack; Toggle.TextSize=20; CreateCorner(Toggle,22); EnableDrag(Toggle,Toggle)
Toggle.MouseButton1Click:Connect(function() MainFrame.Visible = not MainFrame.Visible end)
