
--[[
    Roblox Macro V2: Fully Responsive & Enhanced GUI
    This version implements screen-size normalization for accurate replay on any resolution,
    adds robust input validation, and improves user feedback.
]]

local UserInputService = game:GetService("UserInputService")
local VirtualUser = game:GetService("VirtualUser")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local CoreGui = game:GetService("CoreGui")

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MacroV2_GUI"
screenGui.Parent = CoreGui
screenGui.IgnoreGuiInset = true

local recordedActions = {}
local isRecording = false
local isReplaying = false
local clickInterval = 0.1 -- Default click interval in seconds
local replayCount = 1
local defaultRecordedResolution = Vector2.new(1920, 1080) -- Reference resolution for normalization

-- Local GUI Elements Setup
local mainFrame
local contentFrame
local tabButtons = {}

-- Helper to safely encode Unicode strings to base64 (Not used in Lua, but kept in mind for context)
local function sendNotification(title, message, duration)
    -- Simplified notification for display purposes
    print(string.format("[Notification] %s: %s", title, message))
    -- In a real Roblox environment, this would show an actual UI notification
end

local function getViewportSize()
    return UserInputService.ViewportSize
end

-- 1. FIX: Normalization Functions
local function toNormalized(position)
    local viewport = getViewportSize()
    return Vector2.new(
        position.X / viewport.X,
        position.Y / viewport.Y
    )
end

local function fromNormalized(normPos)
    local viewport = getViewportSize()
    return Vector2.new(
        normPos.X * viewport.X,
        normPos.Y * viewport.Y
    )
end

-- 2. IMPROVEMENT: Screen Ratio Calculation for Replay
local function getDeviceRatio()
    local currentSize = getViewportSize()
    return {
        x = currentSize.X / defaultRecordedResolution.X,
        y = currentSize.Y / defaultRecordedResolution.Y
    }
end

local function adjustForScreen(normPos)
    local currentSize = getViewportSize()
    -- Calculate pixel position based on current viewport size and recorded normalized position
    return Vector2.new(
        normPos.X * currentSize.X, 
        normPos.Y * currentSize.Y
    )
end

-- Base GUI Creation Helpers
local function createFrame(size, position, parent)
    local frame = Instance.new("Frame")
    frame.Size = size or UDim2.new(0.3, 0, 0.6, 0) -- Responsive default size
    frame.Position = position or UDim2.new(0.5, -frame.Size.X.Offset/2, 0.5, -frame.Size.Y.Offset/2)
    frame.AnchorPoint = Vector2.new(0.5, 0.5)
    frame.BackgroundColor3 = Color3.fromHex("161b22") -- Dark Card
    frame.BorderSizePixel = 0
    frame.BorderColor3 = Color3.fromHex("30363d")
    frame.ClipsDescendants = true
    frame.Parent = parent
    return frame
end

local function createTextLabel(text, size, parent)
    local label = Instance.new("TextLabel")
    label.Text = text
    label.Size = size or UDim2.new(1, 0, 0, 30)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromHex("c9d1d9") -- Light Text
    label.TextSize = 16 -- Will be adjusted responsively
    label.Font = Enum.Font.SourceSans
    label.Parent = parent
    return label
end

local function createButton(text, width, parent)
    local button = Instance.new("TextButton")
    button.Text = text
    button.Size = UDim2.new(0, width, 0, 35)
    button.BackgroundColor3 = Color3.fromHex("238636") -- GitHub Green
    button.TextColor3 = Color3.new(1, 1, 1)
    button.TextSize = 16
    button.Font = Enum.Font.SourceSans
    button.Parent = parent
    return button
end

local function createInput(default, width, parent)
    local input = Instance.new("TextBox")
    input.Text = default
    input.Size = UDim2.new(0, width, 0, 35)
    input.BackgroundColor3 = Color3.fromHex("0d1117") -- Dark background
    input.TextColor3 = Color3.fromHex("58a6ff") -- Blue highlight
    input.TextSize = 16
    input.Font = Enum.Font.SourceSans
    input.TextXAlignment = Enum.TextXAlignment.Left
    input.TextYAlignment = Enum.TextYAlignment.Center
    input.ClearTextOnFocus = false
    input.Parent = parent
    return input
end

local function createPadding(parent)
    local padding = Instance.new("UIListLayout")
    padding.Padding = UDim.new(0, 5)
    padding.SortOrder = Enum.SortOrder.LayoutOrder
    padding.Parent = parent
    return padding
end

-- Main GUI Initialization
mainFrame = createFrame(UDim2.new(0.3, 0, 0.6, 0), UDim2.new(0.5, 0, 0.5, 0), screenGui)
local uiList = Instance.new("UIListLayout")
uiList.FillDirection = Enum.FillDirection.Vertical
uiList.Padding = UDim.new(0, 10)
uiList.HorizontalAlignment = Enum.HorizontalAlignment.Center
uiList.Parent = mainFrame

local title = createTextLabel("Roblox Macro V2", UDim2.new(1, -20, 0, 30), mainFrame)
title.Position = UDim2.new(0.5, 0, 0, 10)
title.TextScaled = true -- Responsive text size

local tabsContainer = createFrame(UDim2.new(1, -20, 0, 40), nil, mainFrame)
tabsContainer.BackgroundColor3 = Color3.fromHex("0d1117")
tabsContainer.LayoutUtil = Instance.new("UIListLayout")
tabsContainer.LayoutUtil.FillDirection = Enum.FillDirection.Horizontal
tabsContainer.LayoutUtil.Parent = tabsContainer
tabsContainer.LayoutUtil.HorizontalAlignment = Enum.HorizontalAlignment.Center

local tabContent = createFrame(UDim2.new(1, -20, 1, -80), nil, mainFrame)
tabContent.BackgroundColor3 = Color3.fromHex("0d1117")
tabContent.LayoutUtil = Instance.new("UIListLayout")
tabContent.LayoutUtil.FillDirection = Enum.FillDirection.Vertical
tabContent.LayoutUtil.Padding = UDim.new(0, 10)
tabContent.LayoutUtil.Parent = tabContent

-- Tab Creation Logic
local currentTab = nil

local function createTabButton(name)
    local btn = createButton(name, 100, tabsContainer)
    btn.Size = UDim2.new(1/3, 0, 1, 0)
    btn.BackgroundColor3 = Color3.fromHex("30363d") -- Inactive tab color
    tabButtons[name] = btn

    btn.MouseButton1Click:Connect(function()
        if currentTab then
            tabButtons[currentTab].BackgroundColor3 = Color3.fromHex("30363d")
        end
        currentTab = name
        btn.BackgroundColor3 = Color3.fromHex("161b22") -- Active tab color
        -- Clear content and display new tab content
        for _, child in pairs(tabContent:GetChildren()) do
            if child:IsA("Frame") or child:IsA("ScrollingFrame") then
                child:Destroy()
            end
        end
        if name == "Record" then setupRecordTab()
        elseif name == "Replay" then setupReplayTab()
        elseif name == "Settings" then setupSettingsTab()
        end
    end)
    return btn
end

createTabButton("Record")
createTabButton("Replay")
createTabButton("Settings")

-- === TAB CONTENT ===

-- 1. Record Tab
local function setupRecordTab()
    local recordContent = createFrame(UDim2.new(1, 0, 1, 0), nil, tabContent)
    recordContent.BackgroundColor3 = Color3.fromHex("161b22")
    createPadding(recordContent)
    
    local btnToggleRecording = createButton("Start Recording", 170, recordContent)
    btnToggleRecording.BackgroundColor3 = Color3.fromHex("238636") -- Green

    local btnSetPosition = createButton("Set Position (Q)", 170, recordContent)
    btnSetPosition.BackgroundColor3 = Color3.fromHex("30363d")

    local btnClearActions = createButton("Clear Recorded Actions", 170, recordContent)
    btnClearActions.BackgroundColor3 = Color3.fromHex("dc3232") -- Red

    local actionDisplay = Instance.new("ScrollingFrame", recordContent)
    actionDisplay.Size = UDim2.new(1, 0, 1, -120) -- Take remaining vertical space
    actionDisplay.BackgroundColor3 = Color3.fromHex("0d1117")
    actionDisplay.CanvasSize = UDim2.new(0, 0, 0, 0)
    actionDisplay.ScrollBarThickness = 5
    actionDisplay.HorizontalScrollBarVisible = false

    local actionList = Instance.new("UIListLayout", actionDisplay)
    actionList.FillDirection = Enum.FillDirection.Vertical
    actionList.Padding = UDim.new(0, 2)
    actionList.Parent = actionDisplay

    local function updateActionDisplay()
        for _, child in pairs(actionDisplay:GetChildren()) do
            if child:IsA("TextLabel") then child:Destroy() end
        end
        for i, action in ipairs(recordedActions) do
            local text = string.format("%d. %s at (%.0f, %.0f)", i, action.type, action.normPos.X * 100, action.normPos.Y * 100)
            local lbl = createTextLabel(text, UDim2.new(1, 0, 0, 20), actionDisplay)
            lbl.TextSize = 12
        end
        actionDisplay.CanvasSize = UDim2.new(0, 0, 0, #recordedActions * 22)
    end

    -- Toggle Recording Logic
    btnToggleRecording.MouseButton1Click:Connect(function()
        if not isReplaying then
            isRecording = not isRecording
            if isRecording then
                btnToggleRecording.Text = "Recording..."
                btnToggleRecording.BackgroundColor3 = Color3.fromHex("dc3232") -- Red: Recording
                sendNotification("Recording", "Recording has started.", 1)
            else
                btnToggleRecording.Text = "Start Recording"
                btnToggleRecording.BackgroundColor3 = Color3.fromHex("238636") -- Green: Stopped
                sendNotification("Recording", "Recording has stopped.", 1)
            end
        end
    end)

    -- Set Position Logic (Keybind Q)
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if input.KeyCode == Enum.KeyCode.Q and not gameProcessed and isRecording then
            local pos = UserInputService:GetMouseLocation()
            local normPos = toNormalized(pos)
            table.insert(recordedActions, {
                type = "Tap", 
                normPos = normPos,
                time = os.clock(), -- Record absolute time
                interval = clickInterval
            })
            btnSetPosition.Text = "Position Set!"
            updateActionDisplay()
            -- 3. IMPROVEMENT: Extended notification duration
            task.delay(2, function() 
                if btnSetPosition.Text == "Position Set!" then
                    btnSetPosition.Text = "Set Position (Q)"
                end
            end)
        end
    end)

    -- 2. IMPROVEMENT: Clear actions button logic
    btnClearActions.MouseButton1Click:Connect(function()
        recordedActions = {}
        updateActionDisplay()
        sendNotification("Cleared", "All recorded actions have been cleared.")
    end)
    
    updateActionDisplay() -- Initial display load
end

-- 2. Replay Tab
local function setupReplayTab()
    local replayContent = createFrame(UDim2.new(1, 0, 1, 0), nil, tabContent)
    replayContent.BackgroundColor3 = Color3.fromHex("161b22")
    createPadding(replayContent)

    local replayControls = createFrame(UDim2.new(1, 0, 0, 80), nil, replayContent)
    replayControls.BackgroundTransparency = 1
    local controlsLayout = Instance.new("UIListLayout", replayControls)
    controlsLayout.FillDirection = Enum.FillDirection.Vertical
    controlsLayout.Padding = UDim.new(0, 5)
    controlsLayout.Parent = replayControls

    local btnReplay = createButton("Start Replay", 170, replayControls)
    btnReplay.BackgroundColor3 = Color3.fromHex("238636")
    
    local lblIntervalDesc = createTextLabel("Click Interval (secs > 0.05):", UDim2.new(1, 0, 0, 20), replayControls)
    lblIntervalDesc.TextSize = 14
    local lblInterval = createInput(tostring(clickInterval), 100, replayControls)
    
    local lblReplayCountDesc = createTextLabel("Replay Amount (times > 0):", UDim2.new(1, 0, 0, 20), replayControls)
    lblReplayCountDesc.TextSize = 14
    local replayCountInput = createInput(tostring(replayCount), 100, replayControls)

    -- 4. Input Validation Enhancements
    lblInterval.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            local val = tonumber(lblInterval.Text)
            if val and val > 0.05 then
                clickInterval = val
                sendNotification("Setting Updated", "Click Interval set to " .. tostring(clickInterval) .. "s")
            else
                lblInterval.Text = tostring(clickInterval)
                sendNotification("Invalid Value", "Interval must be > 0.05 seconds.")
            end
        end
    end)

    replayCountInput.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            local val = tonumber(replayCountInput.Text)
            if val and val > 0 then
                replayCount = math.floor(val)
                sendNotification("Setting Updated", "Replay Count set to " .. tostring(replayCount))
            else
                replayCountInput.Text = tostring(replayCount)
                sendNotification("Invalid Value", "Replay count must be a positive integer.")
            end
        end
    end)

    -- Replay Logic
    btnReplay.MouseButton1Click:Connect(function()
        if isRecording then
            sendNotification("Error", "Stop recording before starting replay.")
            return
        end
        if #recordedActions == 0 then
            sendNotification("Error", "No actions recorded to replay.")
            return
        end
        
        isReplaying = true
        btnReplay.Text = "Replaying..."
        btnReplay.BackgroundColor3 = Color3.fromHex("58a6ff") -- Blue: Replaying
        sendNotification("Replay", string.format("Starting %d replays...", replayCount))

        local currentReplay = 0
        local function executeReplay()
            currentReplay = currentReplay + 1
            if currentReplay > replayCount then
                isReplaying = false
                btnReplay.Text = "Start Replay"
                btnReplay.BackgroundColor3 = Color3.fromHex("238636")
                sendNotification("Replay Complete", "All replays finished.")
                return
            end
            
            for i, action in ipairs(recordedActions) do
                if not isReplaying then break end -- Emergency stop
                
                -- 1. FIX: Use screen adjustment for normalized position
                local pixelPos = adjustForScreen(action.normPos)

                -- Use VirtualUser for reliable click simulation
                VirtualUser:Button2Down(pixelPos.X, pixelPos.Y)
                VirtualUser:Button2Up(pixelPos.X, pixelPos.Y)
                
                -- Wait for the configured interval
                task.wait(action.interval)
            end
            
            -- Wait a short moment between replays
            task.wait(clickInterval) 
            
            if isReplaying then
                executeReplay() -- Recursive call for next replay
            end
        end

        executeReplay()
    end)
end

-- 3. Settings Tab
local function setupSettingsTab()
    local settingsContent = createFrame(UDim2.new(1, 0, 1, 0), nil, tabContent)
    settingsContent.BackgroundColor3 = Color3.fromHex("161b22")
    createPadding(settingsContent)

    -- Swipe Speed Control
    local lblSwipeSpeedDesc = createTextLabel("Swipe Duration (sec, default 0.15):", UDim2.new(1, 0, 0, 20), settingsContent)
    lblSwipeSpeedDesc.TextSize = 14
    local swipeSpeedInput = createInput("0.15", 100, settingsContent) -- 3. Swipe System Improvements
    
    -- Swipe Curvature Control
    local lblCurveDesc = createTextLabel("Swipe Curvature (0=Straight, 10-50=Curve):", UDim2.new(1, 0, 0, 20), settingsContent)
    lblCurveDesc.TextSize = 14
    local swipeCurveInput = createInput("20", 100, settingsContent)
    
    -- Screen Calibration Placeholder (Future implementation)
    local btnCalibrate = createButton("Calibrate Screen (WIP)", 170, settingsContent)
    btnCalibrate.BackgroundColor3 = Color3.fromHex("30363d")
    
    local lblNotes = createTextLabel("Note: To record a SWIPE, press 'S' on initial click, then release 'S' on final position.", UDim2.new(1, 0, 0, 40), settingsContent)
    lblNotes.TextWrapped = true
    lblNotes.TextSize = 12
    lblNotes.TextColor3 = Color3.fromHex("e3b341") -- Yellow

    -- Add swipe logic placeholders (future enhancement)
end

-- Initialize the GUI on the "Record" tab
task.wait(0.1) -- Wait for UI to load
if tabButtons["Record"] then
    tabButtons["Record"].MouseButton1Click:Fire()
end
    
    