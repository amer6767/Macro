
--[[
    Roblox Macro V2: Persistence, Swipe Support, and Fixed Calibration
    This version adds DataStore persistence and the ability to record/replay swipe actions.
]]

local UserInputService = game:GetService("UserInputService")
local VirtualUser = game:GetService("VirtualUser")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local HttpService = game:GetService("HttpService") -- For Save/Load JSON encoding
local DataStoreService = game:GetService("DataStoreService") -- For Persistence

local MACRO_STORE = "MacroV2_Library"
local SWIPE_MIN_PIXELS = 50 -- Minimum distance to be considered a swipe

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MacroV2_GUI"
screenGui.Parent = CoreGui
screenGui.IgnoreGuiInset = true

local macroData = {
    name = "New Macro",
    actions = {},
    recordedResolution = Vector2.new(1920, 1080) -- Default, will be updated by calibration
}
local isRecording = false
local isReplaying = false
local isCalibrating = false
local clickInterval = 0.1 -- Default click interval in seconds
local replayCount = 1

local tabButtons = {}
local recordingIndicator -- Visual feedback element
local currentDragData = nil -- Tracks swipe/drag actions

-- Helper Functions
local function getViewportSize()
    return UserInputService.ViewportSize
end

local function sendNotification(title, message)
    -- Placeholder for better in-game notification, prints to console for now
    print(string.format("[Notification] %s: %s", title, message))
end

-- Advanced Normalization for Aspect Ratio Correction
local function adjustForScreen(normPos)
    local recordedRes = macroData.recordedResolution
    local currentRes = getViewportSize()

    local xRatio = currentRes.X / recordedRes.X
    local yRatio = currentRes.Y / recordedRes.Y
    
    -- Use the minimum ratio for consistent scaling (Aspect Ratio Preservation)
    local scaleRatio = math.min(xRatio, yRatio)

    -- Calculate offsets to center the macro area on non-matching aspect ratios
    local offsetX = (currentRes.X - (recordedRes.X * scaleRatio)) / 2
    local offsetY = (currentRes.Y - (recordedRes.Y * scaleRatio)) / 2
    
    -- Calculate position based on scale and offset
    local adjustedX = (normPos.X * recordedRes.X * scaleRatio) + offsetX
    local adjustedY = (normPos.Y * recordedRes.Y * scaleRatio) + offsetY
    
    return Vector2.new(adjustedX, adjustedY)
end

local function toNormalized(position)
    local recordedRes = macroData.recordedResolution
    return Vector2.new(
        position.X / recordedRes.X,
        position.Y / recordedRes.Y
    )
end

-- 1. CORE FEATURE: DataStore Save/Load
local function saveMacro()
    if #macroData.actions == 0 then
        sendNotification("Error", "No actions to save.")
        return
    end
    
    local success, err = pcall(function()
        local data = HttpService:JSONEncode(macroData)
        DataStoreService:GetDataStore(MACRO_STORE):SetAsync(macroData.name, data)
    end)

    if success then
        sendNotification("Saved", string.format("Macro '%s' saved successfully.", macroData.name))
    else
        sendNotification("Error", "Failed to save macro: " .. (err or "Unknown Error"))
    end
end

local function loadMacro(name)
    if name == "" or not name then
        sendNotification("Error", "Please enter a macro name to load.")
        return
    end

    local json, err = pcall(function()
        return DataStoreService:GetDataStore(MACRO_STORE):GetAsync(name)
    end)
    
    if json and json ~= "" then
        local success, loadedData = pcall(function()
            return HttpService:JSONDecode(json)
        end)
        
        if success and loadedData and loadedData.actions then
            macroData = loadedData
            sendNotification("Loaded", string.format("Macro '%s' loaded. Resolution: %dx%d", macroData.name, macroData.recordedResolution.X, macroData.recordedResolution.Y))
            -- Force update of GUI to show new actions/settings (requires re-firing the tab click)
            if tabButtons[currentTab] then tabButtons[currentTab].MouseButton1Click:Fire() end 
        else
            sendNotification("Error", "Failed to decode macro data.")
        end
    elseif err then
        sendNotification("Error", "Failed to load macro: " .. (err or "Unknown Error"))
    else
        sendNotification("Error", string.format("Macro '%s' not found.", name))
    end
end

-- === GUI CORE HELPERS (Modern Look with UICorner) ===

local function addUICorner(parent, radius)
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, radius or 8)
    corner.Parent = parent
end

local function createFrame(size, position, parent)
    local frame = Instance.new("Frame")
    frame.Size = size or UDim2.new(0.3, 0, 0.6, 0)
    frame.Position = position or UDim2.new(0.5, 0, 0.5, 0)
    frame.AnchorPoint = Vector2.new(0.5, 0.5)
    frame.BackgroundColor3 = Color3.fromHex("161b22")
    frame.BorderSizePixel = 0
    addUICorner(frame, 8) -- Rounded corners
    frame.Parent = parent
    return frame
end

local function createButton(text, width, parent)
    local button = Instance.new("TextButton")
    button.Text = text
    button.Size = UDim2.new(0, width, 0, 35)
    button.BackgroundColor3 = Color3.fromHex("238636")
    button.TextColor3 = Color3.new(1, 1, 1)
    button.TextSize = 16
    button.Font = Enum.Font.SourceSans
    addUICorner(button, 6) -- Rounded corners
    button.Parent = parent
    return button
end

local function createInput(default, width, parent)
    local input = Instance.new("TextBox")
    input.Text = default
    input.Size = UDim2.new(0, width, 0, 35)
    input.BackgroundColor3 = Color3.fromHex("0d1117") -- Dark background
    input.TextColor3 = Color3.fromHex("58a6ff") -- Blue highlight
    input.TextSize = 16
    addUICorner(input, 6) -- Rounded corners
    input.Font = Enum.Font.SourceSans
    input.TextXAlignment = Enum.TextXAlignment.Left
    input.TextYAlignment = Enum.TextYAlignment.Center
    input.ClearTextOnFocus = false
    input.Parent = parent
    return input
end

-- Main GUI Initialization
local mainFrame = createFrame(UDim2.new(0.8, 0, 0.7, 0), UDim2.new(0.5, 0, 0.5, 0), screenGui)
local uiList = Instance.new("UIListLayout")
uiList.FillDirection = Enum.FillDirection.Vertical
uiList.Padding = UDim.new(0, 10)
uiList.HorizontalAlignment = Enum.HorizontalAlignment.Center
uiList.Parent = mainFrame
local uiPadding = Instance.new("UIPadding", mainFrame)
uiPadding.PaddingTop = UDim.new(0, 15)
uiPadding.PaddingBottom = UDim.new(0, 15)

-- Prominent Recording Indicator
recordingIndicator = Instance.new("Frame", mainFrame)
recordingIndicator.Size = UDim2.new(0, 15, 0, 15)
recordingIndicator.Position = UDim2.new(1, -25, 0, 10)
recordingIndicator.AnchorPoint = Vector2.new(1, 0)
recordingIndicator.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
recordingIndicator.Visible = false
addUICorner(recordingIndicator, 15) -- Circle shape

local title = Instance.new("TextLabel", mainFrame)
title.Text = "Roblox Macro V2"
title.Size = UDim2.new(1, -30, 0, 30)
title.BackgroundTransparency = 1
title.TextColor3 = Color3.fromHex("c9d1d9")
title.TextScaled = true

-- Tabs Container
local tabsContainer = createFrame(UDim2.new(1, 0, 0, 40), nil, mainFrame)
tabsContainer.BackgroundColor3 = Color3.fromHex("0d1117")
tabsContainer.BorderSizePixel = 0
addUICorner(tabsContainer, 8)

local tabsLayout = Instance.new("UIListLayout")
tabsLayout.FillDirection = Enum.FillDirection.Horizontal
tabsLayout.Parent = tabsContainer
tabsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
tabsLayout.VerticalAlignment = Enum.VerticalAlignment.Center

local tabContent = createFrame(UDim2.new(1, 0, 1, -100), nil, mainFrame)
tabContent.BackgroundColor3 = Color3.fromHex("0d1117")
tabContent.BorderSizePixel = 0
addUICorner(tabContent, 8)

local currentTab = nil

local function createTabButton(name)
    local btn = createButton(name, 100, tabsContainer)
    btn.Size = UDim2.new(0.33, 0, 1, 0) -- Responsive sizing
    btn.BackgroundColor3 = Color3.fromHex("30363d") 
    btn.TextColor3 = Color3.fromHex("c9d1d9") 
    tabButtons[name] = btn

    btn.MouseButton1Click:Connect(function()
        if currentTab then
            tabButtons[currentTab].BackgroundColor3 = Color3.fromHex("30363d")
        end
        currentTab = name
        btn.BackgroundColor3 = Color3.fromHex("161b22") 
        
        -- Clear content and display new tab content
        for _, child in pairs(tabContent:GetChildren()) do
            if not child:IsA("UIListLayout") and not child:IsA("UIPadding") and not child:IsA("UICorner") then
                child:Destroy()
            end
        end
        
        if name == "Record" then setupRecordTab()
        elseif name == "Replay" then setupReplayTab()
        elseif name == "Settings" then setupSettingsTab()
        end
    end)
    return btn
end

createTabButton("Record")
createTabButton("Replay")
createTabButton("Settings")

-- 1. Record Tab
local function setupRecordTab()
    local recordContent = Instance.new("ScrollingFrame", tabContent)
    recordContent.Size = UDim2.new(1, 0, 1, 0)
    recordContent.BackgroundTransparency = 1
    recordContent.ScrollBarThickness = 5

    local listLayout = Instance.new("UIListLayout", recordContent)
    listLayout.FillDirection = Enum.FillDirection.Vertical
    listLayout.Padding = UDim.new(0, 10)
    listLayout.Parent = recordContent
    
    local nameInput = createInput(macroData.name, 200, recordContent)
    nameInput.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            macroData.name = nameInput.Text
            sendNotification("Macro Name", "Name set to: " .. macroData.name)
        end
    end)

    local btnToggleRecording = createButton(isRecording and "Recording..." or "Start Recording", 170, recordContent)
    btnToggleRecording.BackgroundColor3 = isRecording and Color3.fromHex("dc3232") or Color3.fromHex("238636")

    local btnClearActions = createButton("Clear Actions", 170, recordContent)
    btnClearActions.BackgroundColor3 = Color3.fromHex("dc3232") 
    
    local actionDisplay = Instance.new("Frame", recordContent)
    actionDisplay.Size = UDim2.new(1, 0, 0, 200) -- Fixed size for actions list

    local scrollFrame = Instance.new("ScrollingFrame", actionDisplay)
    scrollFrame.Size = UDim2.new(1, 0, 1, 0)
    scrollFrame.BackgroundTransparency = 1
    scrollFrame.ScrollBarThickness = 5

    local actionList = Instance.new("UIListLayout", scrollFrame)
    actionList.FillDirection = Enum.FillDirection.Vertical
    actionList.Padding = UDim.new(0, 2)
    
    local function createActionItem(index, action)
        local item = Instance.new("Frame", scrollFrame)
        item.Size = UDim2.new(1, 0, 0, 30)
        item.BackgroundColor3 = index % 2 == 1 and Color3.fromHex("0d1117") or Color3.fromHex("161b22")
        item.BorderSizePixel = 0
        
        local text
        if action.type == "Tap" then
            text = string.format("%d. TAP @ (%.1f, %.1f)", index, action.normPos.X * 100, action.normPos.Y * 100)
        elseif action.type == "Swipe" then
            text = string.format("%d. SWIPE Start(%.1f) End(%.1f) Dur(%.2fs)", index, action.startNorm.X * 100, action.endNorm.X * 100, action.duration)
        end

        local lbl = Instance.new("TextLabel", item)
        lbl.Text = text
        lbl.Size = UDim2.new(0.8, 0, 1, 0)
        lbl.BackgroundTransparency = 1
        lbl.TextColor3 = Color3.fromHex("c9d1d9")
        lbl.TextSize = 14
        lbl.TextXAlignment = Enum.TextXAlignment.Left
        
        -- Placeholder for future editing
        local btnEdit = createButton("Edit", 50, item)
        btnEdit.Size = UDim2.new(0.2, -10, 0.8, 0)
        btnEdit.Position = UDim2.new(0.8, 0, 0.5, 0)
        btnEdit.AnchorPoint = Vector2.new(0, 0.5)
        btnEdit.BackgroundColor3 = Color3.fromHex("58a6ff")
        btnEdit.TextSize = 12
        btnEdit.MouseButton1Click:Connect(function()
            sendNotification("Action Editor", "Feature not yet implemented: Editing action " .. index)
        end)
        
        return item
    end

    local function updateActionDisplay()
        for _, child in pairs(scrollFrame:GetChildren()) do
            if child:IsA("Frame") then child:Destroy() end
        end
        for i, action in ipairs(macroData.actions) do
            createActionItem(i, action)
        end
        scrollFrame.CanvasSize = UDim2.new(0, 0, 0, #macroData.actions * 32)
    end

    -- Toggle Recording Logic
    btnToggleRecording.MouseButton1Click:Connect(function()
        if not isReplaying and not isCalibrating then
            isRecording = not isRecording
            recordingIndicator.Visible = isRecording -- Show/hide indicator
            if isRecording then
                macroData.recordedResolution = getViewportSize() -- Record initial screen size
                btnToggleRecording.Text = "Recording..."
                btnToggleRecording.BackgroundColor3 = Color3.fromHex("dc3232")
                sendNotification("Recording", "Recording started. Resolution: " .. macroData.recordedResolution.X .. "x" .. macroData.recordedResolution.Y, 1)
            else
                btnToggleRecording.Text = "Start Recording"
                btnToggleRecording.BackgroundColor3 = Color3.fromHex("238636")
                sendNotification("Recording", "Recording stopped.", 1)
            end
        end
    end)

    -- 2. CORE FEATURE: Swipe and Tap Recording Logic
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not isRecording or gameProcessed then return end

        local inputType = input.UserInputType
        if inputType == Enum.UserInputType.MouseButton1 or inputType == Enum.UserInputType.Touch then
            currentDragData = {
                startPos = input.Position,
                startTime = tick(),
                movedDistance = 0,
                isDragging = true
            }
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input, gameProcessed)
        if not isRecording or gameProcessed or not currentDragData or not currentDragData.isDragging then return end

        local inputType = input.UserInputType
        if inputType == Enum.UserInputType.MouseMovement or inputType == Enum.UserInputType.Touch then
            local newPos = input.Position
            local delta = (newPos - currentDragData.startPos)
            -- Only update the moved distance when it moves past the threshold to prevent tap recording
            if delta.Magnitude > currentDragData.movedDistance then
                currentDragData.movedDistance = delta.Magnitude
            end
        end
    end)

    UserInputService.InputEnded:Connect(function(input, gameProcessed)
        if not isRecording or gameProcessed or not currentDragData or not currentDragData.isDragging then return end

        local inputType = input.UserInputType
        if inputType == Enum.UserInputType.MouseButton1 or inputType == Enum.UserInputType.Touch then
            local endPos = input.Position
            local duration = tick() - currentDragData.startTime
            local lastActionInterval = #macroData.actions > 0 and macroData.actions[#macroData.actions].interval or 0
            
            -- Determine the delay (the time since the last action finished)
            local delay = math.max(0, currentDragData.startTime - lastActionInterval) 

            if currentDragData.movedDistance >= SWIPE_MIN_PIXELS then
                -- Record as SWIPE
                table.insert(macroData.actions, {
                    type = "Swipe",
                    startNorm = toNormalized(currentDragData.startPos),
                    endNorm = toNormalized(endPos),
                    duration = duration,
                    interval = clickInterval -- Replay interval after swipe
                })
            else
                -- Record as TAP (if distance moved is small enough)
                table.insert(macroData.actions, {
                    type = "Tap", 
                    normPos = toNormalized(endPos),
                    interval = clickInterval
                })
            end
            
            currentDragData.isDragging = false
            currentDragData = nil
            updateActionDisplay()
        end
    end)

    btnClearActions.MouseButton1Click:Connect(function()
        macroData.actions = {}
        updateActionDisplay()
        sendNotification("Cleared", "All recorded actions have been cleared.")
    end)
    
    updateActionDisplay() 
end

-- 2. Replay Tab
local function setupReplayTab()
    local replayContent = Instance.new("Frame", tabContent)
    replayContent.Size = UDim2.new(1, 0, 1, 0)
    replayContent.BackgroundTransparency = 1
    local listLayout = Instance.new("UIListLayout", replayContent)
    listLayout.FillDirection = Enum.FillDirection.Vertical
    listLayout.Padding = UDim.new(0, 5)
    
    local btnReplay = createButton("Start Replay", 170, replayContent)
    btnReplay.BackgroundColor3 = Color3.fromHex("238636")
    
    local lblIntervalDesc = Instance.new("TextLabel", replayContent)
    lblIntervalDesc.Text = "Interval (secs > 0.05):"
    lblIntervalDesc.BackgroundTransparency = 1
    lblIntervalDesc.TextColor3 = Color3.fromHex("c9d1d9")
    lblIntervalDesc.TextSize = 14
    local lblInterval = createInput(tostring(clickInterval), 100, replayContent)
    
    local lblReplayCountDesc = Instance.new("TextLabel", replayContent)
    lblReplayCountDesc.Text = "Replay Amount (times > 0):"
    lblReplayCountDesc.BackgroundTransparency = 1
    lblReplayCountDesc.TextColor3 = Color3.fromHex("c9d1d9")
    lblReplayCountDesc.TextSize = 14
    local replayCountInput = createInput(tostring(replayCount), 100, replayContent)

    -- Input Validation
    lblInterval.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            local val = tonumber(lblInterval.Text)
            if val and val > 0.05 then clickInterval = val
            else lblInterval.Text = tostring(clickInterval); sendNotification("Invalid Value", "Interval must be > 0.05s.") end
        end
    end)

    replayCountInput.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            local val = tonumber(replayCountInput.Text)
            if val and val > 0 then replayCount = math.floor(val)
            else replayCountInput.Text = tostring(replayCount); sendNotification("Invalid Value", "Count must be a positive integer.") end
        end
    end)

    -- Replay Logic
    btnReplay.MouseButton1Click:Connect(function()
        if isRecording or isCalibrating then sendNotification("Error", "Stop recording/calibration first."); return end
        if #macroData.actions == 0 then sendNotification("Error", "No actions recorded. Load or record a macro first."); return end
        
        isReplaying = true
        btnReplay.Text = "Replaying..."
        btnReplay.BackgroundColor3 = Color3.fromHex("58a6ff")

        local currentReplay = 0
        local function executeReplay()
            currentReplay = currentReplay + 1
            if currentReplay > replayCount or not isReplaying then
                isReplaying = false
                btnReplay.Text = "Start Replay"
                btnReplay.BackgroundColor3 = Color3.fromHex("238636")
                sendNotification("Replay Complete", "All replays finished.")
                return
            end
            
            for i, action in ipairs(macroData.actions) do
                if not isReplaying then break end
                
                if action.type == "Tap" then
                    local pixelPos = adjustForScreen(action.normPos)
                    VirtualUser:Button2Down(pixelPos.X, pixelPos.Y)
                    VirtualUser:Button2Up(pixelPos.X, pixelPos.Y)
                elseif action.type == "Swipe" then
                    local startPos = adjustForScreen(action.startNorm)
                    local endPos = adjustForScreen(action.endNorm)
                    
                    -- Simulate drag: press at start, wait for duration, release at end
                    VirtualUser:Button2Down(startPos.X, startPos.Y)
                    task.wait(action.duration)
                    VirtualUser:Button2Up(endPos.X, endPos.Y)
                end
                
                task.wait(action.interval)
            end
            
            task.wait(clickInterval) 
            
            if isReplaying then executeReplay() end
        end

        executeReplay()
    end)
end

-- 3. Settings Tab
local function setupSettingsTab()
    local settingsContent = Instance.new("Frame", tabContent)
    settingsContent.Size = UDim2.new(1, 0, 1, 0)
    settingsContent.BackgroundTransparency = 1
    local listLayout = Instance.new("UIListLayout", settingsContent)
    listLayout.FillDirection = Enum.FillDirection.Vertical
    listLayout.Padding = UDim.new(0, 10)

    -- Macro Management Section
    local lblMacroNameDesc = Instance.new("TextLabel", settingsContent)
    lblMacroNameDesc.Text = "Macro Name (for Save/Load):"
    lblMacroNameDesc.BackgroundTransparency = 1
    lblMacroNameDesc.TextColor3 = Color3.fromHex("c9d1d9")
    lblMacroNameDesc.TextSize = 14

    local nameInput = createInput(macroData.name, 170, settingsContent)
    nameInput.FocusLost:Connect(function(enterPressed)
        if enterPressed then macroData.name = nameInput.Text end
    end)

    local saveBtn = createButton("Save Macro", 170, settingsContent)
    saveBtn.BackgroundColor3 = Color3.fromHex("58a6ff")
    saveBtn.MouseButton1Click:Connect(saveMacro)
    
    local loadBtn = createButton("Load Macro", 170, settingsContent)
    loadBtn.BackgroundColor3 = Color3.fromHex("58a6ff")
    loadBtn.MouseButton1Click:Connect(function() loadMacro(nameInput.Text) end)

    -- Calibration Section
    local lblCalib = Instance.new("TextLabel", settingsContent)
    lblCalib.Text = "Resolution: " .. macroData.recordedResolution.X .. "x" .. macroData.recordedResolution.Y
    lblCalib.BackgroundTransparency = 1
    lblCalib.TextColor3 = Color3.fromHex("e3b341")
    lblCalib.TextSize = 16

    local btnCalibrate = createButton("Calibrate Screen (Fix Replay)", 170, settingsContent)
    btnCalibrate.BackgroundColor3 = Color3.fromHex("238636")
    btnCalibrate.MouseButton1Click:Connect(function()
        if not isRecording and not isReplaying then
            calibrateScreen(lblCalib)
        else
            sendNotification("Error", "Stop recording/replaying to calibrate.")
        end
    end)

    -- Other Settings (Placeholder)
    local lblNotes = Instance.new("TextLabel", settingsContent)
    lblNotes.Text = "Macro Editing and Advanced Swipe settings will be added next."
    lblNotes.Size = UDim2.new(1, 0, 0, 40)
    lblNotes.TextWrapped = true
    lblNotes.TextSize = 12
    lblNotes.TextColor3 = Color3.fromHex("c9d1d9") 
end

-- Screen Calibration System
local calibrationFrame
local calibrationText
local calibrationCorners = {}
local currentCorner = 1
local cornerPrompts = {"Top-Left", "Top-Right", "Bottom-Left", "Bottom-Right"}
local calibrationInputConnection

local function updateCalibrationPrompt(prompt)
    if calibrationText then calibrationText.Text = "Click " .. prompt .. " Corner" end
end

local function finalizeCalibration(corners)
    -- 3. MINOR FIX: Calculate width using corners 1 and 2, and height using 1 and 3.
    local effectiveWidth = math.abs(corners[2].X - corners[1].X)
    local effectiveHeight = math.abs(corners[3].Y - corners[1].Y)
    
    -- Set the new recorded resolution (This fixes the misalignment)
    macroData.recordedResolution = Vector2.new(effectiveWidth, effectiveHeight)
    
    isCalibrating = false
    calibrationInputConnection:Disconnect()
    
    -- Cleanup UI
    local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    TweenService:Create(calibrationFrame, tweenInfo, {BackgroundTransparency = 1, TextTransparency = 1}):Play()
    task.delay(0.3, function() calibrationFrame:Destroy() end)

    sendNotification("Calibration Complete", string.format("Screen Calibrated! Resolution set to %dx%d.", effectiveWidth, effectiveHeight))
end

local function calibrateScreen(lblCalib)
    isCalibrating = true
    sendNotification("Calibration", "Starting 4-Corner Calibration. Click the corners as prompted.")
    
    -- Setup Calibration UI (simple overlay)
    calibrationFrame = createFrame(UDim2.new(1, 0, 1, 0), UDim2.new(0.5, 0, 0.5, 0), CoreGui)
    calibrationFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    calibrationFrame.BackgroundTransparency = 0.5
    calibrationFrame.ZIndex = 100
    addUICorner(calibrationFrame, 0)
    
    calibrationText = Instance.new("TextLabel", calibrationFrame)
    calibrationText.Size = UDim2.new(1, 0, 0, 50)
    calibrationText.Position = UDim2.new(0.5, 0, 0.5, 0)
    calibrationText.AnchorPoint = Vector2.new(0.5, 0.5)
    calibrationText.TextScaled = true
    calibrationText.TextColor3 = Color3.fromHex("c9d1d9")
    calibrationText.BackgroundTransparency = 1
    
    currentCorner = 1
    updateCalibrationPrompt(cornerPrompts[currentCorner])
    
    -- Input capture
    calibrationInputConnection = UserInputService.InputBegan:Connect(function(input)
        if isCalibrating and (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then
            if currentCorner <= 4 then
                local pos = UserInputService:GetMouseLocation()
                calibrationCorners[currentCorner] = pos
                
                -- Visual feedback dot
                local dot = Instance.new("Frame", calibrationFrame)
                dot.Size = UDim2.new(0, 10, 0, 10)
                dot.Position = UDim2.new(0, pos.X, 0, pos.Y)
                dot.AnchorPoint = Vector2.new(0.5, 0.5)
                dot.BackgroundColor3 = Color3.fromHex("238636")
                addUICorner(dot, 10)

                currentCorner = currentCorner + 1
                
                if currentCorner <= 4 then
                    updateCalibrationPrompt(cornerPrompts[currentCorner])
                else
                    finalizeCalibration(calibrationCorners)
                    lblCalib.Text = "Resolution: " .. macroData.recordedResolution.X .. "x" .. macroData.recordedResolution.Y
                end
            end
        end
    end)
end

-- Initialize the GUI on the "Record" tab
task.wait(0.1) 
if tabButtons["Record"] then
    tabButtons["Record"].MouseButton1Click:Fire()
end
    