-- Roblox Macro V2 (MOBILE-FULLY CENTERED | NO KEY | TAP/SWIPE WORKS)
-- LocalScript in StarterPlayerScripts or StarterGui

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local StarterGui = game:GetService("StarterGui")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local workspace = workspace

-- Config
local MIN_CLICK_HOLD_DURATION = 0.05
local FONT_MAIN = Enum.Font.Gotham
local FONT_BOLD = Enum.Font.GothamBold
local SWIPE_MIN_PIXELS = 8
local SWIPE_SAMPLE_FPS = 60
local SWIPE_CURVATURE_DEFAULT = 0.0
local SWIPE_EASING = "easeInOutQuad"

-- Limits
local MIN_CLICK_INTERVAL = 0.01
local MAX_CLICK_INTERVAL = 10.0
local MIN_REPLAY_COUNT = 1
local MAX_REPLAY_COUNT = 10000

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- State
local autoClickEnabled = false
local clickInterval = 0.2
local clickPosition = Vector2.new(300, 300)
local waitingForPosition = false

local isRecording = false
local recordedActions = {}
local recordStartTime = 0

local isReplaying = false
local replayCount = 1
local currentReplayThread = nil

local isReplayingLoop = false
local currentReplayLoopThread = nil

local activeXOffsetRaw = { mode = "px", value = 0 }
local activeYOffsetRaw = { mode = "px", value = 0 }

local guiHidden = false

-- task shim
if type(task) ~= "table" or type(task.spawn) ~= "function" then
    task = {
        spawn = function(func)
            local co = coroutine.create(func)
            coroutine.resume(co)
            return co
        end,
        wait = function(time)
            local start = tick()
            while tick() - start < (time or 0) do
                RunService.Heartbeat:Wait()
            end
        end,
        delay = function(time, func)
            task.spawn(function()
                task.wait(time)
                func()
            end)
        end,
        cancel = function(co)
            -- no-op
        end
    }
end

-- UI Creation (CENTERED ON ALL DEVICES)
local mainGui = Instance.new("ScreenGui")
mainGui.Name = "MacroV2GUI"
mainGui.IgnoreGuiInset = true
mainGui.ResetOnSpawn = false
mainGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
mainGui.Parent = playerGui

-- Main Frame - Always Centered
local mainFrame = Instance.new("Frame", mainGui)
mainFrame.Size = UDim2.new(0, 300, 0, 420)
mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
mainFrame.BorderSizePixel = 0
mainFrame.ClipsDescendants = true
mainFrame.Visible = true
local frameCorner = Instance.new("UICorner", mainFrame)
frameCorner.CornerRadius = UDim.new(0, 12)

-- Drag Handle
local dragLayer = Instance.new("Frame", mainFrame)
dragLayer.Size = UDim2.new(1, 0, 0, 50)
dragLayer.BackgroundTransparency = 1
dragLayer.ZIndex = 1
dragLayer.Active = true

-- Title
local title = Instance.new("TextLabel", mainFrame)
title.Size = UDim2.new(1, 0, 0, 50)
title.BackgroundTransparency = 1
title.Text = "Macro V2"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.Font = FONT_BOLD
title.TextSize = 24
title.ZIndex = 2

-- Tab Bar
local tabBar = Instance.new("Frame", mainFrame)
tabBar.Size = UDim2.new(1, 0, 0, 45)
tabBar.Position = UDim2.new(0, 0, 0, 50)
tabBar.BackgroundColor3 = Color3.fromRGB(40, 40, 40)

local function createTab(text, xPos)
    local btn = Instance.new("TextButton", tabBar)
    btn.Size = UDim2.new(0, 90, 1, 0)
    btn.Position = UDim2.new(0, xPos, 0, 0)
    btn.Text = text
    btn.Font = FONT_MAIN
    btn.TextSize = 16
    btn.TextColor3 = Color3.new(1, 1, 1)
    btn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    local corner = Instance.new("UICorner", btn)
    corner.CornerRadius = UDim.new(0, 6)
    return btn
end

local tabAutoClicker = createTab("Auto", 10)
local tabRecorder = createTab("Record", 105)
local tabSettings = createTab("Settings", 200)

-- Content Area
local contentArea = Instance.new("Frame", mainFrame)
contentArea.Size = UDim2.new(1, 0, 1, -95)
contentArea.Position = UDim2.new(0, 0, 0, 95)
contentArea.BackgroundTransparency = 1

local autoContent = Instance.new("Frame", contentArea)
autoContent.Size = UDim2.new(1, 0, 1, 0)
autoContent.BackgroundTransparency = 1
autoContent.Visible = true

local recordContent = Instance.new("Frame", contentArea)
recordContent.Size = UDim2.new(1, 0, 1, 0)
recordContent.BackgroundTransparency = 1
recordContent.Visible = false

local settingsContent = Instance.new("Frame", contentArea)
settingsContent.Size = UDim2.new(1, 0, 1, 0)
settingsContent.BackgroundTransparency = 1
settingsContent.Visible = false

-- Button Factory
local function createButton(text, posY, parent, callback)
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0.9, 0, 0, 40)
    btn.Position = UDim2.new(0.05, 0, 0, posY)
    btn.Text = text
    btn.TextColor3 = Color3.fromRGB(255, 255, 255)
    btn.Font = FONT_MAIN
    btn.TextSize = 18
    btn.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    btn.BorderSizePixel = 0
    btn.ZIndex = 3
    btn.Parent = parent
    local corner = Instance.new("UICorner", btn)
    corner.CornerRadius = UDim.new(0, 8)
    if callback then btn.MouseButton1Click:Connect(callback) end
    return btn
end

-- Auto Tab
local btnAutoClicker = createButton("Auto Clicker: OFF", 10, autoContent)
local btnSetPosition = createButton("Set Position", 60, autoContent)
local lblInterval = Instance.new("TextBox", autoContent)
lblInterval.Size = UDim2.new(0.9, 0, 0, 40)
lblInterval.Position = UDim2.new(0.05, 0, 0, 110)
lblInterval.PlaceholderText = "Interval (sec)"
lblInterval.Text = "0.2"
lblInterval.Font = FONT_MAIN
lblInterval.TextSize = 18
lblInterval.TextColor3 = Color3.fromRGB(255, 255, 255)
lblInterval.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
lblInterval.BorderSizePixel = 0
local lblIntervalCorner = Instance.new("UICorner", lblInterval)
lblIntervalCorner.CornerRadius = UDim.new(0, 8)

-- Record Tab
local btnStartRecording = createButton("Start Recording", 10, recordContent)
local btnReplayClicks = createButton("Replay Clicks", 60, recordContent)
local btnReplayLoop = createButton("Replay Loop: OFF", 110, recordContent)
local btnClearRecording = createButton("Clear Recording", 160, recordContent)
local btnExport = createButton("Export Recording", 210, recordContent)
local btnImport = createButton("Import Recording", 260, recordContent)

local replayCountInput = Instance.new("TextBox", recordContent)
replayCountInput.Size = UDim2.new(0.9, 0, 0, 40)
replayCountInput.Position = UDim2.new(0.05, 0, 0, 310)
replayCountInput.PlaceholderText = "Replay Count"
replayCountInput.Text = "1"
replayCountInput.Font = FONT_MAIN
replayCountInput.TextSize = 18
replayCountInput.TextColor3 = Color3.fromRGB(255, 255, 255)
replayCountInput.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
replayCountInput.BorderSizePixel = 0
local replayCorner = Instance.new("UICorner", replayCountInput)
replayCorner.CornerRadius = UDim.new(0, 8)

-- Action List
local actionListFrame = Instance.new("ScrollingFrame", recordContent)
actionListFrame.Size = UDim2.new(0.9, 0, 0, 120)
actionListFrame.Position = UDim2.new(0.05, 0, 0, 360)
actionListFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
actionListFrame.BorderSizePixel = 0
actionListFrame.ScrollBarThickness = 6
actionListFrame.ScrollBarImageColor3 = Color3.fromRGB(80, 80, 80)
actionListFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
local actionListCorner = Instance.new("UICorner", actionListFrame)
actionListCorner.CornerRadius = UDim.new(0, 6)

local actionListLayout = Instance.new("UIListLayout", actionListFrame)
actionListLayout.SortOrder = Enum.SortOrder.LayoutOrder
actionListLayout.Padding = UDim.new(0, 4)

local actionEntries = {}

-- Settings Tab
local offsetXInput = Instance.new("TextBox", settingsContent)
offsetXInput.Size = UDim2.new(0.9, 0, 0, 40)
offsetXInput.Position = UDim2.new(0.05, 0, 0, 10)
offsetXInput.PlaceholderText = "X Offset (px or %)"
offsetXInput.Text = "0"
offsetXInput.Font = FONT_MAIN
offsetXInput.TextSize = 18
offsetXInput.TextColor3 = Color3.fromRGB(255, 255, 255)
offsetXInput.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
offsetXInput.BorderSizePixel = 0
local offsetXCorner = Instance.new("UICorner", offsetXInput)
offsetXCorner.CornerRadius = UDim.new(0, 8)

local offsetYInput = Instance.new("TextBox", settingsContent)
offsetYInput.Size = UDim2.new(0.9, 0, 0, 40)
offsetYInput.Position = UDim2.new(0.05, 0, 0, 60)
offsetYInput.PlaceholderText = "Y Offset (px or %)"
offsetYInput.Text = "0"
offsetYInput.Font = FONT_MAIN
offsetYInput.TextSize = 18
offsetYInput.TextColor3 = Color3.fromRGB(255, 255, 255)
offsetYInput.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
offsetYInput.BorderSizePixel = 0
local offsetYCorner = Instance.new("UICorner", offsetYInput)
offsetYCorner.CornerRadius = UDim.new(0, 8)

local swipeCurveInput = Instance.new("TextBox", settingsContent)
swipeCurveInput.Size = UDim2.new(0.9, 0, 0, 40)
swipeCurveInput.Position = UDim2.new(0.05, 0, 0, 110)
swipeCurveInput.PlaceholderText = "Swipe Curve %"
swipeCurveInput.Text = "0"
swipeCurveInput.Font = FONT_MAIN
swipeCurveInput.TextSize = 18
swipeCurveInput.TextColor3 = Color3.fromRGB(255, 255, 255)
swipeCurveInput.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
swipeCurveInput.BorderSizePixel = 0
local swipeCorner = Instance.new("UICorner", swipeCurveInput)
swipeCorner.CornerRadius = UDim.new(0, 8)

local btnApplyOffsets = createButton("Apply Settings", 160, settingsContent)

-- Toggle Button (Top-Left Corner)
local toggleGuiBtn = Instance.new("TextButton", mainGui)
toggleGuiBtn.Size = UDim2.new(0, 80, 0, 40)
toggleGuiBtn.Position = UDim2.new(0, 10, 0, 10)
toggleGuiBtn.Text = "Hide"
toggleGuiBtn.Font = FONT_MAIN
toggleGuiBtn.TextSize = 18
toggleGuiBtn.BackgroundColor3 = Color3.fromRGB(0, 120, 255)
toggleGuiBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleGuiBtn.ZIndex = 1000
toggleGuiBtn.Visible = true
local toggleCorner = Instance.new("UICorner", toggleGuiBtn)
toggleCorner.CornerRadius = UDim.new(0, 8)

-- Visualizer
local visualizer = Instance.new("ScreenGui")
visualizer.Name = "MacroVisualizer"
visualizer.IgnoreGuiInset = true
visualizer.ResetOnSpawn = false
visualizer.Enabled = false
visualizer.Parent = playerGui

local vizFrame = Instance.new("Frame", visualizer)
vizFrame.Size = UDim2.new(1, 0, 1, 0)
vizFrame.BackgroundTransparency = 1

-- Helpers
local function makeDraggable(guiObject, dragHandle)
    local dragging = false
    local dragStartMousePos
    local objectStartPos

    dragHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStartMousePos = UserInputService:GetMouseLocation()
            objectStartPos = guiObject.Position
        end
    end)

    dragHandle.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local currentMousePos = UserInputService:GetMouseLocation()
            local delta = currentMousePos - dragStartMousePos
            guiObject.Position = UDim2.new(
                objectStartPos.X.Scale, objectStartPos.X.Offset + delta.X,
                objectStartPos.Y.Scale, objectStartPos.Y.Offset + delta.Y
            )
        end
    end)

    dragHandle.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
        end
    end)
end

local function sendNotification(title, text)
    pcall(function()
        StarterGui:SetCore("SendNotification", {Title = title, Text = text, Duration = 3})
    end)
end

local function selectTab(tabName)
    autoContent.Visible = tabName == "auto"
    recordContent.Visible = tabName == "record"
    settingsContent.Visible = tabName == "settings"
    tabAutoClicker.BackgroundColor3 = tabName == "auto" and Color3.fromRGB(60, 60, 60) or Color3.fromRGB(50, 50, 50)
    tabRecorder.BackgroundColor3 = tabName == "record" and Color3.fromRGB(60, 60, 60) or Color3.fromRGB(50, 50, 50)
    tabSettings.BackgroundColor3 = tabName == "settings" and Color3.fromRGB(60, 60, 60) or Color3.fromRGB(50, 50, 50)
end

-- Viewport & Input
local function getViewportSize()
    local cam = workspace.CurrentCamera
    return cam and cam.ViewportSize or Vector2.new(1920, 1080)
end

local function toNormalized(pos)
    local vs = getViewportSize()
    return Vector2.new(pos.X / vs.X, pos.Y / vs.Y)
end

local function fromNormalized(norm)
    local vs = getViewportSize()
    return Vector2.new(math.clamp(norm.X * vs.X, 0, vs.X), math.clamp(norm.Y * vs.Y, 0, vs.Y))
end

-- Virtual Input
local function vmAvailable()
    return VirtualInputManager and typeof(VirtualInputManager.SendMouseButtonEvent) == "function"
end

local function safeSendMouseMove(x, y)
    if vmAvailable() then pcall(function() VirtualInputManager:SendMouseMoveEvent(x, y, game, 0) end) end
end

local function safeSendMouseButton(x, y, down)
    if vmAvailable() then pcall(function() VirtualInputManager:SendMouseButtonEvent(x, y, 0, down, game, 0) end) end
end

-- Simulate Click
local function simulateClick(norm)
    local pos = fromNormalized(norm)
    local xOffset = activeXOffsetRaw.mode == "px" and activeXOffsetRaw.value or activeXOffsetRaw.value * getViewportSize().X
    local yOffset = activeYOffsetRaw.mode == "px" and activeYOffsetRaw.value or activeYOffsetRaw.value * getViewportSize().Y
    local x, y = pos.X + xOffset, pos.Y + yOffset
    safeSendMouseMove(x, y)
    task.wait(0.02)
    safeSendMouseButton(x, y, true)
    task.wait(MIN_CLICK_HOLD_DURATION)
    safeSendMouseButton(x, y, false)
end

-- Recording
local activeInputs = {}
local recordConnections = {}

local function isOverGUI(pos)
    local objs = playerGui:GetGuiObjectsAtPosition(pos.X, pos.Y)
    for _, obj in ipairs(objs) do
        if obj:IsDescendantOf(mainGui) then return true end
    end
    return false
end

local function startRecording()
    isRecording = true
    recordedActions = {}
    recordStartTime = os.clock()
    btnStartRecording.Text = "Stop Recording"
    visualizer.Enabled = true

    recordConnections.began = UserInputService.InputBegan:Connect(function(input)
        if not isRecording then return end
        local ut = input.UserInputType
        if ut ~= Enum.UserInputType.Touch and ut ~= Enum.UserInputType.MouseButton1 then return end
        local pos = input.Position
        if isOverGUI(pos) then return end
        activeInputs[input] = { startTime = os.clock(), startPos = pos }
    end)

    recordConnections.ended = UserInputService.InputEnded:Connect(function(input)
        if not isRecording or not activeInputs[input] then return end
        local data = activeInputs[input]
        local now = os.clock()
        local delay = now - recordStartTime
        recordStartTime = now
        local endPos = input.Position or data.startPos
        local moved = (endPos - data.startPos).Magnitude

        if moved >= SWIPE_MIN_PIXELS then
            table.insert(recordedActions, {
                type = "swipe",
                startNorm = toNormalized(data.startPos),
                endNorm = toNormalized(endPos),
                duration = now - data.startTime,
                delay = delay
            })
        else
            table.insert(recordedActions, {
                type = "tap",
                norm = toNormalized(data.startPos),
                delay = delay
            })
        end
        updateActionList()
        activeInputs[input] = nil
    end)
end

local function stopRecording()
    isRecording = false
    btnStartRecording.Text = "Start Recording"
    visualizer.Enabled = false
    for _, conn in pairs(recordConnections) do conn:Disconnect() end
    recordConnections = {}
end

btnStartRecording.MouseButton1Click:Connect(function()
    if isRecording then stopRecording() else startRecording() end
end)

-- Action List Update
local function updateActionList()
    for _, entry in ipairs(actionEntries) do entry.frame:Destroy() end
    actionEntries = {}
    for i, act in ipairs(recordedActions) do
        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(1, -10, 0, 30)
        frame.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
        frame.LayoutOrder = i
        frame.Parent = actionListFrame
        local corner = Instance.new("UICorner", frame)
        corner.CornerRadius = UDim.new(0, 4)

        local label = Instance.new("TextLabel", frame)
        label.Size = UDim2.new(1, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.TextColor3 = Color3.fromRGB(220, 220, 220)
        label.Font = FONT_MAIN
        label.TextSize = 14
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Text = act.type == "tap" and string.format("Tap (%.0f, %.0f)", fromNormalized(act.norm).X, fromNormalized(act.norm).Y)
            or string.format("Swipe in %.2fs", act.duration)
        table.insert(actionEntries, { frame = frame })
    end
    actionListFrame.CanvasSize = UDim2.new(0, 0, 0, actionListLayout.AbsoluteContentSize.Y + 10)
end

-- Export/Import
btnExport.MouseButton1Click:Connect(function()
    if #recordedActions == 0 then sendNotification("Empty", "No actions to export"); return end
    local data = HttpService:JSONEncode({ actions = recordedActions })
    if setclipboard then setclipboard(data); sendNotification("Copied", "JSON copied to clipboard") end
end)

btnImport.MouseButton1Click:Connect(function()
    local box = Instance.new("TextBox")
    box.Size = UDim2.new(0.9, 0, 0, 100)
    box.Position = UDim2.new(0.05, 0, 0, 310)
    box.MultiLine = true
    box.PlaceholderText = "Paste JSON here..."
    box.Parent = recordContent
    local confirm = createButton("Import", 420, recordContent, function()
        local ok, res = pcall(HttpService.JSONDecode, HttpService, box.Text)
        if ok and res.actions then
            recordedActions = res.actions
            updateActionList()
            box:Destroy()
            confirm:Destroy()
            sendNotification("Imported", #recordedActions.." actions loaded")
        else
            sendNotification("Error", "Invalid JSON")
        end
    end)
end)

-- Tab Switching
tabAutoClicker.MouseButton1Click:Connect(function() selectTab("auto") end)
tabRecorder.MouseButton1Click:Connect(function() selectTab("record") end)
tabSettings.MouseButton1Click:Connect(function() selectTab("settings") end)

-- Final Setup
makeDraggable(mainFrame, dragLayer)
toggleGuiBtn.MouseButton1Click:Connect(function()
    guiHidden = not guiHidden
    mainFrame.Visible = not guiHidden
    toggleGuiBtn.Text = guiHidden and "Show" or "Hide"
end)

-- Auto Clicker
btnAutoClicker.MouseButton1Click:Connect(function()
    autoClickEnabled = not autoClickEnabled
    btnAutoClicker.Text = autoClickEnabled and "Auto Clicker: ON" or "Auto Clicker: OFF"
    if autoClickEnabled then
        task.spawn(function()
            while autoClickEnabled do
                simulateClick(toNormalized(clickPosition))
                task.wait(clickInterval)
            end
        end)
    end
end)

-- Set Position
btnSetPosition.MouseButton1Click:Connect(function()
    if waitingForPosition then return end
    waitingForPosition = true
    btnSetPosition.Text = "Tap Screen..."
    local conn = UserInputService.InputBegan:Connect(function(input)
        if not waitingForPosition then return end
        local pos = input.Position
        if isOverGUI(pos) then return end
        clickPosition = pos
        waitingForPosition = false
        btnSetPosition.Text = "Position Set!"
        conn:Disconnect()
        task.delay(1, function() if btnSetPosition.Text == "Position Set!" then btnSetPosition.Text = "Set Position" end end)
    end)
end)

-- Replay
btnReplayClicks.MouseButton1Click:Connect(function()
    if isReplaying then
        isReplaying = false
        btnReplayClicks.Text = "Replay Clicks"
        if currentReplayThread then task.cancel(currentReplayThread) end
        return
    end
    if #recordedActions == 0 then sendNotification("No Actions", "Record first"); return end
    isReplaying = true
    local count = tonumber(replayCountInput.Text) or 1
    btnReplayClicks.Text = "Stop Replay"
    currentReplayThread = task.spawn(function()
        for i = 1, count do
            if not isReplaying then break end
            for _, act in ipairs(recordedActions) do
                if not isReplaying then break end
                if act.delay then task.wait(act.delay) end
                if act.type == "tap" then
                    simulateClick(act.norm)
                elseif act.type == "swipe" then
                    -- Simplified swipe replay
                    task.wait(act.duration or 0.2)
                end
            end
        end
        isReplaying = false
        btnReplayClicks.Text = "Replay Clicks"
    end)
end)

-- Loop Replay
btnReplayLoop.MouseButton1Click:Connect(function()
    isReplayingLoop = not isReplayingLoop
    btnReplayLoop.Text = isReplayingLoop and "Replay Loop: ON" or "Replay Loop: OFF"
    if isReplayingLoop then
        currentReplayLoopThread = task.spawn(function()
            while isReplayingLoop do
                for _, act in ipairs(recordedActions) do
                    if not isReplayingLoop then break end
                    if act.delay then task.wait(act.delay) end
                    if act.type == "tap" then simulateClick(act.norm) end
                end
                task.wait(0.1)
            end
        end)
    else
        if currentReplayLoopThread then task.cancel(currentReplayLoopThread) end
    end
end)

-- Clear
btnClearRecording.MouseButton1Click:Connect(function()
    recordedActions = {}
    updateActionList()
    sendNotification("Cleared", "Recording reset")
end)

-- Apply Offsets
btnApplyOffsets.MouseButton1Click:Connect(function()
    local function parse(text)
        text = text:gsub("%%", ""):gsub("%s+", "")
        if text:find("%%$") then
            return { mode = "pct", value = tonumber(text:sub(1, -2)) / 100 }
        else
            return { mode = "px", value = tonumber(text) }
        end
    end
    local x = parse(offsetXInput.Text)
    local y = parse(offsetYInput.Text)
    if x and y then
        activeXOffsetRaw = x
        activeYOffsetRaw = y
        sendNotification("Applied", "Offsets updated")
    else
        sendNotification("Error", "Invalid format")
    end
end)

-- Start
selectTab("auto")
sendNotification("Macro V2", "GUI centered on all devices!")
            