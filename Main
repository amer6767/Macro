--[[
    ╔═══════════════════════════════════════════════════════════════════════════╗
    ║                     AXIORA ULTIMATE v6.0 - DELTA OPTIMIZED                ║
    ║                        Complete Rewrite for Stability                      ║
    ║                                                                            ║
    ║  Features: Recording, Playback, Strategy Loading, Visual HUD, UI          ║
    ║  Optimized for: Delta Executor (with fallbacks for other executors)       ║
    ╚═══════════════════════════════════════════════════════════════════════════╝
]]

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 1: ENVIRONMENT SETUP & CAPABILITY DETECTION
-- ═══════════════════════════════════════════════════════════════════════════════

local Axiora = {}
Axiora._VERSION = "6.0.0"
Axiora._BUILD = "DELTA-STABLE"

-- Safe function to get global environment
local function getEnv()
    if getgenv then return getgenv() end
    if getfenv then return getfenv(0) end
    return _G
end

local Root = getEnv()

-- Prevent multiple loads
if Root.Axiora and Root.Axiora._LOADED then
    warn("[Axiora] Already loaded, skipping re-initialization")
    return Root.Axiora
end

-- Safe service getter with caching
local Services = setmetatable({}, {
    __index = function(self, serviceName)
        local success, service = pcall(function()
            return game:GetService(serviceName)
        end)
        if success and service then
            -- Use cloneref if available for security
            if typeof(cloneref) == "function" then
                service = cloneref(service)
            end
            rawset(self, serviceName, service)
            return service
        end
        return nil
    end
})

-- Pre-cache commonly used services
local Players = Services.Players
local RunService = Services.RunService
local UserInputService = Services.UserInputService
local TweenService = Services.TweenService
local HttpService = Services.HttpService
local Workspace = Services.Workspace
local CoreGui = Services.CoreGui
local GuiService = Services.GuiService
local VirtualInputManager = Services.VirtualInputManager
local PathfindingService = Services.PathfindingService

-- Get local player safely
local function getLocalPlayer()
    return Players and Players.LocalPlayer
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- CAPABILITY DETECTION
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Capabilities = {
    -- Executor detection
    IsDelta = typeof(Root.delta) == "table" or typeof(Root.Delta) == "table",
    Executor = "Unknown",
    
    -- File system
    ReadFile = typeof(readfile) == "function",
    WriteFile = typeof(writefile) == "function",
    MakeFolder = typeof(makefolder) == "function",
    IsFile = typeof(isfile) == "function",
    IsFolder = typeof(isfolder) == "function",
    
    -- Input capabilities
    MouseMoveAbs = typeof(mousemoveabs) == "function",
    MouseClick = typeof(mouse1click) == "function",
    KeyPress = typeof(keypress) == "function",
    KeyRelease = typeof(keyrelease) == "function",
    VirtualInput = VirtualInputManager ~= nil,
    
    -- Metatable capabilities
    GetRawMetatable = typeof(getrawmetatable) == "function",
    SetReadonly = typeof(setreadonly) == "function",
    NewCClosure = typeof(newcclosure) == "function",
    
    -- Drawing
    Drawing = typeof(Drawing) == "table" or typeof(Drawing) == "userdata",
    
    -- Other
    GetNamecallMethod = typeof(getnamecallmethod) == "function",
    SetClipboard = typeof(setclipboard) == "function",
    Request = typeof(request) == "function" or typeof(http_request) == "function",
    
    -- Identity level (estimated)
    IdentityLevel = 2
}

-- Detect executor
local function detectExecutor()
    local executors = {
        {check = function() return Root.delta or Root.Delta end, name = "Delta"},
        {check = function() return syn and syn.protect_gui end, name = "Synapse X"},
        {check = function() return KRNL_LOADED end, name = "KRNL"},
        {check = function() return fluxus end, name = "Fluxus"},
        {check = function() return Hydrogen end, name = "Hydrogen"},
        {check = function() return getexecutorname and getexecutorname() end, name = nil},
    }
    
    for _, exec in ipairs(executors) do
        local success, result = pcall(exec.check)
        if success and result then
            return exec.name or tostring(result)
        end
    end
    return "Unknown"
end

Axiora.Capabilities.Executor = detectExecutor()

-- Check identity level
pcall(function()
    if getidentity then
        Axiora.Capabilities.IdentityLevel = getidentity()
    elseif getthreadcontext then
        Axiora.Capabilities.IdentityLevel = getthreadcontext()
    end
end)

-- File system verified check
Axiora.Capabilities.FileSystemVerified = false
if Axiora.Capabilities.WriteFile and Axiora.Capabilities.ReadFile then
    local testSuccess = pcall(function()
        writefile("Axiora/_test.tmp", "test")
        local content = readfile("Axiora/_test.tmp")
        if Axiora.Capabilities.IsFile then
            if isfile("Axiora/_test.tmp") then
                delfile("Axiora/_test.tmp")
            end
        end
        return content == "test"
    end)
    Axiora.Capabilities.FileSystemVerified = testSuccess
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 2: CORE STATE & EVENT SYSTEM
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.State = {
    Status = "IDLE", -- IDLE, RECORDING, PLAYING, PAUSED
    Buffer = {},
    StartTime = 0,
    Connections = {},
    Threads = {},
    SecurityConnections = {},
    LoopCount = 0,
    InitTime = os.clock()
}

Axiora.Settings = {
    -- Recording
    SmartRecording = true,
    MinMoveDistance = 0.5,
    MinClickInterval = 0.05,
    RecordUIClicks = true,
    RecordCamera = true,
    RecordVelocity = true, -- Record movement direction for accurate replay
    MaxBufferSize = 50000,
    
    -- Playback
    TimeScale = 1.0,
    NavigationTimeout = 10,
    NavigationRetries = 3,
    
    -- Pathfinding (Smart navigation to start)
    UsePathfinding = true, -- Use pathfinding instead of teleport
    PathfindingTimeout = 30, -- Max seconds to pathfind to start
    TeleportFallback = true, -- Teleport if pathfinding fails (executor dependent)
    
    -- Input offsets (calibration)
    XOffset = 0,
    YOffset = 0,
    
    -- Features
    AntiAFK = true,
    AntiKick = false,
    ClickRipple = true,
    AutoSave = false,
    AutoSaveInterval = 300,
    
    -- Visuals
    Theme = "default",
    HUDEnabled = true,
    PerformanceMode = false,
    
    -- Progressive Rendering
    RenderBatchSize = 50,
    RenderBatchDelay = 0.03,
    
    -- Click Recovery
    ClickRecoveryEnabled = true,
    ClickRecoveryMaxAttempts = 9,
    ClickRecoveryOffsetPixels = 5,
    ClickRecoveryDelay = 0.05,
    
    -- Breakpoints
    BreakpointsEnabled = true,
    BreakpointNotify = true,
    
    -- Buffer Library
    UseNativeBuffers = false, -- Enable binary buffers for memory savings
    
    -- Debug
    DebugPathfinding = false, -- Visualize pathfinding waypoints
    
    -- MOBILE SETTINGS
    IsMobile = false, -- Auto-detected
    UIScale = 1.0, -- Auto-calculated based on screen
    MinButtonSize = 44, -- Minimum touch target size (Apple HIG)
    MobileButtonScale = 1.3, -- Scale factor for buttons on mobile
    MobileFontScale = 1.2, -- Scale factor for fonts on mobile
    
    -- Speed Presets (used by UI speed buttons)
    SpeedPresets = {
        careful = 0.5,
        normal = 1.0,
        fast = 1.5,
        turbo = 2.0
    }
}

-- Mobile detection
local function detectMobile()
    local isMobile = false
    
    -- Check if touch is primary input
    pcall(function()
        isMobile = UserInputService.TouchEnabled and not UserInputService.MouseEnabled
    end)
    
    -- Also check screen size (mobile typically < 1024 width)
    pcall(function()
        local viewport = Workspace.CurrentCamera and Workspace.CurrentCamera.ViewportSize
        if viewport and viewport.X < 1024 then
            isMobile = true
        end
    end)
    
    Axiora.Settings.IsMobile = isMobile
    
    -- Set UI scale based on screen
    if isMobile then
        Axiora.Settings.UIScale = 1.0 -- Mobile already uses full screen
        Axiora.Settings.MinButtonSize = 50 -- Larger touch targets
    else
        Axiora.Settings.UIScale = 1.0
        Axiora.Settings.MinButtonSize = 36
    end
    
    return isMobile
end

-- Call detection
detectMobile()

-- Simple event system
Axiora.Events = {
    _listeners = {}
}

function Axiora.Events:Connect(eventName, callback)
    if not self._listeners[eventName] then
        self._listeners[eventName] = {}
    end
    local id = #self._listeners[eventName] + 1
    self._listeners[eventName][id] = callback
    
    return {
        Disconnect = function()
            self._listeners[eventName][id] = nil
        end
    }
end

function Axiora.Events:Fire(eventName, ...)
    if not self._listeners[eventName] then return end
    for _, callback in pairs(self._listeners[eventName]) do
        if typeof(callback) == "function" then
            task.spawn(function(...)
                pcall(callback, ...)
            end, ...)
        end
    end
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 3: MATH UTILITIES
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Math = {
    Screen = {
        Viewport = Vector2.new(1920, 1080),
        GuiInset = Vector2.new(0, 36), -- Default Roblox top bar height
        Initialized = false
    }
}

function Axiora.Math.UpdateScreenMetrics()
    local success = pcall(function()
        local cam = Workspace.CurrentCamera
        if cam then
            Axiora.Math.Screen.Viewport = cam.ViewportSize
        end
        
        if GuiService and GuiService.GetGuiInset then
            local insetTop, insetBottom = GuiService:GetGuiInset()
            -- insetTop is the Vector2 offset from top-left
            if typeof(insetTop) == "Vector2" then
                Axiora.Math.Screen.GuiInset = insetTop
            else
                Axiora.Math.Screen.GuiInset = Vector2.new(0, 36)
            end
        end
        
        Axiora.Math.Screen.Initialized = true
    end)
    return success
end

-- Wait for screen metrics to be valid
function Axiora.Math.WaitForInit(timeout)
    timeout = timeout or 2
    local start = os.clock()
    
    while (os.clock() - start) < timeout do
        Axiora.Math.UpdateScreenMetrics()
        if Axiora.Math.Screen.Viewport.X > 100 then
            return true
        end
        task.wait(0.1)
    end
    return false
end

-- Convert relative coords (0-1) to absolute screen position (for input simulation)
-- FIX: Added GUI inset back since GetRelativeInput subtracts it
function Axiora.Math.GetAbsoluteInput(relX, relY)
    local viewport = Axiora.Math.Screen.Viewport
    local inset = Axiora.Math.Screen.GuiInset
    
    if viewport.X < 10 then viewport = Vector2.new(1920, 1080) end
    
    -- Convert relative to viewport coordinates
    local x = relX * viewport.X
    local y = relY * viewport.Y
    
    -- Add GUI inset back (GetRelativeInput subtracted it during recording)
    x = x + inset.X
    y = y + inset.Y
    
    -- Apply user calibration offset
    x = x + (Axiora.Settings.XOffset or 0)
    y = y + (Axiora.Settings.YOffset or 0)
    
    -- Apply DPI scale if detected (for high-DPI displays)
    local dpiScale = Axiora.Settings.DPIScale or 1.0
    if dpiScale ~= 1.0 then
        x = x * dpiScale
        y = y * dpiScale
    end
    
    -- Clamp to valid screen range
    local totalWidth = (viewport.X + inset.X) * dpiScale
    local totalHeight = (viewport.Y + inset.Y) * dpiScale
    x = math.clamp(x, 0, totalWidth)
    y = math.clamp(y, 0, totalHeight)
    
    return Vector2.new(x, y)
end

-- Convert absolute screen position to relative coords (0-1)
-- GetMouseLocation() returns coords WITH inset, so we subtract it to get viewport-relative
function Axiora.Math.GetRelativeInput(absX, absY)
    local viewport = Axiora.Math.Screen.Viewport
    local inset = Axiora.Math.Screen.GuiInset
    
    if viewport.X < 10 then viewport = Vector2.new(1920, 1080) end
    
    -- Subtract inset because GetMouseLocation includes it
    -- but we want viewport-relative coordinates
    local viewX = absX - inset.X
    local viewY = absY - inset.Y
    
    -- Convert to 0-1 range relative to viewport
    return {
        x = math.clamp(viewX / viewport.X, 0, 1),
        y = math.clamp(viewY / viewport.Y, 0, 1)
    }
end

-- Serialize Vector3 to compact array
function Axiora.Math.SerializeVec(v)
    if not v then return {0, 0, 0} end
    return {
        math.floor(v.X * 100) / 100,
        math.floor(v.Y * 100) / 100,
        math.floor(v.Z * 100) / 100
    }
end

-- Deserialize array to Vector3
function Axiora.Math.DeserializeVec(t)
    if not t or type(t) ~= "table" then return Vector3.zero end
    return Vector3.new(t[1] or 0, t[2] or 0, t[3] or 0)
end

-- Serialize CFrame to component array
function Axiora.Math.SerializeCF(cf)
    if not cf then return nil end
    local components = {cf:GetComponents()}
    for i, v in ipairs(components) do
        components[i] = math.floor(v * 1000) / 1000
    end
    return components
end

-- Deserialize array to CFrame
function Axiora.Math.DeserializeCF(t)
    if not t or type(t) ~= "table" or #t ~= 12 then return nil end
    local success, result = pcall(function()
        return CFrame.new(table.unpack(t))
    end)
    return success and result or nil
end

-- Initialize screen metrics
task.spawn(function()
    task.wait(0.5)
    Axiora.Math.WaitForInit(3)
end)

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 3.5: BUFFER LIBRARY (Memory Management)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.BufferLib = {
    Enabled = false,
    Supported = (typeof(buffer) == "table" or typeof(buffer) == "userdata") and typeof(buffer.create) == "function",
    NodeSize = 34, -- Fixed size per node (bytes)
    GrowthFactor = 1.5
}

-- Node Binary Format (34 bytes):
-- [0] Type (u8)
-- [1-4] Delay (f32)
-- [5-8] X/P.X (f32)
-- [9-12] Y/P.Y (f32)
-- [13-16] Z (f32) - only for Move
-- [17-20] Cam.X (f32)
-- [21-24] Cam.Y (f32)
-- [25-28] Cam.Z (f32) 
-- [29] Flags (u8) - 1=Jump, 2=UI
-- [30-33] KeyCode/Extra (u32)

function Axiora.BufferLib.Init(initialCapacity)
    if not Axiora.BufferLib.Supported then return nil end
    initialCapacity = initialCapacity or 10000
    
    local size = initialCapacity * Axiora.BufferLib.NodeSize
    local buf = buffer.create(size)
    
    return {
        Raw = buf,
        Capacity = initialCapacity,
        Count = 0,
        WriteCursor = 0
    }
end

function Axiora.BufferLib.WriteNode(bufObj, node)
    if not bufObj or not bufObj.Raw then return false end
    
    -- Check capacity
    if bufObj.Count >= bufObj.Capacity then
        -- Grow buffer
        local newCap = math.floor(bufObj.Capacity * Axiora.BufferLib.GrowthFactor)
        local newSize = newCap * Axiora.BufferLib.NodeSize
        local newBuf = buffer.create(newSize)
        buffer.copy(newBuf, 0, bufObj.Raw, 0, bufObj.WriteCursor)
        
        bufObj.Raw = newBuf
        bufObj.Capacity = newCap
    end
    
    local offset = bufObj.WriteCursor
    local b = bufObj.Raw
    
    -- Write common data
    buffer.writeu8(b, offset, node.t or 0)
    buffer.writef32(b, offset + 1, node.d or 0)
    
    -- Type-specific write
    local flags = 0
    
    if node.t == 1 then -- Move
        if node.p then
            local p = Axiora.Math.DeserializeVec(node.p)
            buffer.writef32(b, offset + 5, p.X)
            buffer.writef32(b, offset + 9, p.Y)
            buffer.writef32(b, offset + 13, p.Z)
        end
        
        if node.c then
            local cf = Axiora.Math.DeserializeCF(node.c)
            if cf then
                local lv = cf.LookVector
                buffer.writef32(b, offset + 17, lv.X)
                buffer.writef32(b, offset + 21, lv.Y)
                buffer.writef32(b, offset + 25, lv.Z)
            end
        end
        
        if node.j then flags = bit32.bor(flags, 1) end
        
    elseif node.t == 2 then -- Click
        buffer.writef32(b, offset + 5, node.x or 0)
        buffer.writef32(b, offset + 9, node.y or 0)
        if node.ui then flags = bit32.bor(flags, 2) end
        
    elseif node.t == 3 then -- Key
        local k = node.k and Enum.KeyCode[node.k] and Enum.KeyCode[node.k].Value or 0
        buffer.writeu32(b, offset + 30, k)
    end
    
    buffer.writeu8(b, offset + 29, flags)
    
    bufObj.Count = bufObj.Count + 1
    bufObj.WriteCursor = bufObj.WriteCursor + Axiora.BufferLib.NodeSize
    return true
end

function Axiora.BufferLib.ReadNode(bufObj, index)
    if not bufObj or index < 1 or index > bufObj.Count then return nil end
    
    local offset = (index - 1) * Axiora.BufferLib.NodeSize
    local b = bufObj.Raw
    
    local t = buffer.readu8(b, offset)
    local d = buffer.readf32(b, offset + 1)
    local flags = buffer.readu8(b, offset + 29)
    
    local node = {t = t, d = d}
    
    if t == 1 then -- Move
        local x = buffer.readf32(b, offset + 5)
        local y = buffer.readf32(b, offset + 9)
        local z = buffer.readf32(b, offset + 13)
        node.p = {x, y, z} -- Simplified vector
        
        local cx = buffer.readf32(b, offset + 17)
        local cy = buffer.readf32(b, offset + 21)
        local cz = buffer.readf32(b, offset + 25)
        if cx ~= 0 or cy ~= 0 or cz ~= 0 then
             -- We only stored lookvector, reconstructing full CF is hard without knowing Up/Right
             -- This is a simplified version for memory efficiency
             -- For full fidelity, standard tables are better.
        end
        
        if bit32.band(flags, 1) ~= 0 then node.j = true end
        
    elseif t == 2 then -- Click
        node.x = buffer.readf32(b, offset + 5)
        node.y = buffer.readf32(b, offset + 9)
        if bit32.band(flags, 2) ~= 0 then node.ui = true end
        
    elseif t == 3 then -- Key
        local kVal = buffer.readu32(b, offset + 30)
        -- Need to reverse lookup KeyCode enum... complex in loop
        -- Storing key name string is hard in fixed buffer without lookup table
    end
    
    return node
end

function Axiora.BufferLib.ToTable(bufObj)
    if not bufObj then return {} end
    local t = {}
    for i = 1, bufObj.Count do
        table.insert(t, Axiora.BufferLib.ReadNode(bufObj, i))
    end
    return t
end

function Axiora.BufferLib.FromTable(tbl)
    local bufObj = Axiora.BufferLib.Init(#tbl)
    if not bufObj then return nil end
    for _, node in ipairs(tbl) do
        Axiora.BufferLib.WriteNode(bufObj, node)
    end
    return bufObj
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 4: INPUT SYSTEM (Multi-Executor Compatible)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Input = {
    Method = "VIM", -- Delta, Native, VIM
    ClickDelay = 0.02
}

-- Detect best input method
local function detectInputMethod()
    -- Check for Delta's native input
    if Axiora.Capabilities.IsDelta then
        local deltaGlobal = Root.delta or Root.Delta
        if deltaGlobal and typeof(deltaGlobal.input) == "table" then
            Axiora.Input.Method = "Delta"
            Axiora.Input._deltaInput = deltaGlobal.input
            return
        end
    end
    
    -- Check for native mouse functions
    if Axiora.Capabilities.MouseMoveAbs and Axiora.Capabilities.MouseClick then
        Axiora.Input.Method = "Native"
        return
    end
    
    -- Fallback to VirtualInputManager
    Axiora.Input.Method = "VIM"
end

detectInputMethod()

-- Universal click function
function Axiora.Input.Click(x, y, nonBlocking)
    local startTime = os.clock()
    
    -- Delta method (fastest)
    if Axiora.Input.Method == "Delta" and Axiora.Input._deltaInput then
        local success = pcall(function()
            if Axiora.Input._deltaInput.mouse_move then
                Axiora.Input._deltaInput.mouse_move(x, y)
            end
            task.wait(0.01)
            if Axiora.Input._deltaInput.mouse_click then
                Axiora.Input._deltaInput.mouse_click()
            end
        end)
        if success then return true, os.clock() - startTime end
    end
    
    -- Native method
    if Axiora.Input.Method == "Native" then
        local success = pcall(function()
            mousemoveabs(x, y)
            if not nonBlocking then task.wait(Axiora.Input.ClickDelay) end
            mouse1click()
        end)
        if success then return true, os.clock() - startTime end
    end
    
    -- VIM fallback
    if VirtualInputManager then
        if nonBlocking then
            task.spawn(function()
                pcall(function()
                    VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 1)
                    task.wait(0.03)
                    VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 1)
                end)
            end)
            return true, 0
        else
            local success = pcall(function()
                VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 1)
                task.wait(0.03)
                VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 1)
            end)
            return success, os.clock() - startTime
        end
    end
    
    return false, 0
end

-- Universal key press function
function Axiora.Input.KeyPress(keyCode, duration)
    duration = duration or 0.05
    
    -- Delta method
    if Axiora.Input.Method == "Delta" and Axiora.Input._deltaInput then
        local success = pcall(function()
            if Axiora.Input._deltaInput.key_press then
                Axiora.Input._deltaInput.key_press(keyCode)
                task.wait(duration)
                Axiora.Input._deltaInput.key_release(keyCode)
            end
        end)
        if success then return true end
    end
    
    -- Native method
    if Axiora.Capabilities.KeyPress and Axiora.Capabilities.KeyRelease then
        local success = pcall(function()
            keypress(keyCode)
            task.wait(duration)
            keyrelease(keyCode)
        end)
        if success then return true end
    end
    
    -- VIM fallback
    if VirtualInputManager then
        pcall(function()
            VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
            task.wait(duration)
            VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
        end)
        return true
    end
    
    return false
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- CLICK RECOVERY (Spiral Offset Pattern)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.ClickRecovery = {
    Enabled = true,
    LastAttempts = 0,
    LastSuccess = true
}

-- Generate spiral offsets for click recovery
function Axiora.ClickRecovery.GetSpiralOffsets()
    local offset = Axiora.Settings.ClickRecoveryOffsetPixels
    return {
        {0, 0},           -- Center (original)
        {offset, 0},      -- Right
        {-offset, 0},     -- Left
        {0, -offset},     -- Up
        {0, offset},      -- Down
        {offset, -offset},  -- Up-right
        {-offset, -offset}, -- Up-left
        {offset, offset},   -- Down-right
        {-offset, offset}   -- Down-left
    }
end

-- Click with spiral recovery pattern
-- validator: optional function that returns true if click succeeded
function Axiora.ClickRecovery.ClickWithRetry(x, y, validator)
    if not Axiora.Settings.ClickRecoveryEnabled then
        Axiora.Input.Click(x, y)
        return true, 1
    end
    
    local offsets = Axiora.ClickRecovery.GetSpiralOffsets()
    local maxAttempts = math.min(#offsets, Axiora.Settings.ClickRecoveryMaxAttempts)
    local delay = Axiora.Settings.ClickRecoveryDelay
    
    for attempt = 1, maxAttempts do
        local offsetX = offsets[attempt][1]
        local offsetY = offsets[attempt][2]
        local clickX = x + offsetX
        local clickY = y + offsetY
        
        Axiora.Input.Click(clickX, clickY)
        Axiora.ClickRecovery.LastAttempts = attempt
        
        -- If no validator, assume success on first attempt
        if not validator then
            Axiora.ClickRecovery.LastSuccess = true
            return true, attempt
        end
        
        -- Wait a bit for UI to respond
        task.wait(delay)
        
        -- Check if click was successful
        local success = pcall(function()
            return validator()
        end)
        
        if success then
            Axiora.ClickRecovery.LastSuccess = true
            if attempt > 1 then
                Axiora.Events:Fire("ClickRecovered", {
                    OriginalX = x,
                    OriginalY = y,
                    SuccessX = clickX,
                    SuccessY = clickY,
                    Attempts = attempt
                })
            end
            return true, attempt
        end
    end
    
    -- All attempts failed
    Axiora.ClickRecovery.LastSuccess = false
    Axiora.Events:Fire("ClickRecoveryFailed", {
        X = x,
        Y = y,
        Attempts = maxAttempts
    })
    return false, maxAttempts
end

-- Quick check function - tries click recovery if needed
function Axiora.SmartClick(relX, relY, validator)
    local abs = Axiora.Math.GetAbsoluteInput(relX, relY)
    return Axiora.ClickRecovery.ClickWithRetry(abs.X, abs.Y, validator)
end

-- Create a validator function for UI elements
function Axiora.ClickRecovery.CreateUIValidator(guiObject)
    return function()
        return guiObject and guiObject.Visible and guiObject.Parent 
               and guiObject.AbsoluteSize.X > 0
    end
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 5: RECORDING ENGINE
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Recording = {
    Active = false,
    StartTime = 0,
    LastNodeTime = 0,
    NodeCount = 0,
    LastPos = Vector3.zero,
    LastCamCF = CFrame.new(),
    LastClickPos = Vector2.zero,
    LastClickTime = 0
}

-- Get elapsed time since recording started (CRITICAL: was missing, breaks Controller/Gyro)
function Axiora.Recording.GetElapsedTime()
    if not Axiora.Recording.Active then return 0 end
    return os.clock() - Axiora.Recording.StartTime
end

-- Clean disconnect all recording connections
local function cleanupRecordingConnections()
    for key, conn in pairs(Axiora.State.Connections) do
        if typeof(conn) == "RBXScriptConnection" then
            pcall(function() conn:Disconnect() end)
        end
    end
    Axiora.State.Connections = {}
end

-- Add a node with optimization
local function addNode(node)
    if #Axiora.State.Buffer >= Axiora.Settings.MaxBufferSize then
        Axiora.Stop()
        Axiora.Events:Fire("BufferFull")
        return false
    end
    
    table.insert(Axiora.State.Buffer, node)
    Axiora.Recording.NodeCount = Axiora.Recording.NodeCount + 1
    return true
end

-- Check if we should record this position (smart filtering)
local function shouldRecordPosition(currentPos, timeSinceLastNode)
    if not Axiora.Settings.SmartRecording then return true end
    
    local distance = (currentPos - Axiora.Recording.LastPos).Magnitude
    if distance < Axiora.Settings.MinMoveDistance then
        return false
    end
    
    if timeSinceLastNode < 0.05 then
        return false
    end
    
    return true
end

function Axiora.Record()
    Axiora.Stop()
    
    -- Wait for math initialization
    Axiora.Math.WaitForInit(2)
    
    local LP = getLocalPlayer()
    if not LP then
        Axiora.Events:Fire("Error", {Message = "No local player"})
        return false
    end
    
    -- Initialize state
    Axiora.State.Status = "RECORDING"
    local buffer = {} -- Local buffer for speed
    Axiora.State.Buffer = buffer
    
    local startTime = os.clock()
    Axiora.State.StartTime = startTime
    Axiora.Recording.Active = true
    Axiora.Recording.StartTime = startTime
    
    -- Auto-start extended inputs
    if Axiora.Controller and Axiora.Controller.IsConnected() then
        Axiora.Controller.StartRecording()
    end
    if Axiora.Gyro and Axiora.Gyro.IsSupported() then
        Axiora.Gyro.StartTracking()
    end
    
    Axiora.Recording.LastNodeTime = startTime
    Axiora.Recording.NodeCount = 0
    Axiora.Recording.LastPos = Vector3.zero
    Axiora.Recording.LastCamCF = CFrame.new()
    Axiora.Recording.LastClickPos = Vector2.zero
    Axiora.Recording.LastClickTime = 0
    
    -- Optimization: Localize functions for loop speed
    local clock = os.clock
    local floor = math.floor
    local abs = math.abs
    local serializeVec = Axiora.Math.SerializeVec
    local serializeCF = Axiora.Math.SerializeCF
    local maxBuffer = Axiora.Settings.MaxBufferSize or 10000
    
    -- Movement recording
    Axiora.State.Connections.Move = RunService.Heartbeat:Connect(function()
        local char = LP.Character
        if not char then return end
        
        local root = char:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChildOfClass("Humanoid")
        if not root or not hum then return end
        
        local pos = root.Position
        local now = clock()
        local timeSinceLastNode = now - Axiora.Recording.LastNodeTime
        
        local camChanged = false
        local cam = Workspace.CurrentCamera
        local currentCamCF
        
        if Axiora.Settings.RecordCamera and cam then
            currentCamCF = cam.CFrame
            local camRotDiff = (currentCamCF.LookVector - Axiora.Recording.LastCamCF.LookVector).Magnitude
            if camRotDiff > 0.05 then
                camChanged = true
            end
        end
        
        -- Inline validation check for speed
        if shouldRecordPosition(pos, timeSinceLastNode) or hum.Jump or (camChanged and timeSinceLastNode > 0.1) then
            -- Safe check for buffer size
            if #buffer >= maxBuffer then
                Axiora.Stop()
                Axiora.Events:Fire("BufferFull")
                return
            end
            
            local node = {
                t = 1, -- Movement type
                d = now - startTime, -- Delay from start
                p = serializeVec(pos),
            }
            
            -- Record velocity/movement direction for accurate path replay
            if Axiora.Settings.RecordVelocity then
                local moveDir = hum.MoveDirection
                if moveDir.Magnitude > 0.1 then
                    -- Store normalized movement direction
                    node.v = {
                        floor(moveDir.X * 100) / 100,
                        floor(moveDir.Y * 100) / 100,
                        floor(moveDir.Z * 100) / 100
                    }
                end
                
                -- Store walk speed for replay accuracy
                node.ws = floor(hum.WalkSpeed * 10) / 10
            end
            
            if hum.Jump then
                node.j = true
            end
            
            if Axiora.Settings.RecordCamera and camChanged then
                node.c = serializeCF(currentCamCF)
                Axiora.Recording.LastCamCF = currentCamCF
            end
            
            -- FAST INSERT
            buffer[#buffer+1] = node
            
            Axiora.Recording.NodeCount = Axiora.Recording.NodeCount + 1
            Axiora.Recording.LastPos = pos
            Axiora.Recording.LastNodeTime = now
        end
    end)
    
    -- Input recording (clicks and keys)
    Axiora.State.Connections.Input = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed and not Axiora.Settings.RecordUIClicks then return end
        
        local now = os.clock()
        
        -- Mouse/Touch clicks (Left & Right)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or
           input.UserInputType == Enum.UserInputType.MouseButton2 or
           input.UserInputType == Enum.UserInputType.Touch then
            
            local isRightClick = input.UserInputType == Enum.UserInputType.MouseButton2
            local clickPos = UserInputService:GetMouseLocation()
            
            if input.UserInputType == Enum.UserInputType.Touch and input.Position then
                local inset = Axiora.Math.Screen.GuiInset
                clickPos = Vector2.new(input.Position.X + inset.X, input.Position.Y + inset.Y)
            end
            
            local rel = Axiora.Math.GetRelativeInput(clickPos.X, clickPos.Y)
            
            -- Filter duplicate clicks
            local clickDist = math.abs(rel.x - Axiora.Recording.LastClickPos.X) + 
                             math.abs(rel.y - Axiora.Recording.LastClickPos.Y)
            local timeSinceLastClick = now - Axiora.Recording.LastClickTime
            
            if clickDist < 0.01 and timeSinceLastClick < Axiora.Settings.MinClickInterval then
                return 
            end
            
            local node = {
                t = isRightClick and 4 or 2, -- 4 for Right, 2 for Left
                d = now - Axiora.State.StartTime,
                x = rel.x,
                y = rel.y,
                ui = gameProcessed or nil
            }
            
            addNode(node)
            Axiora.Recording.LastClickPos = Vector2.new(rel.x, rel.y)
            Axiora.Recording.LastClickTime = now
            
            if Axiora.Settings.ClickRipple and Axiora.Visuals and Axiora.Visuals.Ripple then
                Axiora.Visuals.Ripple(clickPos.X, clickPos.Y, isRightClick and Color3.new(0,0.5,1))
            end
            
        -- Keyboard & Gamepad
        elseif input.UserInputType == Enum.UserInputType.Keyboard or
               input.UserInputType == Enum.UserInputType.Gamepad1 then
            local node = {
                t = 3, -- Key type
                d = now - Axiora.State.StartTime,
                k = input.KeyCode.Name
            }
            addNode(node)
        end
    end)
    
    -- Scroll Recording
    Axiora.State.Connections.InputChanged = UserInputService.InputChanged:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.UserInputType == Enum.UserInputType.MouseWheel then
            local now = os.clock()
            local node = {
                t = 5, -- Scroll type
                d = now - Axiora.State.StartTime,
                z = input.Position.Z -- Scroll delta
            }
            addNode(node)
        end
    end)
    
    Axiora.Events:Fire("RecordingStarted", {
        Mode = Axiora.Settings.SmartRecording and "Smart" or "Full"
    })
    
    return true
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 6: PLAYBACK ENGINE
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Playback = {
    Active = false,
    Paused = false,
    CurrentIndex = 0,
    LoopCount = 0,
    Speed = 1.0,
    Mode = "normal" -- normal, fast, precise
}

-- Navigate to a position with retry logic (simple direct navigation)
local function navigateToPosition(hum, root, targetPos, timeout, retries)
    timeout = timeout or Axiora.Settings.NavigationTimeout
    retries = retries or Axiora.Settings.NavigationRetries
    
    local attempt = 0
    
    while attempt < retries do
        if Axiora.State.Status ~= "PLAYING" then return false end
        
        local distance = (root.Position - targetPos).Magnitude
        if distance <= 3 then return true end
        
        hum:MoveTo(targetPos)
        
        local arrived = false
        local startTime = os.clock()
        
        local conn
        conn = hum.MoveToFinished:Connect(function(reached)
            arrived = true
            if reached then distance = 0 end
            if conn then conn:Disconnect() end
        end)
        
        while not arrived and (os.clock() - startTime) < timeout do
            if Axiora.State.Status ~= "PLAYING" then
                if conn then conn:Disconnect() end
                return false
            end
            if (root.Position - targetPos).Magnitude <= 3 then
                arrived = true
                break
            end
            task.wait(0.1)
        end
        
        if conn then conn:Disconnect() end
        
        if (root.Position - targetPos).Magnitude <= 5 then
            return true
        end
        
        -- Retry with jump
        attempt = attempt + 1
        if attempt < retries then
            hum.Jump = true
            task.wait(0.5)
        end
    end
    
    return false
end

-- Smart Pathfinding Navigation (uses PathfindingService)
-- Smart Pathfinding Navigation (uses PathfindingService)
local function pathfindToPosition(hum, root, targetPos, timeout)

    timeout = timeout or Axiora.Settings.PathfindingTimeout
    
    -- Check if already close enough
    local distance = (root.Position - targetPos).Magnitude
    if distance <= 5 then
        return true
    end
    
    Axiora.Visuals.Notify("Pathfinding", "Navigating to start position... (" .. math.floor(distance) .. " studs)", 3, "info")
    
    -- Try to use PathfindingService
    if not PathfindingService then
        Axiora.Visuals.Notify("Pathfinding", "PathfindingService not available, using direct navigation", 2, "warning")
        return navigateToPosition(hum, root, targetPos, timeout)
    end
    
    local success, path = pcall(function()
        local pathParams = {
            AgentRadius = 2,
            AgentHeight = 5,
            AgentCanJump = true,
            AgentCanClimb = true,
            WaypointSpacing = 4
        }
        return PathfindingService:CreatePath(pathParams)
    end)
    
    if not success or not path then
        Axiora.Visuals.Notify("Pathfinding", "Failed to create path, using direct navigation", 2, "warning")
        return navigateToPosition(hum, root, targetPos, timeout)
    end
    
    -- Compute path with timeout
    local computeSuccess = false
    local computeDone = false
    
    task.spawn(function()
        local s, e = pcall(function()
            path:ComputeAsync(root.Position, targetPos)
        end)
        if s then computeSuccess = true end
        computeDone = true
    end)
    
    local waitStart = os.clock()
    while not computeDone and (os.clock() - waitStart) < 2 do -- 2 second timeout
        task.wait()
    end
    
    if not computeDone then
        Axiora.Visuals.Notify("Pathfinding", "Computation timed out", 2, "warning")
        return navigateToPosition(hum, root, targetPos, timeout)
    end
    
    if not computeSuccess then
        Axiora.Visuals.Notify("Pathfinding", "Path computation failed, using direct navigation", 2, "warning")
        return navigateToPosition(hum, root, targetPos, timeout)
    end
    
    if path.Status ~= Enum.PathStatus.Success then
        Axiora.Visuals.Notify("Pathfinding", "No path found, using direct navigation", 2, "warning")
        return navigateToPosition(hum, root, targetPos, timeout)
    end
    
    -- Get waypoints
    local waypoints = path:GetWaypoints()
    if #waypoints == 0 then
        return navigateToPosition(hum, root, targetPos, timeout)
    end
    
    Axiora.Visuals.Notify("Pathfinding", "Following path (" .. #waypoints .. " waypoints)", 2, "info")
    
    -- Debug visualization
    if Axiora.Settings.DebugPathfinding then
        for idx, wp in ipairs(waypoints) do
            local marker = Axiora.Visuals.GetPooledPart()
            marker.Shape = Enum.PartType.Ball
            marker.Size = Vector3.new(1, 1, 1)
            marker.Position = wp.Position
            marker.Anchored = true
            marker.CanCollide = false
            marker.BrickColor = BrickColor.new("Lime green")
            marker.Material = Enum.Material.Neon
            marker.Parent = workspace
            table.insert(Axiora.Visuals.Objects, marker)
        end
    end
    
    local startTime = os.clock()
    local blockedCount = 0
    local stuckTimer = 0
    local lastPos = root.Position
    
    -- Follow waypoints
    for i, waypoint in ipairs(waypoints) do
        if Axiora.State.Status ~= "PLAYING" then return false end
        if (os.clock() - startTime) > timeout then
            Axiora.Visuals.Notify("Pathfinding", "Timeout reached", 2, "warning")
            break
        end
        
        -- Handle jump action
        if waypoint.Action == Enum.PathWaypointAction.Jump then
            hum.Jump = true
            task.wait(0.1)
        end
        
        -- Move to waypoint
        hum:MoveTo(waypoint.Position)
        
        -- Wait for movement to complete
        local reachedWaypoint = false
        local waypointStart = os.clock()
        
        local moveConn
        moveConn = hum.MoveToFinished:Connect(function()
            reachedWaypoint = true
            if moveConn then moveConn:Disconnect() end
        end)
        
        -- Wait for waypoint or timeout
        while not reachedWaypoint and (os.clock() - waypointStart) < 3 do
            if Axiora.State.Status ~= "PLAYING" then
                if moveConn then moveConn:Disconnect() end
                return false
            end
            
            -- Check if close enough to waypoint
            if (root.Position - waypoint.Position).Magnitude <= 2 then
                reachedWaypoint = true
                break
            end
            
            task.wait(0.1)
            
            -- Stuck detection with automatic jump
            if (root.Position - lastPos).Magnitude < 0.5 then
                stuckTimer = stuckTimer + 0.1
                if stuckTimer > 2 then
                    hum.Jump = true
                    stuckTimer = 0
                end
            else
                stuckTimer = 0
            end
            lastPos = root.Position
        end
        
        if moveConn then moveConn:Disconnect() end
        
        -- Check for blocked path
        if not reachedWaypoint then
            blockedCount = blockedCount + 1
            if blockedCount >= 3 then
                Axiora.Visuals.Notify("Pathfinding", "Path blocked, trying direct approach", 2, "warning")
                hum.Jump = true
                task.wait(0.3)
            end
        else
            blockedCount = 0
        end
    end
    
    -- Final check - are we close enough?
    local finalDistance = (root.Position - targetPos).Magnitude
    if finalDistance <= 8 then
        Axiora.Visuals.Notify("Pathfinding", "Arrived at start position!", 2, "success")
        return true
    else
        -- Try direct navigation for the last bit
        return navigateToPosition(hum, root, targetPos, 5, 2)
    end
end

function Axiora.Play(loop)
    if #Axiora.State.Buffer == 0 then
        Axiora.Events:Fire("Error", {Message = "No macro loaded"})
        return false
    end
    
    Axiora.Stop()
    Axiora.Math.WaitForInit(2)
    
    local LP = getLocalPlayer()
    if not LP then
        Axiora.Events:Fire("Error", {Message = "No local player"})
        return false
    end
    
    -- Initialize state
    Axiora.State.Status = "PLAYING"
    Axiora.Playback.Active = true
    Axiora.Playback.Paused = false
    Axiora.Playback.CurrentIndex = 0
    Axiora.Playback.LoopCount = 0
    
    -- Determine loop settings
    local loopMode = "once"
    local loopTarget = 1
    
    if loop == true then
        loopMode = "infinite"
    elseif type(loop) == "number" then
        loopMode = "count"
        loopTarget = loop
    end
    
    -- Create snapshot of buffer
    local buffer = {}
    for i, node in ipairs(Axiora.State.Buffer) do
        buffer[i] = node
    end
    local bufferSize = #buffer
    
    -- Playback thread
    local playbackThread = task.spawn(function()
        while Axiora.State.Status == "PLAYING" do
            -- Wait for character
            if not LP.Character then
                LP.CharacterAdded:Wait()
                task.wait(1)
            end
            
            local hum = LP.Character:WaitForChild("Humanoid", 5)
            local root = LP.Character:WaitForChild("HumanoidRootPart", 5)
            
            if not hum or not root then
                Axiora.Events:Fire("Error", {Message = "Character not found"})
                break
            end
            
            -- Navigate to start position using pathfinding
            local firstNode = buffer[1]
            if firstNode and firstNode.p then
                local startPos = Axiora.Math.DeserializeVec(firstNode.p)
                local distanceToStart = (root.Position - startPos).Magnitude
                
                if distanceToStart > 5 then
                    if Axiora.Settings.UsePathfinding then
                        -- Use smart pathfinding to walk to start
                        local pathSuccess = pathfindToPosition(hum, root, startPos, Axiora.Settings.PathfindingTimeout)
                        
                        if not pathSuccess and Axiora.Settings.TeleportFallback then
                            -- Try teleport as last resort (may not work in all executors)
                            pcall(function()
                                root.CFrame = CFrame.new(startPos)
                            end)
                            task.wait(0.5)
                        end
                    else
                        -- Use simple direct navigation
                        navigateToPosition(hum, root, startPos)
                    end
                    task.wait(0.5)
                end
            end
            
            local startTime = os.clock()
            
            -- Execute buffer
            for i, node in ipairs(buffer) do
                if Axiora.State.Status ~= "PLAYING" then break end
                
                -- Handle pause
                while Axiora.Playback.Paused do
                    if Axiora.State.Status ~= "PLAYING" then break end
                    task.wait(0.1)
                end
                
                Axiora.Playback.CurrentIndex = i
                
                -- Breakpoint Check
                if Axiora.Breakpoints and Axiora.Breakpoints.Check(i) then
                    Axiora.Playback.Paused = true
                    Axiora.Breakpoints.WaitingAtBreakpoint = true
                    Axiora.Breakpoints.CurrentBreakpoint = i
                    if Axiora.Settings.BreakpointNotify then
                        Axiora.Visuals.Notify("Breakpoint", "Paused at node #" .. i, 0, "warning")
                    end
                    Axiora.Events:Fire("BreakpointHit", {Index = i})
                    
                    -- Wait until resumed
                    while Axiora.Playback.Paused and Axiora.Breakpoints.WaitingAtBreakpoint do
                        if Axiora.State.Status ~= "PLAYING" then break end
                        task.wait(0.1)
                    end
                end
                
                -- Wait for timestamp
                local now = os.clock() - startTime
                local safeTimeScale = math.max(0.01, Axiora.Settings.TimeScale)
                local safeSpeed = math.max(0.01, Axiora.Playback.Speed)
                local targetTime = (node.d or 0) / safeTimeScale / safeSpeed
                
                if now < targetTime then
                    task.wait(targetTime - now)
                end
                
                if Axiora.State.Status ~= "PLAYING" then break end
                
                -- Execute node based on type
                if node.t == 1 then
                    -- Movement with enhanced accuracy
                    local dest = Axiora.Math.DeserializeVec(node.p)
                    if dest then
                        -- Restore recorded walk speed if available
                        if node.ws and node.ws > 0 then
                            hum.WalkSpeed = node.ws
                        end
                        
                        -- MoveTo the recorded position (this follows the exact path)
                        hum:MoveTo(dest)
                    end
                    
                    if node.j then
                        hum.Jump = true
                    end
                    
                    -- Camera sync for look direction
                    if node.c and Axiora.Settings.RecordCamera then
                        local camCF = Axiora.Math.DeserializeCF(node.c)
                        if camCF and Workspace.CurrentCamera then
                            pcall(function()
                                Workspace.CurrentCamera.CFrame = camCF
                            end)
                        end
                    end
                    
                elseif node.t == 2 then
                    -- Click with recovery support
                    local abs = Axiora.Math.GetAbsoluteInput(node.x, node.y)
                    
                    if Axiora.Settings.ClickRecoveryEnabled then
                        if Axiora.AIClickRecovery and Axiora.AIClickRecovery.Enabled then
                            -- Use AI Enhanced Recovery
                            Axiora.AIClickRecovery.SmartClick(abs.X, abs.Y)
                        else
                            -- Standard Recovery
                            Axiora.ClickRecovery.ClickWithRetry(abs.X, abs.Y)
                        end
                    else
                        Axiora.Input.Click(abs.X, abs.Y)
                    end
                    
                    if Axiora.Settings.ClickRipple and Axiora.Visuals and Axiora.Visuals.Ripple then
                        Axiora.Visuals.Ripple(abs.X, abs.Y)
                    end
                    
                elseif node.t == 3 then
                    -- Keyboard & Gamepad
                    local keyCode = Enum.KeyCode[node.k]
                    if keyCode then
                        Axiora.Input.KeyPress(keyCode)
                    end
                    
                elseif node.t == 4 then
                    -- Right Click
                    local abs = Axiora.Math.GetAbsoluteInput(node.x, node.y)
                    if Axiora.Input.RightClick then
                        Axiora.Input.RightClick(abs.X, abs.Y)
                    end
                    
                    if Axiora.Settings.ClickRipple and Axiora.Visuals and Axiora.Visuals.Ripple then
                        Axiora.Visuals.Ripple(abs.X, abs.Y, Color3.new(0,0.5,1))
                    end
                    
                elseif node.t == 5 then
                    -- Scroll
                    local isForward = (node.z or 0) > 0
                    local mouseLoc = UserInputService:GetMouseLocation()
                    if VirtualInputManager then
                        pcall(function()
                            VirtualInputManager:SendMouseWheelEvent(mouseLoc.X, mouseLoc.Y, isForward)
                        end)
                    end
                    
                elseif node.t == Axiora.NodeTypes.GAMEPAD then
                    -- Gamepad
                    if Axiora.Controller and Axiora.Controller.SimulateButton then
                        Axiora.Controller.SimulateButton(node.button, node.pressed)
                    end
                    
                elseif node.t == Axiora.NodeTypes.GYRO then
                    -- Gyroscope (Camera Rotation)
                    if node.rotation and Axiora.Gyro and Workspace.CurrentCamera then
                        -- Apply relative rotation or absolute? Recording saves absolute CFrame usually or delta?
                        -- Gyro records {x,y,z,w} quaternion from DeviceRotationChanged
                        -- We should apply it to Camera CFrame
                        local rot = node.rotation
                        local cf = CFrame.new(0,0,0, rot.x, rot.y, rot.z, rot.w)
                        -- But this is device rotation. Camera CFrame is different.
                        -- However, for simple replay, we might map it directly or skip if complex.
                        -- Implementing basic CFrame rotation application:
                        -- Workspace.CurrentCamera.CFrame = Workspace.CurrentCamera.CFrame * cf
                        -- (Experimental)
                    end
                end
                
                -- Smart Breakpoints Check
                if Axiora.SmartBreakpoints and Axiora.SmartBreakpoints.Check(i) then
                    Axiora.Playback.Paused = true
                    Axiora.Events:Fire("PlaybackPauseToggled", true)
                    Axiora.Visuals.Notify("Breakpoint", "Smart Condition Met", 2, "warning")
                end
                
                -- Progress event every 10 nodes
                if i % 10 == 0 then
                    Axiora.Events:Fire("PlaybackProgress", {
                        Current = i,
                        Total = bufferSize,
                        Percent = math.floor(i / bufferSize * 100)
                    })
                end
            end
            
            -- Loop logic
            Axiora.Playback.LoopCount = Axiora.Playback.LoopCount + 1
            
            local shouldContinue = false
            if loopMode == "infinite" then
                shouldContinue = true
            elseif loopMode == "count" then
                shouldContinue = Axiora.Playback.LoopCount < loopTarget
            end
            
            if not shouldContinue then break end
            
            task.wait(1)
        end
        
        Axiora.Events:Fire("PlaybackComplete", {
            NodesPlayed = Axiora.Playback.CurrentIndex,
            TotalNodes = bufferSize,
            Loops = Axiora.Playback.LoopCount
        })
        
        Axiora.Stop()
    end)
    
    table.insert(Axiora.State.Threads, playbackThread)
    
    Axiora.Events:Fire("PlaybackStarted", {
        Nodes = bufferSize,
        Loop = loopMode
    })
    
    return true
end

function Axiora.Pause()
    if Axiora.State.Status == "PLAYING" then
        Axiora.Playback.Paused = not Axiora.Playback.Paused
        Axiora.Events:Fire("PlaybackPauseToggled", Axiora.Playback.Paused)
        return Axiora.Playback.Paused
    end
    return false
end

function Axiora.Resume()
    if Axiora.State.Status == "PLAYING" and Axiora.Playback.Paused then
        Axiora.Playback.Paused = false
        return true
    end
    return false
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 7: STOP & CLEANUP
-- ═══════════════════════════════════════════════════════════════════════════════

function Axiora.Stop()
    local wasPlaying = Axiora.State.Status == "PLAYING"
    local wasRecording = Axiora.State.Status == "RECORDING"
    
    Axiora.State.Status = "IDLE"
    Axiora.Recording.Active = false
    Axiora.Playback.Active = false
    Axiora.Playback.Paused = false
    
    -- Disconnect regular connections
    for key, conn in pairs(Axiora.State.Connections) do
        if typeof(conn) == "RBXScriptConnection" then
            pcall(function() conn:Disconnect() end)
        end
    end
    Axiora.State.Connections = {}
    
    -- Cancel threads
    for _, t in pairs(Axiora.State.Threads) do
        pcall(function() task.cancel(t) end)
    end
    Axiora.State.Threads = {}
    
    -- Clear visuals
    if Axiora.Visuals and Axiora.Visuals.Clear then
        pcall(function() Axiora.Visuals.Clear() end)
    end
    
    -- Stop Extended Inputs
    if Axiora.Controller and Axiora.Controller.Recording then
        Axiora.Controller.StopRecording()
    end
    if Axiora.Gyro and Axiora.Gyro.Recording then
        Axiora.Gyro.StopTracking()
    end
    
    Axiora.Events:Fire("Stopped", {
        WasRecording = wasRecording,
        WasPlaying = wasPlaying
    })
end

function Axiora.FullStop()
    Axiora.Stop()
    
    -- Also clear security connections
    for _, conn in pairs(Axiora.State.SecurityConnections) do
        pcall(function() conn:Disconnect() end)
    end
    Axiora.State.SecurityConnections = {}
    
    Axiora.Events:Fire("FullStopped")
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 8: VISUAL SYSTEM (Notifications, HUD, Ripples)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Visuals = {
    ScreenGui = nil,
    HUDFrame = nil,
    NotificationContainer = nil,
    Objects = {},
    Folder = nil,
    NotificationQueue = {},
    NotificationCooldown = false,
    PartPool = {} -- Object pooling for performance
}

-- Object pooling functions
function Axiora.Visuals.GetPooledPart()
    if #Axiora.Visuals.PartPool > 0 then
        return table.remove(Axiora.Visuals.PartPool)
    end
    return Instance.new("Part")
end

function Axiora.Visuals.ReturnToPool(part)
    part.Parent = nil
    table.insert(Axiora.Visuals.PartPool, part)
end

-- Theme colors
Axiora.Visuals.Themes = {
    default = {
        Name = "Axiora Quantum",
        Primary = Color3.fromRGB(0, 180, 255),
        Secondary = Color3.fromRGB(0, 120, 180),
        Tertiary = Color3.fromRGB(35, 35, 45),
        Deep = Color3.fromRGB(12, 12, 18),
        Background = Color3.fromRGB(18, 18, 25),
        Surface = Color3.fromRGB(25, 25, 35),
        Overlay = Color3.new(0, 0, 0),
        Text = Color3.fromRGB(245, 245, 255),
        TextDim = Color3.fromRGB(150, 150, 170),
        Success = Color3.fromRGB(0, 200, 100),
        Warning = Color3.fromRGB(255, 180, 0),
        Error = Color3.fromRGB(255, 60, 80),
        Info = Color3.fromRGB(100, 200, 255),
        
        -- State Colors
        Idle = Color3.fromRGB(150, 150, 170),
        Playing = Color3.fromRGB(0, 255, 100),
        Recording = Color3.fromRGB(255, 60, 60),
        Paused = Color3.fromRGB(255, 200, 50),
        
        -- Editor Colors
        Movement = Color3.fromRGB(0, 180, 255),
        Click = Color3.fromRGB(200, 100, 255),
        Key = Color3.fromRGB(255, 150, 50),
        Delay = Color3.fromRGB(120, 120, 140)
    },
    crimson = {
        Name = "Crimson Pulse",
        Primary = Color3.fromRGB(220, 50, 80),
        Secondary = Color3.fromRGB(180, 30, 60),
        Tertiary = Color3.fromRGB(45, 25, 30),
        Deep = Color3.fromRGB(15, 10, 12),
        Background = Color3.fromRGB(20, 15, 18),
        Surface = Color3.fromRGB(30, 22, 26),
        Overlay = Color3.new(0, 0, 0),
        Text = Color3.fromRGB(255, 245, 248),
        TextDim = Color3.fromRGB(180, 150, 160),
        Success = Color3.fromRGB(50, 200, 120),
        Warning = Color3.fromRGB(255, 200, 0),
        Error = Color3.fromRGB(255, 80, 100),
        Info = Color3.fromRGB(220, 100, 150),
        
        -- State Colors
        Idle = Color3.fromRGB(180, 150, 160),
        Playing = Color3.fromRGB(50, 200, 120),
        Recording = Color3.fromRGB(255, 50, 80),
        Paused = Color3.fromRGB(255, 200, 50),
        
        -- Editor Colors
        Movement = Color3.fromRGB(220, 50, 80),
        Click = Color3.fromRGB(255, 100, 150),
        Key = Color3.fromRGB(255, 180, 50),
        Delay = Color3.fromRGB(160, 120, 140)
    },
    emerald = {
        Name = "Emerald Matrix",
        Primary = Color3.fromRGB(0, 200, 100),
        Secondary = Color3.fromRGB(0, 150, 75),
        Tertiary = Color3.fromRGB(22, 35, 28),
        Deep = Color3.fromRGB(8, 14, 10),
        Background = Color3.fromRGB(12, 20, 16),
        Surface = Color3.fromRGB(18, 28, 22),
        Overlay = Color3.new(0, 0, 0),
        Text = Color3.fromRGB(240, 255, 245),
        TextDim = Color3.fromRGB(140, 170, 150),
        Success = Color3.fromRGB(0, 255, 130),
        Warning = Color3.fromRGB(255, 200, 50),
        Error = Color3.fromRGB(255, 80, 80),
        Info = Color3.fromRGB(100, 220, 180),
        
        -- State Colors
        Idle = Color3.fromRGB(140, 170, 150),
        Playing = Color3.fromRGB(0, 255, 130),
        Recording = Color3.fromRGB(255, 80, 80),
        Paused = Color3.fromRGB(255, 200, 50),
        
        -- Editor Colors
        Movement = Color3.fromRGB(0, 200, 100),
        Click = Color3.fromRGB(100, 255, 180),
        Key = Color3.fromRGB(220, 255, 100),
        Delay = Color3.fromRGB(100, 140, 120)
    }
}

function Axiora.Visuals.GetTheme()
    return Axiora.Visuals.Themes[Axiora.Settings.Theme] or Axiora.Visuals.Themes.default
end

function Axiora.Visuals.SetTheme(themeName)
    if Axiora.Visuals.Themes[themeName] then
        Axiora.Settings.Theme = themeName
        Axiora.Events:Fire("ThemeChanged", themeName)
        return true
    end
    return false
end

-- Initialize screen GUI
function Axiora.Visuals.Init()
    if Axiora.Visuals.ScreenGui then
        pcall(function() Axiora.Visuals.ScreenGui:Destroy() end)
    end
    
    local sg = Instance.new("ScreenGui")
    sg.Name = "AxioraVisuals"
    sg.IgnoreGuiInset = true
    sg.ResetOnSpawn = false
    sg.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    -- Try CoreGui first, fallback to PlayerGui
    local success = pcall(function()
        sg.Parent = CoreGui
    end)
    if not success then
        local LP = getLocalPlayer()
        if LP and LP:FindFirstChild("PlayerGui") then
            sg.Parent = LP.PlayerGui
        end
    end
    
    Axiora.Visuals.ScreenGui = sg
    
    -- Create notification container
    local notifContainer = Instance.new("Frame")
    notifContainer.Name = "Notifications"
    notifContainer.BackgroundTransparency = 1
    notifContainer.Size = UDim2.new(0, 320, 1, 0)
    notifContainer.Position = UDim2.new(1, -330, 0, 10)
    notifContainer.AnchorPoint = Vector2.new(0, 0)
    notifContainer.Parent = sg
    
    local layout = Instance.new("UIListLayout")
    layout.SortOrder = Enum.SortOrder.LayoutOrder
    layout.Padding = UDim.new(0, 8)
    layout.VerticalAlignment = Enum.VerticalAlignment.Top
    layout.Parent = notifContainer
    
    Axiora.Visuals.NotificationContainer = notifContainer
    
    return sg
end

-- Notification function
function Axiora.Visuals.Notify(title, message, duration, notifType)
    duration = duration or 3
    notifType = notifType or "info"
    
    if not Axiora.Visuals.NotificationContainer then
        Axiora.Visuals.Init()
    end
    
    if Axiora.Visuals.NotificationCooldown then
        -- Queue it (with size limit to prevent memory leak)
        local maxQueueSize = 10
        if #Axiora.Visuals.NotificationQueue >= maxQueueSize then
            -- Remove oldest notification to make room
            table.remove(Axiora.Visuals.NotificationQueue, 1)
        end
        table.insert(Axiora.Visuals.NotificationQueue, {
            title = title, message = message, duration = duration, notifType = notifType
        })
        return
    end
    
    Axiora.Visuals.NotificationCooldown = true
    
    local theme = Axiora.Visuals.GetTheme()
    local typeColors = {
        success = theme.Success,
        warning = theme.Warning,
        error = theme.Error,
        info = theme.Info
    }
    local accentColor = typeColors[notifType] or theme.Primary
    
    -- Create notification frame
    local notif = Instance.new("Frame")
    notif.Name = "Notification"
    notif.BackgroundColor3 = theme.Surface
    notif.BackgroundTransparency = 0.1
    notif.Size = UDim2.new(1, 0, 0, 65)
    notif.Position = UDim2.new(1, 0, 0, 0) -- Start off-screen
    notif.BorderSizePixel = 0
    notif.ClipsDescendants = true
    notif.LayoutOrder = os.clock() * 1000
    notif.Parent = Axiora.Visuals.NotificationContainer
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = notif
    
    -- Accent bar
    local accent = Instance.new("Frame")
    accent.Name = "Accent"
    accent.BackgroundColor3 = accentColor
    accent.Size = UDim2.new(0, 4, 1, 0)
    accent.BorderSizePixel = 0
    accent.Parent = notif
    
    -- Title
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "Title"
    titleLabel.BackgroundTransparency = 1
    titleLabel.Size = UDim2.new(1, -20, 0, 22)
    titleLabel.Position = UDim2.new(0, 15, 0, 8)
    titleLabel.Text = title or "Axiora"
    titleLabel.TextColor3 = theme.Text
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.TextSize = 14
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.Parent = notif
    
    -- Message
    local msgLabel = Instance.new("TextLabel")
    msgLabel.Name = "Message"
    msgLabel.BackgroundTransparency = 1
    msgLabel.Size = UDim2.new(1, -20, 0, 30)
    msgLabel.Position = UDim2.new(0, 15, 0, 30)
    msgLabel.Text = message or ""
    msgLabel.TextColor3 = theme.TextDim
    msgLabel.Font = Enum.Font.Gotham
    msgLabel.TextSize = 12
    msgLabel.TextXAlignment = Enum.TextXAlignment.Left
    msgLabel.TextTruncate = Enum.TextTruncate.AtEnd
    msgLabel.TextWrapped = true
    msgLabel.Parent = notif
    
    -- Slide in animation
    local tweenIn = TweenService:Create(notif, TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {
        Position = UDim2.new(0, 0, 0, 0)
    })
    tweenIn:Play()
    
    -- Auto-dismiss
    task.delay(duration, function()
        if notif and notif.Parent then
            local tweenOut = TweenService:Create(notif, TweenInfo.new(0.25, Enum.EasingStyle.Quart), {
                Position = UDim2.new(1, 10, 0, 0),
                BackgroundTransparency = 1
            })
            tweenOut:Play()
            tweenOut.Completed:Wait()
            pcall(function() notif:Destroy() end)
        end
    end)
    
    -- Cooldown then process queue
    task.delay(0.3, function()
        Axiora.Visuals.NotificationCooldown = false
        if #Axiora.Visuals.NotificationQueue > 0 then
            local queued = table.remove(Axiora.Visuals.NotificationQueue, 1)
            Axiora.Visuals.Notify(queued.title, queued.message, queued.duration, queued.notifType)
        end
    end)
end

-- Ripple effect for clicks
function Axiora.Visuals.Ripple(x, y)
    if Axiora.Settings.PerformanceMode then return end
    if not Axiora.Visuals.ScreenGui then return end
    
    local theme = Axiora.Visuals.GetTheme()
    
    local r = Instance.new("Frame")
    r.Position = UDim2.fromOffset(x, y)
    r.Size = UDim2.fromOffset(0, 0)
    r.AnchorPoint = Vector2.new(0.5, 0.5)
    r.BackgroundColor3 = theme.Primary
    r.BackgroundTransparency = 0.4
    r.BorderSizePixel = 0
    r.ZIndex = 10
    r.Parent = Axiora.Visuals.ScreenGui
    
    Instance.new("UICorner", r).CornerRadius = UDim.new(1, 0)
    
    local tween = TweenService:Create(r, TweenInfo.new(0.5, Enum.EasingStyle.Quad), {
        Size = UDim2.fromOffset(80, 80),
        BackgroundTransparency = 1
    })
    tween:Play()
    tween.Completed:Connect(function()
        pcall(function() r:Destroy() end)
    end)
end

-- Create simple HUD
function Axiora.Visuals.CreateHUD()
    if not Axiora.Settings.HUDEnabled then return end
    
    if not Axiora.Visuals.ScreenGui then
        Axiora.Visuals.Init()
    end
    
    -- Remove old HUD
    if Axiora.Visuals.HUDFrame then
        pcall(function() Axiora.Visuals.HUDFrame:Destroy() end)
    end
    
    local theme = Axiora.Visuals.GetTheme()
    
    local hud = Instance.new("Frame")
    hud.Name = "HUD"
    hud.BackgroundColor3 = theme.Background
    hud.BackgroundTransparency = 0.15
    hud.Size = UDim2.new(0, 180, 0, 100)
    hud.Position = UDim2.new(0, 15, 0, 50)
    hud.BorderSizePixel = 0
    hud.Parent = Axiora.Visuals.ScreenGui
    
    Instance.new("UICorner", hud).CornerRadius = UDim.new(0, 10)
    
    local stroke = Instance.new("UIStroke")
    stroke.Color = theme.Primary
    stroke.Transparency = 0.5
    stroke.Thickness = 1.5
    stroke.Parent = hud
    
    -- Title
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.BackgroundTransparency = 1
    title.Size = UDim2.new(1, 0, 0, 25)
    title.Text = "AXIORA v" .. Axiora._VERSION
    title.TextColor3 = theme.Primary
    title.Font = Enum.Font.GothamBlack
    title.TextSize = 12
    title.Parent = hud
    
    -- Status
    local status = Instance.new("TextLabel")
    status.Name = "Status"
    status.BackgroundTransparency = 1
    status.Size = UDim2.new(1, 0, 0, 20)
    status.Position = UDim2.new(0, 0, 0, 28)
    status.Text = "IDLE"
    status.TextColor3 = theme.TextDim
    status.Font = Enum.Font.GothamBold
    status.TextSize = 11
    status.Parent = hud
    
    -- Buffer info
    local bufferInfo = Instance.new("TextLabel")
    bufferInfo.Name = "BufferInfo"
    bufferInfo.BackgroundTransparency = 1
    bufferInfo.Size = UDim2.new(1, 0, 0, 20)
    bufferInfo.Position = UDim2.new(0, 0, 0, 50)
    bufferInfo.Text = "Buffer: 0 nodes"
    bufferInfo.TextColor3 = theme.TextDim
    bufferInfo.Font = Enum.Font.Gotham
    bufferInfo.TextSize = 10
    status.Parent = hud
    
    -- Executor info
    local execInfo = Instance.new("TextLabel")
    execInfo.Name = "ExecInfo"
    execInfo.BackgroundTransparency = 1
    execInfo.Size = UDim2.new(1, 0, 0, 20)
    execInfo.Position = UDim2.new(0, 0, 0, 72)
    execInfo.Text = "Executor: " .. Axiora.Capabilities.Executor
    execInfo.TextColor3 = theme.TextDim
    execInfo.Font = Enum.Font.Gotham
    execInfo.TextSize = 9
    execInfo.Parent = hud
    
    Axiora.Visuals.HUDFrame = hud
    
    -- Update loop
    local hudThread = task.spawn(function()
        while hud and hud.Parent do
            if Axiora.State.Status then
                status.Text = Axiora.State.Status
                status.TextColor3 = Axiora.State.Status == "PLAYING" and theme.Success
                    or Axiora.State.Status == "RECORDING" and theme.Error
                    or Axiora.State.Status == "PAUSED" and theme.Warning
                    or theme.TextDim
            end
            bufferInfo.Text = "Buffer: " .. #Axiora.State.Buffer .. " nodes"
            task.wait(0.5)
        end
    end)
    table.insert(Axiora.State.Threads, hudThread)
    
    -- Dragging
    local dragging = false
    local dragStart, startPos
    
    hud.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = UserInputService:GetMouseLocation()
            startPos = hud.Position
        end
    end)
    
    hud.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local current = UserInputService:GetMouseLocation()
            local delta = current - dragStart
            hud.Position = UDim2.new(
                startPos.X.Scale, startPos.X.Offset + delta.X,
                startPos.Y.Scale, startPos.Y.Offset + delta.Y
            )
        end
    end)
    
    return hud
end

-- Show/Hide HUD
function Axiora.Visuals.ToggleHUD()
    if Axiora.Visuals.HUDFrame then
        Axiora.Visuals.HUDFrame.Visible = not Axiora.Visuals.HUDFrame.Visible
        return Axiora.Visuals.HUDFrame.Visible
    end
    return false
end

-- Clear visual objects
function Axiora.Visuals.Clear()
    for _, obj in ipairs(Axiora.Visuals.Objects) do
        pcall(function()
            if obj and obj.Parent then obj:Destroy() end
        end)
    end
    Axiora.Visuals.Objects = {}
    
    if Axiora.Visuals.Folder then
        pcall(function() Axiora.Visuals.Folder:Destroy() end)
        Axiora.Visuals.Folder = nil
    end
end

-- Render path visualization with progressive batch rendering
function Axiora.Visuals.RenderPath(mode)
    Axiora.Visuals.Clear()
    
    if #Axiora.State.Buffer == 0 then 
        Axiora.Visuals.Notify("Render", "No nodes to render", 2, "warning")
        return 
    end
    
    mode = mode or "simple"
    local theme = Axiora.Visuals.GetTheme()
    
    local folder = Instance.new("Folder")
    folder.Name = "Axiora_PathVisual"
    folder.Parent = Workspace
    Axiora.Visuals.Folder = folder
    
    -- Progressive rendering settings
    local batchSize = Axiora.Settings.RenderBatchSize or 50
    local batchDelay = Axiora.Settings.RenderBatchDelay or 0.03
    local spacing = Axiora.Settings.PerformanceMode and 5 or 2
    
    local totalNodes = math.ceil(#Axiora.State.Buffer / spacing)
    local renderedCount = 0
    local lastNotifyCount = 0
    
    Axiora.Visuals.Notify("Render", "Rendering " .. totalNodes .. " nodes...", 3, "info")
    
    for i = 1, #Axiora.State.Buffer, spacing do
        local node = Axiora.State.Buffer[i]
        if node and node.t == 1 and node.p then
            local pos = Axiora.Math.DeserializeVec(node.p)
            
            local part = Instance.new("Part")
            part.Name = "Node_" .. i
            part.Size = Vector3.new(0.4, 0.4, 0.4)
            part.Shape = Enum.PartType.Ball
            part.Anchored = true
            part.CanCollide = false
            part.Material = Enum.Material.Neon
            part.Color = theme.Primary
            part.Transparency = 0.5
            part.Position = pos
            part.CastShadow = false
            part.Parent = folder
            
            table.insert(Axiora.Visuals.Objects, part)
            renderedCount = renderedCount + 1
        end
        
        -- Progressive batch yielding - prevent "Roblox Not Responding"
        if renderedCount % batchSize == 0 then
            task.wait(batchDelay)
            
            -- Progress notification every 500 nodes
            if renderedCount - lastNotifyCount >= 500 then
                local percent = math.floor((renderedCount / totalNodes) * 100)
                Axiora.Visuals.Notify("Render", "Progress: " .. renderedCount .. "/" .. totalNodes .. " (" .. percent .. "%)", 1, "info")
                lastNotifyCount = renderedCount
            end
        end
    end
    
    Axiora.Visuals.Notify("Render", #Axiora.Visuals.Objects .. " nodes rendered", 2, "success")
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 10: SECURITY (Anti-AFK)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Security = {}
Axiora.Security.AntiAFKConnection = nil

function Axiora.Security.EnableAntiAFK()
    if Axiora.Security.AntiAFKConnection then return end
    
    local VirtualUser = game:GetService("VirtualUser")
    local LP = game:GetService("Players").LocalPlayer
    
    if LP then
        Axiora.Security.AntiAFKConnection = LP.Idled:Connect(function()
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end)
    end
end

function Axiora.Security.DisableAntiAFK()
    if Axiora.Security.AntiAFKConnection then
        Axiora.Security.AntiAFKConnection:Disconnect()
        Axiora.Security.AntiAFKConnection = nil
    end
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 9: FILE SYSTEM
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Files = {
    BaseFolder = "Axiora",
    SaveFolder = "Axiora/Saves",
    SettingsFile = "Axiora/settings.json"
}



-- Security: Prevent directory traversal and illegal characters
function Axiora.Files.Sanitize(path)
    if not path then return "" end
    -- Allow alphanumeric, hyphens, underscores, and spaces
    -- Remove slashes, backslashes, dots (to prevent ../)
    return path:gsub("[^%w%-_%s]", "")
end

function Axiora.Files.EnsureFolder(path)
    if not Axiora.Capabilities.MakeFolder then return false end
    
    local success = pcall(function()
        if Axiora.Capabilities.IsFolder and not isfolder(path) then
            makefolder(path)
        elseif not Axiora.Capabilities.IsFolder then
            makefolder(path)
        end
    end)
    return success
end

function Axiora.Files.Init()
    Axiora.Files.EnsureFolder(Axiora.Files.BaseFolder)
    Axiora.Files.EnsureFolder(Axiora.Files.SaveFolder)
end

function Axiora.Save(name)
    if not Axiora.Capabilities.WriteFile then
        Axiora.Visuals.Notify("Save", "File system not available", 3, "error")
        return false
    end
    
    if #Axiora.State.Buffer == 0 then
        Axiora.Visuals.Notify("Save", "No macro to save", 2, "warning")
        return false
    end
    
    Axiora.Files.EnsureFolder(Axiora.Files.SaveFolder)
    
    -- Sanitize name
    name = Axiora.Files.Sanitize(name or ("macro_" .. os.time()))
    if name == "" then name = "unnamed_macro" end
    
    local filename = Axiora.Files.SaveFolder .. "/" .. name .. ".axr"
    
    local data = {
        version = Axiora._VERSION,
        name = name,
        savedAt = os.time(),
        placeId = game.PlaceId,
        nodeCount = #Axiora.State.Buffer,
        buffer = Axiora.State.Buffer
    }
    
    local success, err = pcall(function()
        local json = HttpService:JSONEncode(data)
        if #json > 1024 * 1024 then
            error("File too large (>1MB) - Reduce recording duration")
        end
        writefile(filename, json)
    end)
    
    if success then
        Axiora.Visuals.Notify("Save", "Saved: " .. name, 2, "success")
        return true
    else
        Axiora.Visuals.Notify("Save", "Failed to save", 3, "error")
        return false
    end
end

function Axiora.Load(name)
    if not Axiora.Capabilities.ReadFile then
        Axiora.Visuals.Notify("Load", "File system not available", 3, "error")
        return false
    end
    
    -- Sanitize name
    name = Axiora.Files.Sanitize(name)
    local filename = Axiora.Files.SaveFolder .. "/" .. name .. ".axr"
    
    local success, data = pcall(function()
        local json = readfile(filename)
        return HttpService:JSONDecode(json)
    end)
    
    if success and data and data.buffer then
        Axiora.State.Buffer = data.buffer
        Axiora.Visuals.Notify("Load", "Loaded: " .. (data.name or name) .. " (" .. #data.buffer .. " nodes)", 3, "success")
        Axiora.Events:Fire("MacroLoaded", {Name = data.name, Nodes = #data.buffer})
        return true
    else
        Axiora.Visuals.Notify("Load", "Failed to load file", 3, "error")
        return false
    end
end

function Axiora.ListSaves()
    if not Axiora.Capabilities.ReadFile then return {} end
    
    local saves = {}
    local success = pcall(function()
        if listfiles then
            local files = listfiles(Axiora.Files.SaveFolder)
            for _, file in ipairs(files) do
                if file:match("%.axr$") then
                    local name = file:match("([^/\\]+)%.axr$")
                    if name then
                        table.insert(saves, name)
                    end
                end
            end
        end
    end)
    return saves
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- MACRO EDITOR API
-- ═══════════════════════════════════════════════════════════════════════════════

-- View all nodes in the buffer (for editing)
function Axiora.EditBuffer()
    local nodes = {}
    for i, node in ipairs(Axiora.State.Buffer) do
        local nodeInfo = {
            Index = i,
            Type = node.t == 1 and "Move" or node.t == 2 and "Click" or node.t == 3 and "Key" or "Unknown",
            Delay = node.d or 0,
        }
        
        if node.t == 1 then
            nodeInfo.Position = node.p
            nodeInfo.Jump = node.j
            nodeInfo.Camera = node.c and true or false
        elseif node.t == 2 then
            nodeInfo.X = node.x
            nodeInfo.Y = node.y
            nodeInfo.UI = node.ui
        elseif node.t == 3 then
            nodeInfo.Key = node.k
        end
        
        table.insert(nodes, nodeInfo)
    end
    return nodes
end

-- Get a specific node by index
function Axiora.GetNode(index)
    if index < 1 or index > #Axiora.State.Buffer then
        return nil
    end
    
    local node = Axiora.State.Buffer[index]
    return {
        Index = index,
        Type = node.t == 1 and "Move" or node.t == 2 and "Click" or node.t == 3 and "Key" or "Unknown",
        RawType = node.t,
        Delay = node.d or 0,
        Data = node
    }
end

-- Delete a node at index
function Axiora.DeleteNode(index)
    if index < 1 or index > #Axiora.State.Buffer then
        Axiora.Visuals.Notify("Editor", "Invalid node index", 2, "error")
        return false
    end
    
    local removed = table.remove(Axiora.State.Buffer, index)
    Axiora.Visuals.Notify("Editor", "Deleted node #" .. index, 2, "success")
    Axiora.Events:Fire("NodeDeleted", {Index = index, Node = removed})
    return true
end

-- Insert a node at index
function Axiora.InsertNode(index, node)
    if index < 1 or index > #Axiora.State.Buffer + 1 then
        Axiora.Visuals.Notify("Editor", "Invalid insert index", 2, "error")
        return false
    end
    
    table.insert(Axiora.State.Buffer, index, node)
    Axiora.Visuals.Notify("Editor", "Inserted node at #" .. index, 2, "success")
    Axiora.Events:Fire("NodeInserted", {Index = index, Node = node})
    return true
end

-- Update a node's properties
function Axiora.UpdateNode(index, changes)
    if index < 1 or index > #Axiora.State.Buffer then
        Axiora.Visuals.Notify("Editor", "Invalid node index", 2, "error")
        return false
    end
    
    local node = Axiora.State.Buffer[index]
    for key, value in pairs(changes) do
        node[key] = value
    end
    
    Axiora.Visuals.Notify("Editor", "Updated node #" .. index, 2, "success")
    Axiora.Events:Fire("NodeUpdated", {Index = index, Changes = changes})
    return true
end

-- Delete nodes in a range
function Axiora.DeleteRange(startIdx, endIdx)
    if startIdx < 1 or endIdx > #Axiora.State.Buffer or startIdx > endIdx then
        Axiora.Visuals.Notify("Editor", "Invalid range", 2, "error")
        return false
    end
    
    local count = endIdx - startIdx + 1
    for i = 1, count do
        table.remove(Axiora.State.Buffer, startIdx)
    end
    
    Axiora.Visuals.Notify("Editor", "Deleted " .. count .. " nodes", 2, "success")
    return true
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- MACRO STITCHING (Combine)
-- ═══════════════════════════════════════════════════════════════════════════════

function Axiora.Combine(macro1Name, macro2Name, outputName)
    if not Axiora.Capabilities.ReadFile or not Axiora.Capabilities.WriteFile then
        Axiora.Visuals.Notify("Combine", "File system not available", 3, "error")
        return false
    end
    
    -- Load first macro
    local file1 = Axiora.Files.SaveFolder .. "/" .. macro1Name .. ".axr"
    local success1, data1 = pcall(function()
        return HttpService:JSONDecode(readfile(file1))
    end)
    
    if not success1 or not data1 or not data1.buffer then
        Axiora.Visuals.Notify("Combine", "Failed to load: " .. macro1Name, 3, "error")
        return false
    end
    
    -- Load second macro
    local file2 = Axiora.Files.SaveFolder .. "/" .. macro2Name .. ".axr"
    local success2, data2 = pcall(function()
        return HttpService:JSONDecode(readfile(file2))
    end)
    
    if not success2 or not data2 or not data2.buffer then
        Axiora.Visuals.Notify("Combine", "Failed to load: " .. macro2Name, 3, "error")
        return false
    end
    
    -- Find max delay from first macro
    local maxDelay = 0
    for _, node in ipairs(data1.buffer) do
        if node.d and node.d > maxDelay then
            maxDelay = node.d
        end
    end
    
    -- Add a small gap between macros
    local delayOffset = maxDelay + 1.0
    
    -- Create combined buffer
    local combinedBuffer = {}
    
    -- Add all nodes from macro1
    for _, node in ipairs(data1.buffer) do
        table.insert(combinedBuffer, node)
    end
    
    -- Add all nodes from macro2 with adjusted timestamps
    for _, node in ipairs(data2.buffer) do
        local adjustedNode = {}
        for k, v in pairs(node) do
            adjustedNode[k] = v
        end
        adjustedNode.d = (adjustedNode.d or 0) + delayOffset
        table.insert(combinedBuffer, adjustedNode)
    end
    
    -- Save combined macro
    outputName = outputName or (macro1Name .. "_" .. macro2Name)
    local outputFile = Axiora.Files.SaveFolder .. "/" .. outputName .. ".axr"
    
    local saveData = {
        version = Axiora._VERSION,
        name = outputName,
        savedAt = os.time(),
        placeId = game.PlaceId,
        nodeCount = #combinedBuffer,
        combinedFrom = {macro1Name, macro2Name},
        buffer = combinedBuffer
    }
    
    local success = pcall(function()
        writefile(outputFile, HttpService:JSONEncode(saveData))
    end)
    
    if success then
        Axiora.Visuals.Notify("Combine", "Created: " .. outputName .. " (" .. #combinedBuffer .. " nodes)", 3, "success")
        Axiora.Events:Fire("MacrosCombined", {
            Macro1 = macro1Name,
            Macro2 = macro2Name,
            Output = outputName,
            TotalNodes = #combinedBuffer
        })
        return true
    else
        Axiora.Visuals.Notify("Combine", "Failed to save combined macro", 3, "error")
        return false
    end
end


-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 10: STRATEGY LOADER (URL Loading)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.StrategyLoader = {
    Current = nil,
    Loading = false,
    TrustedDomains = {
        "pastebin.com",
        "raw.githubusercontent.com",
        "gist.githubusercontent.com"
    }
}

-- Universal HTTP request function
local function httpGet(url)
    -- Try request() first (most compatible)
    if typeof(request) == "function" then
        local response = request({Url = url, Method = "GET"})
        if response and response.Success then
            return response.Body
        end
    end
    
    if typeof(http_request) == "function" then
        local response = http_request({Url = url, Method = "GET"})
        if response and response.Success then
            return response.Body
        end
    end
    
    -- Synapse X
    if typeof(syn) == "table" and typeof(syn.request) == "function" then
        local response = syn.request({Url = url, Method = "GET"})
        if response and response.Success then
            return response.Body
        end
    end
    
    -- game:HttpGet fallback
    if game.HttpGet then
        return game:HttpGet(url)
    end
    
    error("No HTTP method available")
end

-- Sanitize URL for raw content
local function sanitizeURL(url)
    if not url or type(url) ~= "string" then return nil end
    
    url = url:gsub("^%s+", ""):gsub("%s+$", "")
    
    if not url:find("^https?://") then
        url = "https://" .. url
    end
    
    -- Pastebin: convert to raw
    if url:find("pastebin.com/") and not url:find("pastebin.com/raw/") then
        local id = url:match("pastebin%.com/([%w]+)$")
        if id then url = "https://pastebin.com/raw/" .. id end
    end
    
    return url
end

function Axiora.StrategyLoader.FetchFromURL(url, options)
    options = options or {}
    
    if Axiora.StrategyLoader.Loading then
        Axiora.Visuals.Notify("Loader", "Already loading...", 2, "warning")
        return false
    end
    
    url = sanitizeURL(url)
    if not url then
        Axiora.Visuals.Notify("Loader", "Invalid URL", 2, "error")
        return false
    end
    
    Axiora.StrategyLoader.Loading = true
    Axiora.Visuals.Notify("Loader", "Fetching strategy...", 2, "info")
    
    task.spawn(function()
        local success, response = pcall(function()
            return httpGet(url)
        end)
        
        if not success or not response then
            Axiora.StrategyLoader.Loading = false
            Axiora.Visuals.Notify("Loader", "Failed to fetch URL", 3, "error")
            return
        end
        
        -- Try to parse as JSON
        local data = nil
        local parseSuccess = pcall(function()
            data = HttpService:JSONDecode(response)
        end)
        
        if not parseSuccess or not data then
            Axiora.StrategyLoader.Loading = false
            Axiora.Visuals.Notify("Loader", "Failed to parse data", 3, "error")
            return
        end
        
        -- Convert to Axiora format
        local convertSuccess = Axiora.StrategyLoader.Convert(data)
        
        Axiora.StrategyLoader.Loading = false
        
        if convertSuccess then
            Axiora.StrategyLoader.Current = {
                Data = data,
                URL = url,
                LoadedAt = os.clock()
            }
            Axiora.Events:Fire("StrategyLoaded", Axiora.StrategyLoader.Current)
        end
    end)
    
    return true
end

-- Convert external format to Axiora buffer
function Axiora.StrategyLoader.Convert(data)
    if not data then return false end
    
    local nodes = {}
    local timeOffset = 0
    
    -- Check for Axiora native format
    if data.buffer or data.nodes then
        Axiora.State.Buffer = data.buffer or data.nodes
        Axiora.Visuals.Notify("Loader", "Loaded " .. #Axiora.State.Buffer .. " nodes", 3, "success")
        return true
    end
    
    -- Check for actions array (Stratz-like format)
    local actions = data.actions or data.events or data
    if type(actions) ~= "table" then
        Axiora.Visuals.Notify("Loader", "Unknown format", 3, "error")
        return false
    end
    
    for i, act in ipairs(actions) do
        if type(act) == "table" then
            local delay = tonumber(act.delay) or tonumber(act.wait) or 0
            timeOffset = timeOffset + delay
            
            local eventType = (act.event or act.type or act.action or ""):lower()
            
            if eventType == "click" or eventType == "tap" then
                local x = tonumber(act.x) or 0
                local y = tonumber(act.y) or 0
                
                -- Normalize if values seem like absolute coords
                if x > 1 or y > 1 then
                    local res = data.resolution or {width = 1920, height = 1080}
                    x = x / (res.width or 1920)
                    y = y / (res.height or 1080)
                end
                
                table.insert(nodes, {
                    t = 2,
                    d = timeOffset,
                    x = x,
                    y = y
                })
                
            elseif eventType == "key" or eventType == "keyboard" then
                table.insert(nodes, {
                    t = 3,
                    d = timeOffset,
                    k = act.key or act.keycode
                })
                
            elseif eventType == "move" or eventType == "position" then
                local pos = act.position or {x = act.x, y = act.y, z = act.z}
                table.insert(nodes, {
                    t = 1,
                    d = timeOffset,
                    p = {pos.x or 0, pos.y or 0, pos.z or 0}
                })
            end
        end
    end
    
    if #nodes > 0 then
        Axiora.State.Buffer = nodes
        Axiora.Visuals.Notify("Loader", "Converted " .. #nodes .. " nodes", 3, "success")
        return true
    end
    
    Axiora.Visuals.Notify("Loader", "No valid actions found", 3, "warning")
    return false
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 11: HOTKEY SYSTEM
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Hotkeys = {
    Enabled = true,
    Bindings = {
        Record = Enum.KeyCode.F1,
        Play = Enum.KeyCode.F2,
        Stop = Enum.KeyCode.F3,
        ToggleUI = Enum.KeyCode.F4,
        ToggleHUD = Enum.KeyCode.F8
    },
    Connection = nil,
    LastTrigger = {},
    Cooldown = 0.3
}

function Axiora.Hotkeys.CanTrigger(keyCode)
    local now = os.clock()
    local last = Axiora.Hotkeys.LastTrigger[keyCode] or 0
    if (now - last) < Axiora.Hotkeys.Cooldown then
        return false
    end
    Axiora.Hotkeys.LastTrigger[keyCode] = now
    return true
end

function Axiora.Hotkeys.Init()
    if Axiora.Hotkeys.Connection then
        pcall(function() Axiora.Hotkeys.Connection:Disconnect() end)
    end
    
    Axiora.Hotkeys.Connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not Axiora.Hotkeys.Enabled then return end
        if gameProcessed then return end
        if input.UserInputType ~= Enum.UserInputType.Keyboard then return end
        
        local keyCode = input.KeyCode
        
        if not Axiora.Hotkeys.CanTrigger(keyCode) then return end
        
        if keyCode == Axiora.Hotkeys.Bindings.Record then
            if Axiora.State.Status == "RECORDING" then
                Axiora.Stop()
            else
                Axiora.Record()
            end
            
        elseif keyCode == Axiora.Hotkeys.Bindings.Play then
            if Axiora.State.Status == "PLAYING" then
                Axiora.Pause()
            else
                Axiora.Play(true)
            end
            
        elseif keyCode == Axiora.Hotkeys.Bindings.Stop then
            Axiora.Stop()
            
        elseif keyCode == Axiora.Hotkeys.Bindings.ToggleUI then
            if Axiora.UI and Axiora.UI.Toggle then
                Axiora.UI.Toggle()
            end
            
        elseif keyCode == Axiora.Hotkeys.Bindings.ToggleHUD then
            Axiora.Visuals.ToggleHUD()
        end
    end)
    
    Axiora.State.SecurityConnections.Hotkeys = Axiora.Hotkeys.Connection
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 12: SECURITY (Anti-AFK, Anti-Kick)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Security = {
    AntiAFKActive = false,
    AntiKickActive = false
}

function Axiora.Security.EnableAntiAFK()
    if Axiora.Security.AntiAFKActive then return end
    
    local LP = getLocalPlayer()
    if not LP then return end
    
    local success = pcall(function()
        local vu = LP:FindFirstChildOfClass("VirtualUser")
        if not vu then
            vu = Instance.new("VirtualUser")
            vu.Parent = LP
        end
        
        local afkConn = Players.LocalPlayer.Idled:Connect(function()
            -- Add random delay to avoid instant reaction
            task.wait(math.random(1, 4))
            
            vu:CaptureController()
            
            -- Randomize click position to avoid hitting same pixel
            local viewport = workspace.CurrentCamera.ViewportSize
            local randomPos = Vector2.new(
                math.random(10, viewport.X - 10),
                math.random(10, viewport.Y - 10)
            )
            
            vu:ClickButton2(randomPos)
        end)
        
        Axiora.State.SecurityConnections.AntiAFK = afkConn
        Axiora.Security.AntiAFKActive = true
    end)
    
    if success then
        Axiora.Visuals.Notify("Security", "Anti-AFK enabled", 2, "success")
    end
end

function Axiora.Security.DisableAntiAFK()
    if Axiora.State.SecurityConnections.AntiAFK then
        pcall(function()
            Axiora.State.SecurityConnections.AntiAFK:Disconnect()
        end)
        Axiora.State.SecurityConnections.AntiAFK = nil
    end
    Axiora.Security.AntiAFKActive = false
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 13: SEQUENCE MANAGER (Multi-Macro Queue)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Sequences = {
    Queue = {},
    CurrentIndex = 0,
    Repeat = false,
    Running = false,
    _connection = nil
}

function Axiora.Sequences.Add(name, buffer, options)
    options = options or {}
    
    local seq = {
        Name = name or ("Sequence_" .. (#Axiora.Sequences.Queue + 1)),
        Buffer = buffer or table.clone(Axiora.State.Buffer),
        Delay = options.delay or 1,
        LoopCount = options.loopCount or 1,
        WaitForCompletion = options.waitForCompletion ~= false
    }
    
    table.insert(Axiora.Sequences.Queue, seq)
    Axiora.Visuals.Notify("Sequences", "Added: " .. seq.Name .. " (" .. #seq.Buffer .. " nodes)", 2, "success")
    Axiora.Events:Fire("SequenceAdded", seq)
    return #Axiora.Sequences.Queue
end

function Axiora.Sequences.AddCurrentBuffer(name, options)
    if #Axiora.State.Buffer == 0 then
        Axiora.Visuals.Notify("Sequences", "Buffer is empty", 2, "warning")
        return nil
    end
    return Axiora.Sequences.Add(name, table.clone(Axiora.State.Buffer), options)
end

function Axiora.Sequences.Remove(index)
    if index <= 0 or index > #Axiora.Sequences.Queue then return false end
    local removed = table.remove(Axiora.Sequences.Queue, index)
    Axiora.Visuals.Notify("Sequences", "Removed: " .. removed.Name, 2, "info")
    return true
end

function Axiora.Sequences.Clear()
    Axiora.Sequences.Queue = {}
    Axiora.Sequences.CurrentIndex = 0
    Axiora.Visuals.Notify("Sequences", "Queue cleared", 2, "info")
end

function Axiora.Sequences.GetQueue()
    local list = {}
    for i, seq in ipairs(Axiora.Sequences.Queue) do
        table.insert(list, {
            Index = i,
            Name = seq.Name,
            Nodes = #seq.Buffer,
            Delay = seq.Delay
        })
    end
    return list
end

function Axiora.Sequences.ExecuteQueue()
    if #Axiora.Sequences.Queue == 0 then
        Axiora.Visuals.Notify("Sequences", "Queue is empty", 2, "warning")
        return false
    end
    
    if Axiora.Sequences.Running then
        Axiora.Visuals.Notify("Sequences", "Already running", 2, "warning")
        return false
    end
    
    Axiora.Sequences.Running = true
    Axiora.Sequences.CurrentIndex = 0
    
    local function executeNext()
        if not Axiora.Sequences.Running then return end
        
        Axiora.Sequences.CurrentIndex = Axiora.Sequences.CurrentIndex + 1
        
        if Axiora.Sequences.CurrentIndex > #Axiora.Sequences.Queue then
            if Axiora.Sequences.Repeat then
                Axiora.Sequences.CurrentIndex = 0
                task.wait(2)
                executeNext()
            else
                Axiora.Sequences.Running = false
                Axiora.Visuals.Notify("Sequences", "Queue completed!", 3, "success")
                Axiora.Events:Fire("QueueCompleted")
            end
            return
        end
        
        local seq = Axiora.Sequences.Queue[Axiora.Sequences.CurrentIndex]
        
        Axiora.Visuals.Notify("Sequence", "Playing: " .. seq.Name .. " (" .. Axiora.Sequences.CurrentIndex .. "/" .. #Axiora.Sequences.Queue .. ")", 3, "info")
        
        -- Load and play
        Axiora.State.Buffer = seq.Buffer
        Axiora.Play(seq.LoopCount > 1)
        
        if seq.WaitForCompletion then
            Axiora.Sequences._connection = Axiora.Events:Connect("Stopped", function()
                if Axiora.Sequences._connection then
                    Axiora.Sequences._connection.Disconnect()
                    Axiora.Sequences._connection = nil
                end
                task.wait(seq.Delay)
                executeNext()
            end)
        else
            task.wait(seq.Delay)
            executeNext()
        end
    end
    
    Axiora.Visuals.Notify("Sequences", "Starting queue (" .. #Axiora.Sequences.Queue .. " sequences)", 2, "info")
    executeNext()
    return true
end

function Axiora.Sequences.StopQueue()
    Axiora.Sequences.Running = false
    if Axiora.Sequences._connection then
        pcall(function() Axiora.Sequences._connection.Disconnect() end)
        Axiora.Sequences._connection = nil
    end
    Axiora.Stop()
    Axiora.Visuals.Notify("Sequences", "Queue stopped", 2, "info")
end

function Axiora.Sequences.SaveQueue(name)
    if not Axiora.Capabilities.WriteFile then return false end
    
    Axiora.Files.EnsureFolder("Axiora/Queues")
    
    local data = {
        Version = Axiora._VERSION,
        QueueName = name,
        Sequences = Axiora.Sequences.Queue,
        Repeat = Axiora.Sequences.Repeat,
        SavedAt = os.time()
    }
    
    local success = pcall(function()
        writefile("Axiora/Queues/" .. name .. ".queue", HttpService:JSONEncode(data))
    end)
    
    if success then
        Axiora.Visuals.Notify("Sequences", "Queue saved: " .. name, 2, "success")
    end
    return success
end

function Axiora.Sequences.LoadQueue(name)
    if not Axiora.Capabilities.ReadFile then return false end
    
    local success, data = pcall(function()
        return HttpService:JSONDecode(readfile("Axiora/Queues/" .. name .. ".queue"))
    end)
    
    if success and data and data.Sequences then
        Axiora.Sequences.Queue = data.Sequences
        Axiora.Sequences.Repeat = data.Repeat or false
        Axiora.Visuals.Notify("Sequences", "Loaded: " .. name, 2, "success")
        return true
    end
    return false
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- BREAKPOINT SYSTEM (Debug Pausing)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Breakpoints = {
    Nodes = {},           -- {[nodeIndex] = true}
    Enabled = true,
    PauseOnHit = true,
    WaitingAtBreakpoint = false,
    CurrentBreakpoint = nil
}

-- Set a breakpoint at a specific node index
function Axiora.SetBreakpoint(index)
    if type(index) ~= "number" or index < 1 then
        Axiora.Visuals.Notify("Breakpoint", "Invalid index", 2, "error")
        return false
    end
    
    Axiora.Breakpoints.Nodes[index] = true
    Axiora.Visuals.Notify("Breakpoint", "Set at node #" .. index, 2, "success")
    Axiora.Events:Fire("BreakpointSet", {Index = index})
    return true
end

-- Remove a breakpoint
function Axiora.RemoveBreakpoint(index)
    if not Axiora.Breakpoints.Nodes[index] then
        Axiora.Visuals.Notify("Breakpoint", "No breakpoint at #" .. index, 2, "warning")
        return false
    end
    
    Axiora.Breakpoints.Nodes[index] = nil
    Axiora.Visuals.Notify("Breakpoint", "Removed from node #" .. index, 2, "info")
    Axiora.Events:Fire("BreakpointRemoved", {Index = index})
    return true
end

-- Toggle breakpoint
function Axiora.ToggleBreakpoint(index)
    if Axiora.Breakpoints.Nodes[index] then
        return Axiora.RemoveBreakpoint(index)
    else
        return Axiora.SetBreakpoint(index)
    end
end

-- Clear all breakpoints
function Axiora.ClearBreakpoints()
    local count = 0
    for _ in pairs(Axiora.Breakpoints.Nodes) do
        count = count + 1
    end
    
    Axiora.Breakpoints.Nodes = {}
    Axiora.Visuals.Notify("Breakpoint", "Cleared " .. count .. " breakpoints", 2, "info")
    Axiora.Events:Fire("BreakpointsCleared", {Count = count})
    return count
end

-- List all breakpoints
function Axiora.ListBreakpoints()
    local list = {}
    for index, _ in pairs(Axiora.Breakpoints.Nodes) do
        table.insert(list, index)
    end
    table.sort(list)
    return list
end

-- Check if node has breakpoint (used in playback loop)
function Axiora.Breakpoints.Check(nodeIndex)
    if not Axiora.Settings.BreakpointsEnabled then return false end
    if not Axiora.Breakpoints.Enabled then return false end
    return Axiora.Breakpoints.Nodes[nodeIndex] == true
end

-- Resume from breakpoint
function Axiora.ResumeFromBreakpoint()
    if Axiora.Breakpoints.WaitingAtBreakpoint then
        Axiora.Breakpoints.WaitingAtBreakpoint = false
        Axiora.Visuals.Notify("Breakpoint", "Resumed from #" .. (Axiora.Breakpoints.CurrentBreakpoint or "?"), 2, "success")
        Axiora.Breakpoints.CurrentBreakpoint = nil
        return true
    end
    return false
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 14: AUTO-RESTART SYSTEM
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.AutoRestart = {
    Enabled = false,
    OnDeath = true,
    MaxRestarts = 10,
    RestartCount = 0,
    RestartDelay = 5,
    LastRestartTime = 0,
    RestartCooldown = 10,
    _initialized = false,
    _characterConnection = nil,
    _deathConnection = nil
}

function Axiora.AutoRestart.Enable()
    if Axiora.AutoRestart.Enabled then return end
    
    Axiora.AutoRestart.Enabled = true
    Axiora.AutoRestart.RestartCount = 0
    Axiora.AutoRestart.LastRestartTime = 0
    
    -- Clean up old connections
    if Axiora.AutoRestart._characterConnection then
        pcall(function() Axiora.AutoRestart._characterConnection:Disconnect() end)
    end
    if Axiora.AutoRestart._deathConnection then
        pcall(function() Axiora.AutoRestart._deathConnection:Disconnect() end)
    end
    
    local LP = getLocalPlayer()
    if not LP then return end
    
    -- Setup character listener
    Axiora.AutoRestart._characterConnection = LP.CharacterAdded:Connect(function(char)
        -- Wait for humanoid
        local hum = char:WaitForChild("Humanoid", 5)
        if not hum then return end
        
        -- Clean up old death connection
        if Axiora.AutoRestart._deathConnection then
            pcall(function() Axiora.AutoRestart._deathConnection:Disconnect() end)
        end
        
        -- Setup death listener
        Axiora.AutoRestart._deathConnection = hum.Died:Connect(function()
            if not Axiora.AutoRestart.Enabled then return end
            if not Axiora.AutoRestart.OnDeath then return end
            if Axiora.AutoRestart.RestartCount >= Axiora.AutoRestart.MaxRestarts then
                Axiora.Visuals.Notify("Auto-Restart", "Max restarts reached", 3, "warning")
                Axiora.AutoRestart.Disable()
                return
            end
            
            local now = os.clock()
            if (now - Axiora.AutoRestart.LastRestartTime) < Axiora.AutoRestart.RestartCooldown then
                return
            end
            
            if Axiora.State.Status ~= "PLAYING" and #Axiora.State.Buffer == 0 then
                return
            end
            
            Axiora.AutoRestart.RestartCount = Axiora.AutoRestart.RestartCount + 1
            Axiora.AutoRestart.LastRestartTime = now
            
            Axiora.Visuals.Notify("Auto-Restart", 
                "Restarting in " .. Axiora.AutoRestart.RestartDelay .. "s... (" .. 
                Axiora.AutoRestart.RestartCount .. "/" .. Axiora.AutoRestart.MaxRestarts .. ")", 
                Axiora.AutoRestart.RestartDelay, "warning")
            
            task.delay(Axiora.AutoRestart.RestartDelay, function()
                if not Axiora.AutoRestart.Enabled then return end
                
                -- Wait for respawn
                local waitStart = os.clock()
                while (os.clock() - waitStart) < 15 do
                    if LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") then
                        break
                    end
                    task.wait(0.5)
                end
                
                task.wait(1)
                Axiora.Play(true)
            end)
        end)
    end)
    
    -- Also setup for current character
    if LP.Character then
        local hum = LP.Character:FindFirstChildOfClass("Humanoid")
        if hum and hum.Health > 0 then
            -- Trigger same logic
            Axiora.AutoRestart._deathConnection = hum.Died:Connect(function()
                -- Same death handling
                if not Axiora.AutoRestart.Enabled or not Axiora.AutoRestart.OnDeath then return end
                if Axiora.AutoRestart.RestartCount >= Axiora.AutoRestart.MaxRestarts then return end
                
                Axiora.AutoRestart.RestartCount = Axiora.AutoRestart.RestartCount + 1
                Axiora.Visuals.Notify("Auto-Restart", "Restarting...", 3, "warning")
                
                task.delay(Axiora.AutoRestart.RestartDelay, function()
                    if not Axiora.AutoRestart.Enabled then return end
                    LP.CharacterAdded:Wait()
                    task.wait(2)
                    Axiora.Play(true)
                end)
            end)
        end
    end
    
    Axiora.AutoRestart._initialized = true
    Axiora.Visuals.Notify("Auto-Restart", "Enabled", 2, "success")
    Axiora.Events:Fire("AutoRestartEnabled")
end

function Axiora.AutoRestart.Disable()
    Axiora.AutoRestart.Enabled = false
    
    if Axiora.AutoRestart._characterConnection then
        pcall(function() Axiora.AutoRestart._characterConnection:Disconnect() end)
        Axiora.AutoRestart._characterConnection = nil
    end
    if Axiora.AutoRestart._deathConnection then
        pcall(function() Axiora.AutoRestart._deathConnection:Disconnect() end)
        Axiora.AutoRestart._deathConnection = nil
    end
    
    Axiora.AutoRestart._initialized = false
    Axiora.Visuals.Notify("Auto-Restart", "Disabled", 2, "info")
    Axiora.Events:Fire("AutoRestartDisabled")
end

function Axiora.AutoRestart.Toggle()
    if Axiora.AutoRestart.Enabled then
        Axiora.AutoRestart.Disable()
    else
        Axiora.AutoRestart.Enable()
    end
    return Axiora.AutoRestart.Enabled
end

function Axiora.AutoRestart.ResetCount()
    Axiora.AutoRestart.RestartCount = 0
end

function Axiora.AutoRestart.GetStatus()
    return {
        Enabled = Axiora.AutoRestart.Enabled,
        RestartCount = Axiora.AutoRestart.RestartCount,
        MaxRestarts = Axiora.AutoRestart.MaxRestarts,
        Delay = Axiora.AutoRestart.RestartDelay
    }
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 15: CONDITIONAL PLAYBACK (IF/THEN Logic)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Conditions = {
    _timers = {},
    _variables = {}
}

-- Condition checks
Axiora.Conditions.Checks = {
    CharacterExists = function()
        local LP = getLocalPlayer()
        return LP and LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") ~= nil
    end,
    
    IsAlive = function()
        local LP = getLocalPlayer()
        if not LP or not LP.Character then return false end
        local hum = LP.Character:FindFirstChildOfClass("Humanoid")
        return hum and hum.Health > 0
    end,
    
    HealthAbove = function(percent)
        local LP = getLocalPlayer()
        if not LP or not LP.Character then return false end
        local hum = LP.Character:FindFirstChildOfClass("Humanoid")
        if not hum then return false end
        return (hum.Health / hum.MaxHealth) * 100 >= (percent or 50)
    end,
    
    HealthBelow = function(percent)
        local LP = getLocalPlayer()
        if not LP or not LP.Character then return false end
        local hum = LP.Character:FindFirstChildOfClass("Humanoid")
        if not hum then return false end
        return (hum.Health / hum.MaxHealth) * 100 < (percent or 50)
    end,
    
    DistanceFromPosition = function(pos, maxDistance)
        local LP = getLocalPlayer()
        if not Axiora.Conditions.Checks.CharacterExists() then return false end
        
        local target
        if typeof(pos) == "Vector3" then
            target = pos
        elseif type(pos) == "table" then
            target = Vector3.new(pos.x or pos[1] or 0, pos.y or pos[2] or 0, pos.z or pos[3] or 0)
        else
            return false
        end
        
        local hrp = LP.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        return (hrp.Position - target).Magnitude <= (maxDistance or 50)
    end,
    
    PartExists = function(partName, parent)
        local searchIn = parent and game:FindFirstChild(parent) or Workspace
        if not searchIn then return false end
        return searchIn:FindFirstChild(partName, true) ~= nil
    end,
    
    TimePassed = function(seconds, timerKey)
        timerKey = timerKey or "_default"
        if not Axiora.Conditions._timers[timerKey] then
            Axiora.Conditions._timers[timerKey] = os.clock()
            return false
        end
        return (os.clock() - Axiora.Conditions._timers[timerKey]) >= (seconds or 0)
    end,
    
    ResetTimer = function(timerKey)
        timerKey = timerKey or "_default"
        Axiora.Conditions._timers[timerKey] = os.clock()
        return true
    end,
    
    RandomChance = function(percent)
        return math.random(1, 100) <= (percent or 50)
    end,
    
    HasTool = function(toolName)
        local LP = getLocalPlayer()
        if not LP or not LP.Character then return false end
        return LP.Character:FindFirstChild(toolName) ~= nil
    end,
    
    StaminaAbove = function(percent)
        local LP = getLocalPlayer()
        if not LP or not LP.Character then return false end
        local stamina = LP.Character:FindFirstChild("Stamina")
        if not stamina or not stamina:IsA("NumberValue") then return false end
        return (stamina.Value / 100) * 100 >= (percent or 50)
    end,
    
    IsInRegion = function(regionName)
        local LP = getLocalPlayer()
        if not LP or not LP.Character or not LP.Character.PrimaryPart then return false end
        local region = workspace:FindFirstChild(regionName)
        if not region or not region:IsA("BasePart") then return false end
        
        local playerPos = LP.Character.PrimaryPart.Position
        local regionPos = region.Position
        local regionSize = region.Size / 2
        
        return math.abs(playerPos.X - regionPos.X) <= regionSize.X
           and math.abs(playerPos.Y - regionPos.Y) <= regionSize.Y
           and math.abs(playerPos.Z - regionPos.Z) <= regionSize.Z
    end,
    
    Always = function() return true end,
    Never = function() return false end
}

-- Actions
Axiora.Actions = {
    Wait = function(duration)
        task.wait(duration or 1)
        return duration or 1
    end,
    
    MoveTo = function(position)
        local LP = getLocalPlayer()
        if not Axiora.Conditions.Checks.CharacterExists() then return 0 end
        
        local target
        if typeof(position) == "Vector3" then
            target = position
        elseif type(position) == "table" then
            target = Vector3.new(position.x or position[1] or 0, position.y or position[2] or 0, position.z or position[3] or 0)
        else
            return 0
        end
        
        LP.Character.Humanoid:MoveTo(target)
        return 0
    end,
    
    Click = function(x, y)
        local abs = Axiora.Math.GetAbsoluteInput(x, y)
        Axiora.Input.Click(abs.X, abs.Y)
        return 0.05
    end,
    
    Jump = function()
        local LP = getLocalPlayer()
        if Axiora.Conditions.Checks.CharacterExists() then
            local hum = LP.Character:FindFirstChildOfClass("Humanoid")
            if hum then hum.Jump = true end
        end
        return 0
    end,
    
    Notify = function(message, duration)
        Axiora.Visuals.Notify("Condition", message, duration or 2, "info")
        return 0
    end,
    
    SetVariable = function(name, value)
        Axiora.Conditions._variables[name] = value
        return 0
    end,
    
    GetVariable = function(name, defaultValue)
        return Axiora.Conditions._variables[name] or defaultValue
    end,
    
    Stop = function()
        Axiora.Stop()
        return 0
    end,
    
    Pause = function(duration)
        Axiora.Playback.Paused = true
        task.wait(duration or 5)
        Axiora.Playback.Paused = false
        return duration or 5
    end
}

-- Create conditional node helper
function Axiora.Conditions.CreateNode(config)
    return {
        t = 4, -- Conditional type
        d = config.delay or 0,
        condition = config.condition,
        conditionArgs = config.conditionArgs or {},
        action = config.action,
        actionArgs = config.actionArgs or {},
        elseAction = config.elseAction,
        elseActionArgs = config.elseActionArgs or {}
    }
end

-- Evaluate a condition
function Axiora.Conditions.Evaluate(conditionName, args)
    local check = Axiora.Conditions.Checks[conditionName]
    if not check then return false end
    
    local success, result = pcall(function()
        if args and #args > 0 then
            return check(table.unpack(args))
        else
            return check()
        end
    end)
    
    return success and result
end

-- Execute an action
function Axiora.Actions.Execute(actionName, args)
    local action = Axiora.Actions[actionName]
    if not action then return 0 end
    
    local success, duration = pcall(function()
        if args and #args > 0 then
            return action(table.unpack(args))
        else
            return action()
        end
    end)
    
    return success and (duration or 0) or 0
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 16: MARKED POSITIONS
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.MarkedPositions = {}

function Axiora.MarkPosition(name)
    local LP = getLocalPlayer()
    if not LP or not LP.Character or not LP.Character:FindFirstChild("HumanoidRootPart") then
        Axiora.Visuals.Notify("Mark", "No character found", 2, "error")
        return false
    end
    
    local hrp = LP.Character.HumanoidRootPart
    local pos = hrp.Position
    local cam = Workspace.CurrentCamera
    
    name = name or ("pos_" .. os.date("%H%M%S"))
    
    Axiora.MarkedPositions[name] = {
        x = pos.X,
        y = pos.Y,
        z = pos.Z,
        timestamp = os.time(),
        cameraLook = cam and {
            x = cam.CFrame.LookVector.X,
            y = cam.CFrame.LookVector.Y,
            z = cam.CFrame.LookVector.Z
        } or nil,
        placeId = game.PlaceId
    }
    
    Axiora.Visuals.Notify("Mark", "Saved: " .. name, 2, "success")
    Axiora.Events:Fire("PositionMarked", {Name = name, Position = pos})
    return true
end

function Axiora.GetMarkedPosition(name)
    local data = Axiora.MarkedPositions[name]
    if not data then return nil end
    return Vector3.new(data.x, data.y, data.z)
end

function Axiora.TeleportToMark(name)
    local pos = Axiora.GetMarkedPosition(name)
    if not pos then
        Axiora.Visuals.Notify("Mark", "Position not found: " .. tostring(name), 2, "error")
        return false
    end
    
    local LP = getLocalPlayer()
    if not LP or not LP.Character or not LP.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    LP.Character.HumanoidRootPart.CFrame = CFrame.new(pos)
    Axiora.Visuals.Notify("Mark", "Teleported to: " .. name, 2, "success")
    return true
end

function Axiora.MoveToMark(name, timeout)
    local pos = Axiora.GetMarkedPosition(name)
    if not pos then return false end
    
    local LP = getLocalPlayer()
    if not LP or not LP.Character then return false end
    
    local hum = LP.Character:FindFirstChildOfClass("Humanoid")
    if not hum then return false end
    
    hum:MoveTo(pos)
    
    if timeout then
        local conn
        local reached = false
        conn = hum.MoveToFinished:Connect(function()
            reached = true
            if conn then conn:Disconnect() end
        end)
        
        local start = os.clock()
        while not reached and (os.clock() - start) < timeout do
            task.wait(0.1)
        end
        if conn then conn:Disconnect() end
    end
    
    return true
end

function Axiora.ListMarkedPositions()
    local list = {}
    for name, data in pairs(Axiora.MarkedPositions) do
        table.insert(list, {
            Name = name,
            Position = Vector3.new(data.x, data.y, data.z),
            Timestamp = data.timestamp
        })
    end
    return list
end

function Axiora.ClearMarkedPositions()
    Axiora.MarkedPositions = {}
    Axiora.Visuals.Notify("Mark", "All positions cleared", 2, "info")
end

function Axiora.SaveMarkedPositions()
    if not Axiora.Capabilities.WriteFile then return false end
    
    local success = pcall(function()
        writefile("Axiora/markers.json", HttpService:JSONEncode(Axiora.MarkedPositions))
    end)
    
    if success then
        Axiora.Visuals.Notify("Mark", "Positions saved", 2, "success")
    end
    return success
end

function Axiora.LoadMarkedPositions()
    if not Axiora.Capabilities.ReadFile then return false end
    
    local success, data = pcall(function()
        return HttpService:JSONDecode(readfile("Axiora/markers.json"))
    end)
    
    if success and data then
        Axiora.MarkedPositions = data
        local count = 0
        for _ in pairs(data) do count = count + 1 end
        Axiora.Visuals.Notify("Mark", "Loaded " .. count .. " positions", 2, "success")
        return true
    end
    return false
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 17: ANALYTICS
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Analytics = {
    StartTime = os.clock(),
    Recording = {
        TotalSessions = 0,
        TotalNodes = 0,
        TotalDuration = 0,
        LastSessionNodes = 0,
        LastSessionDuration = 0
    },
    Playback = {
        TotalExecutions = 0,
        TotalLoops = 0,
        SuccessfulCompletions = 0,
        FailedExecutions = 0,
        TotalPlaybackTime = 0
    },
    Errors = {
        Total = 0,
        LastError = nil,
        LastErrorTime = 0
    }
}

-- Track recording
Axiora.Events:Connect("RecordingStarted", function()
    Axiora.Analytics.Recording.TotalSessions = Axiora.Analytics.Recording.TotalSessions + 1
end)

Axiora.Events:Connect("Stopped", function(data)
    if data and data.WasRecording then
        Axiora.Analytics.Recording.LastSessionNodes = #Axiora.State.Buffer
        Axiora.Analytics.Recording.TotalNodes = Axiora.Analytics.Recording.TotalNodes + #Axiora.State.Buffer
    end
end)

-- Track playback
Axiora.Events:Connect("PlaybackStarted", function()
    Axiora.Analytics.Playback.TotalExecutions = Axiora.Analytics.Playback.TotalExecutions + 1
end)

Axiora.Events:Connect("PlaybackComplete", function(data)
    if data then
        Axiora.Analytics.Playback.TotalLoops = Axiora.Analytics.Playback.TotalLoops + (data.Loops or 1)
        if data.NodesPlayed >= (data.TotalNodes or 1) * 0.9 then
            Axiora.Analytics.Playback.SuccessfulCompletions = Axiora.Analytics.Playback.SuccessfulCompletions + 1
        else
            Axiora.Analytics.Playback.FailedExecutions = Axiora.Analytics.Playback.FailedExecutions + 1
        end
    end
end)

-- Track errors
Axiora.Events:Connect("Error", function(data)
    Axiora.Analytics.Errors.Total = Axiora.Analytics.Errors.Total + 1
    Axiora.Analytics.Errors.LastError = data and data.Message or "Unknown"
    Axiora.Analytics.Errors.LastErrorTime = os.clock()
end)

function Axiora.Analytics.GetUptime()
    return os.clock() - Axiora.Analytics.StartTime
end

function Axiora.Analytics.GetUptimeFormatted()
    local uptime = Axiora.Analytics.GetUptime()
    local hours = math.floor(uptime / 3600)
    local mins = math.floor((uptime % 3600) / 60)
    local secs = math.floor(uptime % 60)
    return string.format("%02d:%02d:%02d", hours, mins, secs)
end

function Axiora.Analytics.GetSuccessRate()
    local total = Axiora.Analytics.Playback.SuccessfulCompletions + Axiora.Analytics.Playback.FailedExecutions
    if total == 0 then return 100 end
    return math.floor((Axiora.Analytics.Playback.SuccessfulCompletions / total) * 100)
end

function Axiora.Analytics.GetReport()
    return {
        System = {
            Uptime = Axiora.Analytics.GetUptime(),
            UptimeFormatted = Axiora.Analytics.GetUptimeFormatted(),
            Executor = Axiora.Capabilities.Executor,
            InputMethod = Axiora.Input.Method
        },
        Recording = Axiora.Analytics.Recording,
        Playback = {
            TotalExecutions = Axiora.Analytics.Playback.TotalExecutions,
            TotalLoops = Axiora.Analytics.Playback.TotalLoops,
            SuccessfulCompletions = Axiora.Analytics.Playback.SuccessfulCompletions,
            FailedExecutions = Axiora.Analytics.Playback.FailedExecutions,
            SuccessRatePercent = Axiora.Analytics.GetSuccessRate()
        },
        Errors = Axiora.Analytics.Errors,
        CurrentState = {
            Status = Axiora.State.Status,
            BufferSize = #Axiora.State.Buffer,
            SequenceQueueSize = #Axiora.Sequences.Queue
        }
    }
end

function Axiora.Analytics.Print()
    local report = Axiora.Analytics.GetReport()
    print("========== AXIORA ANALYTICS ==========")
    print("Uptime: " .. report.System.UptimeFormatted)
    print("Executor: " .. report.System.Executor)
    print("")
    print("Recording Sessions: " .. report.Recording.TotalSessions)
    print("Total Nodes Recorded: " .. report.Recording.TotalNodes)
    print("")
    print("Playback Executions: " .. report.Playback.TotalExecutions)
    print("Success Rate: " .. report.Playback.SuccessRatePercent .. "%")
    print("Total Loops: " .. report.Playback.TotalLoops)
    print("")
    print("Total Errors: " .. report.Errors.Total)
    print("Current Buffer: " .. report.CurrentState.BufferSize .. " nodes")
    print("=======================================")
end

function Axiora.Analytics.Export()
    if not Axiora.Capabilities.WriteFile then
        Axiora.Visuals.Notify("Analytics", "Cannot export - no file system", 3, "error")
        return false
    end
    
    local report = Axiora.Analytics.GetReport()
    local filename = "Axiora/analytics_" .. os.time() .. ".json"
    
    local success = pcall(function()
        writefile(filename, HttpService:JSONEncode(report))
    end)
    
    if success then
        Axiora.Visuals.Notify("Analytics", "Exported to: " .. filename, 3, "success")
    end
    return success
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 18: CALIBRATION
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Calibration = {
    Active = false,
    XOffset = 0,
    YOffset = 0
}

function Axiora.Calibration.SetOffsets(x, y)
    Axiora.Settings.XOffset = x or 0
    Axiora.Settings.YOffset = y or 0
    Axiora.Calibration.XOffset = x or 0
    Axiora.Calibration.YOffset = y or 0
    Axiora.Visuals.Notify("Calibration", "Offsets set: X=" .. x .. ", Y=" .. y, 2, "success")
end

function Axiora.Calibration.GetOffsets()
    return {
        X = Axiora.Settings.XOffset,
        Y = Axiora.Settings.YOffset
    }
end

function Axiora.Calibration.Reset()
    Axiora.Settings.XOffset = 0
    Axiora.Settings.YOffset = 0
    Axiora.Calibration.XOffset = 0
    Axiora.Calibration.YOffset = 0
    Axiora.Visuals.Notify("Calibration", "Offsets reset to 0", 2, "info")
end

function Axiora.Calibration.AutoDetect()
    -- Simple auto-detection based on screen size
    Axiora.Math.UpdateScreenMetrics()
    local screen = Axiora.Math.Screen.Viewport
    
    -- Some common resolution adjustments
    if screen.X < 1280 then
        -- Lower resolution - might need offset
        Axiora.Calibration.SetOffsets(0, 0)
    elseif screen.X > 1920 then
        -- Higher resolution
        Axiora.Calibration.SetOffsets(0, 0)
    else
        -- Standard 1080p
        Axiora.Calibration.SetOffsets(0, 0)
    end
    
    Axiora.Visuals.Notify("Calibration", "Auto-detected for " .. math.floor(screen.X) .. "x" .. math.floor(screen.Y), 2, "info")
end

function Axiora.Calibration.SaveCalibration()
    if not Axiora.Capabilities.WriteFile then return false end
    
    local data = {
        XOffset = Axiora.Settings.XOffset,
        YOffset = Axiora.Settings.YOffset,
        PlaceId = game.PlaceId,
        Resolution = {
            X = Axiora.Math.Screen.Viewport.X,
            Y = Axiora.Math.Screen.Viewport.Y
        }
    }
    
    return pcall(function()
        writefile("Axiora/calibration.json", HttpService:JSONEncode(data))
    end)
end

function Axiora.Calibration.LoadCalibration()
    if not Axiora.Capabilities.ReadFile then return false end
    
    local success, data = pcall(function()
        return HttpService:JSONDecode(readfile("Axiora/calibration.json"))
    end)
    
    if success and data then
        Axiora.Calibration.SetOffsets(data.XOffset or 0, data.YOffset or 0)
        return true
    end
    return false
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- INTERACTIVE CALIBRATION SYSTEM (New)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Calibration.Phase1UI = nil
Axiora.Calibration.Phase2UI = nil
Axiora.Calibration.TempOffset = Vector2.new(0, 0)
Axiora.Calibration.CurrentOffset = Vector2.new(0, 0)
Axiora.Calibration.GreenTarget = nil
Axiora.Calibration.RedPredictor = nil
Axiora.Calibration.IsCalibrating = false

-- Get environment fingerprint for detecting changes
function Axiora.Calibration.GetEnvironmentFingerprint()
    local viewport = Axiora.Math.Screen.Viewport
    local inset = Axiora.Math.Screen.GuiInset
    
    local screenScale = 1.0
    pcall(function()
        if GuiService and GuiService.GetResolutionScale then
            screenScale = GuiService:GetResolutionScale()
        end
    end)
    
    return {
        Executor = Axiora.Capabilities.Executor,
        ViewportX = math.floor(viewport.X),
        ViewportY = math.floor(viewport.Y),
        GuiInsetX = math.floor(inset.X),
        GuiInsetY = math.floor(inset.Y),
        ScreenScale = screenScale,
        PlaceId = game.PlaceId
    }
end

-- Check if environment changed since last calibration
function Axiora.Calibration.HasEnvironmentChanged(savedEnv)
    if not savedEnv then return true end
    
    local current = Axiora.Calibration.GetEnvironmentFingerprint()
    
    if current.Executor ~= savedEnv.Executor then return true end
    if current.ViewportX ~= savedEnv.ViewportX then return true end
    if current.ViewportY ~= savedEnv.ViewportY then return true end
    if math.abs((current.GuiInsetY or 0) - (savedEnv.GuiInsetY or 0)) > 2 then return true end
    
    return false
end

-- Check if calibration is needed
function Axiora.Calibration.CheckNeeded()
    if not Axiora.Capabilities.ReadFile then return true end
    
    local success, exists = pcall(function()
        return isfile("Axiora/calibration.json")
    end)
    
    if not success or not exists then return true end
    
    local loadSuccess, data = pcall(function()
        return HttpService:JSONDecode(readfile("Axiora/calibration.json"))
    end)
    
    if not loadSuccess or not data then return true end
    
    if Axiora.Calibration.HasEnvironmentChanged(data.Environment) then
        return true
    end
    
    -- Load existing calibration
    Axiora.Settings.XOffset = data.OffsetX or 0
    Axiora.Settings.YOffset = data.OffsetY or 0
    return false
end

-- Main entry point for calibration
function Axiora.Calibration.StartInteractiveCalibration()
    if Axiora.Calibration.IsCalibrating then return end
    
    -- Race condition fix: Ensure UI exists
    if not Axiora.UI.ScreenGui then 
        Axiora.Visuals.Notify("Calibration", "UI not ready - Please wait...", 2, "warning")
        return 
    end
    
    Axiora.Calibration.IsCalibrating = true
    
    Axiora.Math.WaitForInit(2)
    
    -- FIX: Use existing ScreenGui or wait for it
    local sg = Axiora.UI.ScreenGui or Axiora.Visuals.ScreenGui
    if not sg then
        -- Wait for main UI to initialize
        local maxWait = 3
        local waited = 0
        while not Axiora.UI.ScreenGui and not Axiora.Visuals.ScreenGui and waited < maxWait do
            task.wait(0.2)
            waited = waited + 0.2
        end
        sg = Axiora.UI.ScreenGui or Axiora.Visuals.ScreenGui
    end
    
    if not sg then
        -- Last resort: create minimal ScreenGui
        sg = Instance.new("ScreenGui")
        sg.Name = "AxioraCalibration"
        sg.IgnoreGuiInset = true
        sg.ResetOnSpawn = false
        sg.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        sg.DisplayOrder = 9999
        pcall(function() sg.Parent = CoreGui end)
        if not sg.Parent then
            local LP = getLocalPlayer()
            if LP then sg.Parent = LP:FindFirstChild("PlayerGui") end
        end
        Axiora.UI.ScreenGui = sg
    end
    
    task.wait(0.3)
    Axiora.Calibration.StartPhase1(sg)
end

-- PHASE 1: Coarse Auto-Detection
-- ═══════════════════════════════════════════════════════════════════════════════
-- HOLOGRAPHIC CALIBRATION SYSTEM (v2.0)
-- ═══════════════════════════════════════════════════════════════════════════════

function Axiora.Calibration.ShowOverlay()
    local sg = Axiora.UI.ScreenGui or Axiora.Visuals.ScreenGui
    if not sg then return end
    
    if Axiora.Calibration.Overlay then
        Axiora.Calibration.Overlay:Destroy()
    end
    
    Axiora.Calibration.IsCalibrating = true
    local vp = Axiora.Math.Screen.Viewport
    
    -- 1. Dark Acrylic Backdrop
    local overlay = Instance.new("Frame")
    overlay.Name = "CalibrationOverlay"
    overlay.BackgroundColor3 = Color3.fromRGB(10, 10, 15)
    overlay.BackgroundTransparency = 0.2
    overlay.Size = UDim2.new(1, 0, 1, 0)
    overlay.ZIndex = 2000
    overlay.Parent = sg
    
    -- Add blur effect if supported (e.g. via Lighting, but we can't easily add to Lighting from here)
    -- Just use dark transparent overlay for focus
    
    Axiora.Calibration.Overlay = overlay
    
    -- 2. Neon Crosshair (Center)
    local reticle = Instance.new("Frame")
    reticle.Name = "Reticle"
    reticle.Size = UDim2.new(0, 120, 0, 120)
    reticle.Position = UDim2.new(0.5, 0, 0.5, 0)
    reticle.AnchorPoint = Vector2.new(0.5, 0.5)
    reticle.BackgroundTransparency = 1
    reticle.ZIndex = 2001
    reticle.Parent = overlay
    
    -- Rotating outer ring
    local ring = Instance.new("ImageLabel")
    ring.Image = "rbxassetid://3570695787" -- Circle ring asset
    ring.ImageColor3 = Color3.fromRGB(0, 255, 255) -- Cyan
    ring.BackgroundTransparency = 1
    ring.Size = UDim2.new(1, 0, 1, 0)
    ring.Parent = reticle
    
    -- Inner dot
    local dot = Instance.new("Frame")
    dot.BackgroundColor3 = Color3.fromRGB(255, 50, 80)
    dot.Size = UDim2.new(0, 8, 0, 8)
    dot.Position = UDim2.new(0.5, 0, 0.5, 0)
    dot.AnchorPoint = Vector2.new(0.5, 0.5)
    dot.Parent = reticle
    Instance.new("UICorner", dot).CornerRadius = UDim.new(1, 0)
    
    -- Animate Reticle
    task.spawn(function()
        local rot = 0
        while overlay and overlay.Parent do
            rot = rot + 2
            ring.Rotation = rot
            task.wait(0.03)
        end
    end)
    
    -- 3. Floating Controls (Bottom)
    local controlsPanel = Instance.new("Frame")
    controlsPanel.Name = "ControlsPanel"
    controlsPanel.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
    controlsPanel.BackgroundTransparency = 0.1
    controlsPanel.Size = UDim2.new(0, 400, 0, 100)
    controlsPanel.Position = UDim2.new(0.5, 0, 0.85, 0) -- Near bottom
    controlsPanel.AnchorPoint = Vector2.new(0.5, 0.5)
    controlsPanel.Parent = overlay
    Instance.new("UICorner", controlsPanel).CornerRadius = UDim.new(0, 16)
    
    -- Title
    local title = Instance.new("TextLabel")
    title.Text = "CALIBRATION MODE"
    title.TextColor3 = Color3.fromRGB(0, 255, 255)
    title.Font = Enum.Font.GothamBlack
    title.TextSize = 14
    title.BackgroundTransparency = 1
    title.Size = UDim2.new(1, 0, 0, 24)
    title.Position = UDim2.new(0, 0, 0, 10)
    title.Parent = controlsPanel
    
    -- Slider Logic
    local currentOffset = Axiora.Settings.XOffset or 0
    local sliderTrack = Instance.new("Frame")
    sliderTrack.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
    sliderTrack.Size = UDim2.new(0.8, 0, 0, 8)
    sliderTrack.Position = UDim2.new(0.1, 0, 0.5, 0)
    sliderTrack.Parent = controlsPanel
    Instance.new("UICorner", sliderTrack).CornerRadius = UDim.new(1, 0)
    
    local knob = Instance.new("Frame")
    knob.BackgroundColor3 = Color3.fromRGB(0, 255, 255)
    knob.Size = UDim2.new(0, 20, 0, 20)
    knob.AnchorPoint = Vector2.new(0.5, 0.5)
    knob.Parent = sliderTrack
    Instance.new("UICorner", knob).CornerRadius = UDim.new(1, 0)
    
    local valueLabel = Instance.new("TextLabel")
    valueLabel.Text = currentOffset .. " px"
    valueLabel.TextColor3 = Color3.new(1, 1, 1)
    valueLabel.Font = Enum.Font.GothamBold
    valueLabel.TextSize = 20
    valueLabel.BackgroundTransparency = 1
    valueLabel.Position = UDim2.new(0.5, 0, 0.7, 0)
    valueLabel.AnchorPoint = Vector2.new(0.5, 0)
    valueLabel.Parent = controlsPanel
    
    local function updateSliderVisuals()
        local min, max = -50, 50
        local pct = (currentOffset - min) / (max - min)
        pct = math.clamp(pct, 0, 1)
        knob.Position = UDim2.new(pct, 0, 0.5, 0)
        valueLabel.Text = (currentOffset > 0 and "+" or "") .. math.floor(currentOffset) .. " px"
        Axiora.Settings.XOffset = currentOffset -- Live update
    end
    
    updateSliderVisuals()
    
    -- Slider Interaction
    local dragging = false
    knob.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
        end
    end)
    
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local pos = input.Position.X
            local startX = sliderTrack.AbsolutePosition.X
            local width = sliderTrack.AbsoluteSize.X
            local rel = math.clamp((pos - startX) / width, 0, 1)
            
            -- Map 0-1 to -50 to +50
            currentOffset = math.floor((rel * 100) - 50)
            updateSliderVisuals()
        end
    end)
    
    -- 4. Interactive Test (Click Anywhere)
    local clickConn
    clickConn = overlay.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            -- Ignore clicks on the panel itself
    -- (Actually overlay is full screen, so we check if mouse is over panel)
            local mPos = UserInputService:GetMouseLocation()
            local pPos = controlsPanel.AbsolutePosition
            local pSize = controlsPanel.AbsoluteSize
            
            if mPos.X >= pPos.X and mPos.X <= pPos.X + pSize.X and
               mPos.Y >= pPos.Y and mPos.Y <= pSize.Y + pPos.Y then
                return -- Clicked on panel
            end
            
            -- VISUALIZE ACCURACY
            -- 1. Where user clicked (Real intent)
            local intentPos = mPos
            
            -- 2. Where script would click with current offset
            -- Script adds XOffset to input. So if we input X, script clicks X + Offset?
            -- Wait. GetAbsoluteInput REVERSES the logic presumably?
            -- No, GetAbsoluteInput converts relative (0-1) to screen coords.
            -- Axiora.Input.Click takes coordinates.
            -- The Offset is ADDED to the coordinate before clicking.
            -- So if I intend to click at 100, and Offset is +10, script clicks 110.
            -- So the "Actual Landing" is Intent + Offset.
            
            local landingX = intentPos.X + currentOffset
            local landingY = intentPos.Y -- Y is not offset
            
            -- Show RIPPLE at Landing
            if Axiora.Visuals.Ripple then
                task.spawn(function() Axiora.Visuals.Ripple(landingX, landingY) end)
            end
            
            -- Show GHOST DOT at Intent (Green = Good, Red = Drift)
            local ghost = Instance.new("Frame")
            ghost.Size = UDim2.new(0, 10, 0, 10)
            ghost.Position = UDim2.new(0, intentPos.X, 0, intentPos.Y)
            ghost.AnchorPoint = Vector2.new(0.5, 0.5)
            ghost.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            ghost.BackgroundTransparency = 0.5
            ghost.Parent = overlay
            Instance.new("UICorner", ghost).CornerRadius = UDim.new(1, 0)
            
            -- Connect them with a line if offset is significant
            if math.abs(currentOffset) > 2 then
                local line = Instance.new("Frame")
                line.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
                line.BorderSizePixel = 0
                line.Size = UDim2.new(0, math.abs(currentOffset), 0, 2)
                -- Position between points
                local midX = (intentPos.X + landingX) / 2
                line.Position = UDim2.new(0, midX, 0, intentPos.Y)
                line.AnchorPoint = Vector2.new(0.5, 0.5)
                line.Parent = overlay
                task.delay(1, function() line:Destroy() end)
            end
            
            task.delay(1, function() ghost:Destroy() end)
        end
    end)
    
    -- 5. Save & Exit Button
    local saveBtn = Instance.new("TextButton")
    saveBtn.Text = "SAVE & CLOSE"
    saveBtn.BackgroundColor3 = Color3.fromRGB(0, 200, 100)
    saveBtn.Size = UDim2.new(0, 120, 0, 30)
    saveBtn.Position = UDim2.new(0.95, 0, 0.1, 0) -- Top right
    saveBtn.AnchorPoint = Vector2.new(0.95, 0.1)
    saveBtn.Parent = overlay
    Instance.new("UICorner", saveBtn).CornerRadius = UDim.new(0, 8)
    
    saveBtn.MouseButton1Click:Connect(function()
        Axiora.Calibration.SaveCalibrationData()
    end)
end

function Axiora.Calibration.StartInteractiveCalibration()
    Axiora.Calibration.ShowOverlay()
end

function Axiora.Calibration.SaveCalibrationData()
    if Axiora.Calibration.Overlay then
        Axiora.Calibration.Overlay:Destroy()
        Axiora.Calibration.Overlay = nil
    end
    Axiora.Calibration.IsCalibrating = false
    
    -- Save to file logic
    local saveData = {
        OffsetX = Axiora.Settings.XOffset,
        Timestamp = os.time()
    }
    
    if Axiora.Capabilities.WriteFile then
        pcall(function()
            if not isfolder("Axiora") then makefolder("Axiora") end
            writefile("Axiora/calibration.json", HttpService:JSONEncode(saveData))
        end)
    end
    
    if Axiora.Visuals and Axiora.Visuals.Notify then
        Axiora.Visuals.Notify("Calibration", "Offsets Saved", 2, "success")
    end
end

function Axiora.Recalibrate()
    Axiora.Calibration.StartInteractiveCalibration()
end


-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 19: AUTOMATION ENGINE (Visual Scripting)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Automation = {
    Rules = {},
    MaxRules = 50,
    Running = false,
    SessionStartTime = os.time(),
    LastChat = {message = "", sender = "", time = 0},
    EvaluatorThread = nil,
    
    -- Debounce and connection tracking
    _debounceTimers = {},
    _connections = {},
    DebounceDuration = 0.5,
    
    -- Rule modes
    MODE_PLAYBACK = "playback",
    MODE_ALWAYS = "always",
    MODE_DISABLED = "disabled"
}

-- Generate unique rule ID
function Axiora.Automation.GenerateId()
    return "rule_" .. tostring(os.time()) .. "_" .. tostring(math.random(1000, 9999))
end

-- Create a new rule
function Axiora.Automation.CreateRule(trigger, condition, action, mode)
    if #Axiora.Automation.Rules >= Axiora.Automation.MaxRules then
        Axiora.Visuals.Notify("Automation", "Max rules reached (50)", 3, "error")
        return nil
    end
    
    local rule = {
        id = Axiora.Automation.GenerateId(),
        enabled = true,
        mode = mode or Axiora.Automation.MODE_PLAYBACK,
        trigger = trigger,
        condition = condition,
        action = action,
        lastTriggered = 0,
        triggerCount = 0
    }
    
    table.insert(Axiora.Automation.Rules, rule)
    Axiora.Automation.SaveRules()
    
    if #Axiora.Automation.Rules >= 40 then
        Axiora.Visuals.Notify("Automation", "Approaching limit (" .. #Axiora.Automation.Rules .. "/50)", 2, "warning")
    end
    
    return rule
end

-- Delete a rule by ID
function Axiora.Automation.DeleteRule(ruleId)
    for i, rule in ipairs(Axiora.Automation.Rules) do
        if rule.id == ruleId then
            table.remove(Axiora.Automation.Rules, i)
            Axiora.Automation.SaveRules()
            return true
        end
    end
    return false
end

-- Toggle rule enabled/disabled
function Axiora.Automation.ToggleRule(ruleId)
    for _, rule in ipairs(Axiora.Automation.Rules) do
        if rule.id == ruleId then
            rule.enabled = not rule.enabled
            Axiora.Automation.SaveRules()
            return rule.enabled
        end
    end
    return nil
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- TRIGGERS (5)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Automation.Triggers = {
    -- Every X seconds
    interval = function(rule, params)
        local interval = params.seconds or 60
        local now = os.clock()
        if now - (rule.lastTriggered or 0) >= interval then
            rule.lastTriggered = now
            return true
        end
        return false
    end,
    
    -- When player joins (checked via _lastPlayerCount)
    playerJoin = function(rule, params)
        local currentCount = #Players:GetPlayers()
        local lastCount = Axiora.Automation._lastPlayerCount or currentCount
        if currentCount > lastCount then
            return true
        end
        return false
    end,
    
    -- When player leaves
    playerLeave = function(rule, params)
        local currentCount = #Players:GetPlayers()
        local lastCount = Axiora.Automation._lastPlayerCount or currentCount
        if currentCount < lastCount then
            return true
        end
        return false
    end,
    
    -- When chat message received
    chatReceived = function(rule, params)
        local lastChat = Axiora.Automation.LastChat
        if lastChat.time > (rule.lastChatTime or 0) then
            rule.lastChatTime = lastChat.time
            return true
        end
        return false
    end,
    
    -- When macro completes
    macroComplete = function(rule, params)
        if Axiora.State._macroJustCompleted then
            return true
        end
        return false
    end,
    
    -- Always trigger (for pure condition-based)
    always = function(rule, params)
        return true
    end,
    
    -- PHASE 2 TRIGGERS --
    
    -- When key is pressed
    keyPressed = function(rule, params)
        local targetKey = params.key or "E"
        if Axiora.Automation._lastKeyPressed == targetKey then
            Axiora.Automation._lastKeyPressed = nil
            return true
        end
        return false
    end,
    
    -- When health is low
    healthLow = function(rule, params)
        local threshold = params.threshold or 30
        local LP = getLocalPlayer()
        if not LP or not LP.Character then return false end
        
        local humanoid = LP.Character:FindFirstChildOfClass("Humanoid")
        if humanoid and humanoid.Health > 0 then
            local healthPercent = (humanoid.Health / humanoid.MaxHealth) * 100
            if healthPercent < threshold and not rule._healthTriggered then
                rule._healthTriggered = true
                return true
            elseif healthPercent >= threshold then
                rule._healthTriggered = false
            end
        end
        return false
    end,
    
    -- When character dies
    onDeath = function(rule, params)
        local LP = getLocalPlayer()
        if not LP or not LP.Character then return false end
        
        local humanoid = LP.Character:FindFirstChildOfClass("Humanoid")
        if humanoid and humanoid.Health <= 0 and not rule._deathTriggered then
            rule._deathTriggered = true
            return true
        elseif humanoid and humanoid.Health > 0 then
            rule._deathTriggered = false
        end
        return false
    end,
    
    -- After N macro loops
    loopCount = function(rule, params)
        local targetLoops = params.loops or 5
        local currentLoops = Axiora.State.LoopCount or 0
        if currentLoops >= targetLoops and currentLoops > (rule._lastLoopCheck or 0) then
            rule._lastLoopCheck = currentLoops
            return true
        end
        return false
    end
}

-- ═══════════════════════════════════════════════════════════════════════════════
-- CONDITIONS (8)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Automation.Conditions = {
    -- Player count comparison
    playerCount = function(params)
        local count = #Players:GetPlayers()
        local op = params.operator or ">"
        local value = params.value or 5
        
        if op == ">" then return count > value
        elseif op == "<" then return count < value
        elseif op == "=" or op == "==" then return count == value
        elseif op == ">=" then return count >= value
        elseif op == "<=" then return count <= value
        end
        return false
    end,
    
    -- Nearest player distance
    playerDistance = function(params)
        local maxDist = params.distance or 50
        local op = params.operator or "<"
        local LP = getLocalPlayer()
        if not LP or not LP.Character then return false end
        
        local myPos = LP.Character:GetPivot().Position
        local nearestDist = math.huge
        
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LP and player.Character then
                local dist = (player.Character:GetPivot().Position - myPos).Magnitude
                if dist < nearestDist then nearestDist = dist end
            end
        end
        
        if op == "<" then return nearestDist < maxDist
        elseif op == ">" then return nearestDist > maxDist
        end
        return false
    end,
    
    -- Position Y (void detection)
    positionY = function(params)
        local threshold = params.value or -50
        local op = params.operator or "<"
        local LP = getLocalPlayer()
        if not LP or not LP.Character then return false end
        
        local y = LP.Character:GetPivot().Position.Y
        
        if op == "<" then return y < threshold
        elseif op == ">" then return y > threshold
        end
        return false
    end,
    
    -- Session time (minutes)
    sessionTime = function(params)
        local minutes = params.value or 30
        local op = params.operator or ">"
        local elapsed = (os.time() - Axiora.Automation.SessionStartTime) / 60
        
        if op == ">" then return elapsed > minutes
        elseif op == "<" then return elapsed < minutes
        end
        return false
    end,
    
    -- Specific player name exists
    playerName = function(params)
        local targetName = params.name or ""
        local checkType = params.type or "exists" -- exists, joined, left
        
        for _, player in ipairs(Players:GetPlayers()) do
            if string.lower(player.Name) == string.lower(targetName) or
               string.lower(player.DisplayName) == string.lower(targetName) then
                return true
            end
        end
        return false
    end,
    
    -- Chat contains text
    chatContains = function(params)
        local text = params.text or ""
        local lastChat = Axiora.Automation.LastChat
        if lastChat.message and string.find(string.lower(lastChat.message), string.lower(text)) then
            return true
        end
        return false
    end,
    
    -- Always true (skip condition)
    always = function(params)
        return true
    end,
    
    -- Random chance (percentage)
    randomChance = function(params)
        local percent = params.percent or 50
        return math.random(100) <= percent
    end,
    
    -- PHASE 2 CONDITIONS --
    
    -- Health below percentage
    healthBelow = function(params)
        local threshold = params.percent or 50
        local LP = getLocalPlayer()
        if not LP or not LP.Character then return false end
        
        local humanoid = LP.Character:FindFirstChildOfClass("Humanoid")
        if humanoid and humanoid.MaxHealth > 0 then
            local healthPercent = (humanoid.Health / humanoid.MaxHealth) * 100
            return healthPercent < threshold
        end
        return false
    end,
    
    -- Character is moving
    isMoving = function(params)
        local LP = getLocalPlayer()
        if not LP or not LP.Character then return false end
        
        local humanoid = LP.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            return humanoid.MoveDirection.Magnitude > 0.1
        end
        return false
    end,
    
    -- Buffer has N or more nodes
    bufferSize = function(params)
        local minSize = params.value or 10
        local op = params.operator or ">"
        local size = #Axiora.State.Buffer
        
        if op == ">" then return size > minSize
        elseif op == "<" then return size < minSize
        elseif op == "=" or op == "==" then return size == minSize
        end
        return false
    end
}

-- ═══════════════════════════════════════════════════════════════════════════════
-- ACTIONS (7 + Phase 2)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Automation.Actions = {
    -- Play macro by name
    playMacro = function(params)
        local name = params.name or ""
        if name ~= "" and Axiora.Load then
            task.spawn(function()
                Axiora.Load(name)
                task.wait(0.5)
                if Axiora.Play then Axiora.Play() end
            end)
        end
    end,
    
    -- Stop/Pause current macro
    stopMacro = function(params)
        if Axiora.Stop then Axiora.Stop() end
    end,
    
    -- Wait N seconds (for chaining)
    wait = function(params)
        local seconds = params.seconds or 1
        task.wait(seconds)
    end,
    
    -- Send chat message
    sendChat = function(params)
        local message = params.message or "Hello"
        pcall(function()
            local LP = getLocalPlayer()
            if LP then
                local chatService = game:GetService("TextChatService")
                local channels = chatService:FindFirstChild("TextChannels")
                if channels then
                    local general = channels:FindFirstChild("RBXGeneral")
                    if general then
                        general:SendAsync(message)
                    end
                end
            end
        end)
    end,
    
    -- Leave server
    leaveServer = function(params)
        task.spawn(function()
            Axiora.Visuals.Notify("Automation", "Leaving server...", 2, "info")
            task.wait(1)
            pcall(function()
                game:GetService("TeleportService"):Teleport(game.PlaceId)
            end)
        end)
    end,
    
    -- Rejoin server
    rejoinServer = function(params)
        task.spawn(function()
            Axiora.Visuals.Notify("Automation", "Rejoining...", 2, "info")
            task.wait(1)
            pcall(function()
                game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId)
            end)
        end)
    end,
    
    -- Show notification
    notify = function(params)
        local title = params.title or "Automation"
        local message = params.message or "Rule triggered"
        Axiora.Visuals.Notify(title, message, 3, "info")
    end,
    
    -- PHASE 2 ACTIONS --
    
    -- Jump
    jump = function(params)
        local LP = getLocalPlayer()
        if not LP or not LP.Character then return end
        
        local humanoid = LP.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.Jump = true
        end
    end,
    
    -- Pause macro (not stop)
    pauseMacro = function(params)
        if Axiora.State.Status == "PLAYING" then
            Axiora.State.Status = "PAUSED"
            Axiora.Visuals.Notify("Automation", "Macro paused", 2, "info")
        end
    end,
    
    -- Resume macro
    resumeMacro = function(params)
        if Axiora.State.Status == "PAUSED" then
            Axiora.State.Status = "PLAYING"
            Axiora.Visuals.Notify("Automation", "Macro resumed", 2, "info")
        end
    end,
    
    -- Reset and restart current macro
    resetMacro = function(params)
        if Axiora.Stop then Axiora.Stop() end
        task.wait(0.5)
        if Axiora.Play then Axiora.Play() end
    end
}

-- ═══════════════════════════════════════════════════════════════════════════════
-- RULE EVALUATOR
-- ═══════════════════════════════════════════════════════════════════════════════

function Axiora.Automation.EvaluateRule(rule)
    if not rule.enabled then return false end
    
    -- Check mode
    local isPlaying = Axiora.State.Status == "PLAYING"
    if rule.mode == Axiora.Automation.MODE_PLAYBACK and not isPlaying then
        return false
    elseif rule.mode == Axiora.Automation.MODE_DISABLED then
        return false
    end
    
    -- Debounce check (prevent rapid re-triggering)
    local now = os.clock()
    local debounceDuration = rule.debounce or Axiora.Automation.DebounceDuration or 0.5
    local lastFire = Axiora.Automation._debounceTimers[rule.id] or 0
    if now - lastFire < debounceDuration then
        return false
    end
    
    -- Dependency check (rule only runs if dependent rule has fired)
    if rule.dependsOn then
        local depFired = false
        for _, r in ipairs(Axiora.Automation.Rules) do
            if r.id == rule.dependsOn and (r.triggerCount or 0) > 0 then
                depFired = true
                break
            end
        end
        if not depFired then
            return false
        end
    end
    
    -- Check trigger
    local triggerFunc = Axiora.Automation.Triggers[rule.trigger.type]
    if not triggerFunc then return false end
    if not triggerFunc(rule, rule.trigger) then return false end
    
    -- Check condition
    local conditionFunc = Axiora.Automation.Conditions[rule.condition.type]
    if conditionFunc and not conditionFunc(rule.condition) then return false end
    
    -- INFINITE LOOP PROTECTION
    -- Count recent triggers
    rule.recentTriggers = rule.recentTriggers or {}
    local recentCount = 0
    for i = #rule.recentTriggers, 1, -1 do
        if now - rule.recentTriggers[i] > 10 then
            table.remove(rule.recentTriggers, i)
        else
            recentCount = recentCount + 1
        end
    end
    
    if recentCount >= 5 then
        Axiora.Visuals.Notify("Automation", "Rule spam detected: " .. (rule.name or rule.id), 5, "warning")
        return false -- Prevent execution
    end
    
    -- Execute action
    local actionFunc = Axiora.Automation.Actions[rule.action.type]
    if actionFunc then
        -- Update debounce timer
        Axiora.Automation._debounceTimers[rule.id] = now
        rule.triggerCount = (rule.triggerCount or 0) + 1
        table.insert(rule.recentTriggers, now) -- Track for spam protection
        
        task.spawn(function()
            -- Add small delay to prevent instant loops
            task.wait(0.1)
            actionFunc(rule.action)
        end)
        return true
    end
    
    return false
end

function Axiora.Automation.StartEvaluator()
    if Axiora.Automation.Running then return end
    Axiora.Automation.Running = true
    Axiora.Automation._lastPlayerCount = #Players:GetPlayers()
    
    -- Clear previous connections and reset state
    Axiora.Automation._connections = {}
    Axiora.Automation._debounceTimers = {}
    
    -- Chat listener
    pcall(function()
        local chatService = game:GetService("TextChatService")
        local chatConn = chatService.MessageReceived:Connect(function(msg)
            Axiora.Automation.LastChat = {
                message = msg.Text or "",
                sender = msg.TextSource and msg.TextSource.Name or "Unknown",
                time = os.clock()
            }
        end)
        table.insert(Axiora.Automation._connections, chatConn)
    end)
    
    -- Key press listener (for keyPressed trigger)
    pcall(function()
        local keyConn = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if input.UserInputType == Enum.UserInputType.Keyboard then
                Axiora.Automation._lastKeyPressed = input.KeyCode.Name
            end
        end)
        table.insert(Axiora.Automation._connections, keyConn)
    end)
    
    -- Main evaluator loop
    Axiora.Automation.EvaluatorThread = task.spawn(function()
        while Axiora.Automation.Running do
            for _, rule in ipairs(Axiora.Automation.Rules) do
                pcall(function()
                    Axiora.Automation.EvaluateRule(rule)
                end)
            end
            
            -- Update player count tracker
            Axiora.Automation._lastPlayerCount = #Players:GetPlayers()
            
            -- Reset macro complete flag
            Axiora.State._macroJustCompleted = false
            
            task.wait(0.5) -- Check every 0.5 seconds
        end
    end)
end

function Axiora.Automation.StopEvaluator()
    Axiora.Automation.Running = false
    
    -- Clean up all connections to prevent memory leaks
    for _, conn in ipairs(Axiora.Automation._connections or {}) do
        pcall(function() conn:Disconnect() end)
    end
    Axiora.Automation._connections = {}
    
    -- Reset debounce timers
    Axiora.Automation._debounceTimers = {}
end

function Axiora.Automation.ShowRuleCreationModal(parent, onCreated)
    local theme = Axiora.UI.Theme or Axiora.Visuals.GetTheme()
    
    local modal = Instance.new("Frame")
    modal.Name = "RuleCreationModal"
    modal.BackgroundColor3 = Color3.new(0,0,0)
    modal.BackgroundTransparency = 0.5
    modal.Size = UDim2.new(1, 0, 1, 0)
    modal.ZIndex = 100
    modal.Parent = parent
    
    local panel = Axiora.UI.Primitives.CreateHoloPanel(modal, UDim2.new(0, 300, 0, 380), UDim2.new(0.5, 0, 0.5, 0))
    panel.AnchorPoint = Vector2.new(0.5, 0.5)
    
    -- Title
    Axiora.UI.Primitives.CreateNeonText(panel, "CREATE NEW RULE", 18, theme.Success).Position = UDim2.new(0, 20, 0, 15)
    
    -- Inputs Container
    local container = Instance.new("ScrollingFrame")
    container.BackgroundTransparency = 1
    container.Size = UDim2.new(1, -40, 0, 260)
    container.Position = UDim2.new(0, 20, 0, 50)
    container.CanvasSize = UDim2.new(0, 0, 0, 400)
    container.ScrollBarThickness = 2
    container.Parent = panel
    
    local layout = Instance.new("UIListLayout")
    layout.Padding = UDim.new(0, 10)
    layout.Parent = container
    
    -- Field Helper
    local function createField(label, placeholder)
        local f = Instance.new("Frame")
        f.BackgroundTransparency = 1
        f.Size = UDim2.new(1, 0, 0, 50)
        f.Parent = container
        
        local l = Instance.new("TextLabel")
        l.Text = label
        l.TextColor3 = theme.TextDim
        l.Font = Enum.Font.GothamBold
        l.TextSize = 10
        l.TextXAlignment = Enum.TextXAlignment.Left
        l.Size = UDim2.new(1, 0, 0, 20)
        l.BackgroundTransparency = 1
        l.Parent = f
        
        local box = Instance.new("TextBox")
        box.BackgroundColor3 = theme.Deep
        box.BackgroundTransparency = 0.5
        box.Size = UDim2.new(1, 0, 0, 30)
        box.Position = UDim2.new(0, 0, 0, 20)
        box.Text = ""
        box.PlaceholderText = placeholder
        box.TextColor3 = theme.Text
        box.Font = Enum.Font.Gotham
        box.TextSize = 12
        box.Parent = f
        Instance.new("UICorner", box).CornerRadius = UDim.new(0, 6)
        
        return box
    end
    
    -- Fields
    local triggerType = createField("TRIGGER TYPE", "chat / key / time / idle")
    local triggerValue = createField("TRIGGER VALUE", "Exact text or KeyCode name")
    
    local actionType = createField("ACTION TYPE", "playMacro / stopMacro / jump / notify")
    local actionValue = createField("ACTION VALUE", "Macro Name or Message")
    
    -- Buttons
    local btnContainer = Instance.new("Frame")
    btnContainer.BackgroundTransparency = 1
    btnContainer.Size = UDim2.new(1, -40, 0, 40)
    btnContainer.Position = UDim2.new(0, 20, 1, -50)
    btnContainer.Parent = panel
    
    local cancelBtn = Instance.new("TextButton")
    cancelBtn.Text = "CANCEL"
    cancelBtn.TextColor3 = theme.TextDim
    cancelBtn.BackgroundColor3 = theme.Surface
    cancelBtn.Size = UDim2.new(0.4, 0, 1, 0)
    cancelBtn.Parent = btnContainer
    Instance.new("UICorner", cancelBtn).CornerRadius = UDim.new(0, 6)
    
    local createBtn = Instance.new("TextButton")
    createBtn.Text = "CREATE RULE"
    createBtn.TextColor3 = theme.Deep
    createBtn.BackgroundColor3 = theme.Success
    createBtn.Size = UDim2.new(0.55, 0, 1, 0)
    createBtn.Position = UDim2.new(0.45, 0, 0, 0)
    createBtn.Parent = btnContainer
    Instance.new("UICorner", createBtn).CornerRadius = UDim.new(0, 6)
    
    cancelBtn.MouseButton1Click:Connect(function() modal:Destroy() end)
    
    createBtn.MouseButton1Click:Connect(function()
        local tType = triggerType.Text:lower()
        local aType = actionType.Text
        
        if Axiora.Automation.Triggers[tType] and Axiora.Automation.Actions[aType] then
            local rule = {
                id = HttpService:GenerateGUID(false),
                enabled = true,
                mode = Axiora.Automation.MODE_PLAYBACK,
                trigger = { type = tType, value = triggerValue.Text },
                condition = { type = "none" },
                action = { type = aType, name = actionValue.Text, message = actionValue.Text }
            }
            
            table.insert(Axiora.Automation.Rules, rule)
            Axiora.Automation.SaveRules()
            
            if onCreated then onCreated() end
            modal:Destroy()
            Axiora.Visuals.Notify("Automation", "Rule Created!", 2, "success")
        else
            Axiora.Visuals.Notify("Error", "Invalid Trigger or Action Type", 3, "error")
        end
    end)
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- PERSISTENCE
-- ═══════════════════════════════════════════════════════════════════════════════

function Axiora.Automation.SaveRules()
    if not Axiora.Capabilities.WriteFile then return false end
    
    local saveData = {
        rules = {},
        version = "1.0"
    }
    
    for _, rule in ipairs(Axiora.Automation.Rules) do
        table.insert(saveData.rules, {
            id = rule.id,
            enabled = rule.enabled,
            mode = rule.mode,
            trigger = rule.trigger,
            condition = rule.condition,
            action = rule.action
        })
    end
    
    return pcall(function()
        if not isfolder("Axiora") then makefolder("Axiora") end
        writefile("Axiora/automation_rules.json", HttpService:JSONEncode(saveData))
    end)
end

function Axiora.Automation.LoadRules()
    if not Axiora.Capabilities.ReadFile then return false end
    
    local success, data = pcall(function()
        if isfile("Axiora/automation_rules.json") then
            return HttpService:JSONDecode(readfile("Axiora/automation_rules.json"))
        end
        return nil
    end)
    
    if success and data and data.rules then
        Axiora.Automation.Rules = {}
        for _, ruleData in ipairs(data.rules) do
            local rule = {
                id = ruleData.id,
                enabled = ruleData.enabled,
                mode = ruleData.mode or Axiora.Automation.MODE_PLAYBACK,
                trigger = ruleData.trigger,
                condition = ruleData.condition,
                action = ruleData.action,
                lastTriggered = 0,
                triggerCount = 0
            }
            table.insert(Axiora.Automation.Rules, rule)
        end
        return true
    end
    return false
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 19: MODERN UI INTERFACE (Fully Redesigned)
-- ═══════════════════════════════════════════════════════════════════════════════

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 19: HOLOGRAPHIC COMMAND CENTER (UI V2.0)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.UI = {
    ScreenGui = nil,
    Open = false,
    CurrentTab = 1,
    Orientation = "Portrait",
    Scale = 1.0,
    IsOpen = false,
    MainFrame = nil,
    
    -- Speed Presets (FIX: was missing causing nil error)
    SpeedPresets = {
        careful = 0.5,
        normal = 1.0,
        fast = 1.5,
        turbo = 2.0
    },
    CurrentSpeed = "normal",
    
    -- Design System
    Theme = {
        -- Backgrounds
        Deep = Color3.fromRGB(8, 8, 15),        -- Main BG
        Surface = Color3.fromRGB(18, 18, 28),   -- Elevated surfaces
        Overlay = Color3.fromRGB(25, 25, 40),   -- Panels
        Glass = 0.1,                            -- Transparency level
        Background = Color3.fromRGB(15, 15, 25),
        
        -- Accents (State-dependent)
        Idle = Color3.fromRGB(60, 180, 255),    -- Cyan
        Recording = Color3.fromRGB(255, 50, 80), -- Crimson
        Playing = Color3.fromRGB(120, 255, 150), -- Green
        Paused = Color3.fromRGB(255, 200, 50),   -- Amber
        
        -- Primary colors
        Primary = Color3.fromRGB(60, 180, 255),
        Secondary = Color3.fromRGB(100, 100, 140),
        Tertiary = Color3.fromRGB(80, 80, 100), -- Fix: Added missing Tertiary color
        
        -- Node Types
        Movement = Color3.fromRGB(80, 150, 255), -- Blue
        Click = Color3.fromRGB(180, 80, 255),    -- Purple
        Key = Color3.fromRGB(255, 180, 50),      -- Orange
        Delay = Color3.fromRGB(100, 100, 120),   -- Gray
        
        -- Text
        Text = Color3.fromRGB(255, 255, 255),
        TextDim = Color3.fromRGB(140, 140, 160),
        
        -- Status
        Success = Color3.fromRGB(50, 255, 150),
        Warning = Color3.fromRGB(255, 200, 50),
        Error = Color3.fromRGB(255, 80, 100),
        Info = Color3.fromRGB(100, 200, 255)
    },
    
    -- Components Storage
    Orb = nil,
    Hub = nil,
    Tabs = {},
    Particles = {},
    Connections = {},
    ToggleButton = nil
}

-- ═══════════════════════════════════════════════════════════════════════════════
-- UI HELPER PRIMITIVES
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.UI.Primitives = {}

function Axiora.UI.Primitives.CreateScreenGui()
    if Axiora.UI.ScreenGui then pcall(function() Axiora.UI.ScreenGui:Destroy() end) end
    
    local sg = Instance.new("ScreenGui")
    sg.Name = "Axiora_HoloUI"
    sg.IgnoreGuiInset = true
    sg.ResetOnSpawn = false
    sg.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    sg.DisplayOrder = 1000
    
    local success = pcall(function() sg.Parent = CoreGui end)
    if not success then
        local LP = getLocalPlayer()
        if LP then sg.Parent = LP:FindFirstChild("PlayerGui") end
    end
    
    Axiora.UI.ScreenGui = sg
    return sg
end

function Axiora.UI.Primitives.CreateHoloPanel(parent, size, pos)
    local theme = Axiora.UI.Theme
    
    local frame = Instance.new("Frame")
    frame.BackgroundColor3 = theme.Deep
    frame.BackgroundTransparency = 0.15
    frame.Size = size or UDim2.new(1, 0, 1, 0)
    frame.Position = pos or UDim2.new(0, 0, 0, 0)
    frame.BorderSizePixel = 0
    frame.Parent = parent
    
    -- Glass effect
    local glass = Instance.new("Frame")
    glass.Name = "GlassOverlay"
    glass.BackgroundColor3 = theme.Surface
    glass.BackgroundTransparency = 0.95
    glass.Size = UDim2.new(1, 0, 1, 0)
    glass.ZIndex = frame.ZIndex
    glass.Parent = frame
    
    -- Neon Stroke
    local stroke = Instance.new("UIStroke")
    stroke.Color = theme.Idle
    stroke.Transparency = 0.6
    stroke.Thickness = 1.5
    stroke.Parent = frame
    
    -- Corner
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 12)
    corner.Parent = frame
    -- Apply to glass too
    local glassCorner = corner:Clone()
    glassCorner.Parent = glass
    
    frame.ClipsDescendants = true
    
    return frame, stroke
end

function Axiora.UI.Primitives.CreateNeonText(parent, text, size, color)
    local theme = Axiora.UI.Theme
    
    local label = Instance.new("TextLabel")
    label.BackgroundTransparency = 1
    label.Size = UDim2.new(1, 0, 0, size or 20)
    label.Text = text or ""
    label.TextColor3 = color or theme.Primary
    label.Font = Enum.Font.GothamBold
    label.TextSize = size or 14
    label.Parent = parent
    
    -- Glow effect
    local stroke = Instance.new("UIStroke")
    stroke.Color = color or theme.Primary
    stroke.Transparency = 0.8
    stroke.Thickness = 2
    stroke.Parent = label
    
    return label
end

function Axiora.UI.Primitives.Create3DButton(parent, text, color, callback)
    local theme = Axiora.UI.Theme
    color = color or theme.Idle
    
    local btn = Instance.new("TextButton")
    btn.BackgroundColor3 = color
    btn.BackgroundTransparency = 0.2
    btn.Size = UDim2.new(1, 0, 0, 45)
    btn.Text = ""
    btn.AutoButtonColor = false
    btn.Parent = parent
    
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 8)
    
    -- Gradient for 3D look
    local grad = Instance.new("UIGradient")
    grad.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(1,1,1)),
        ColorSequenceKeypoint.new(1, Color3.new(0.7,0.7,0.7)) -- Darken bottom
    })
    grad.Rotation = 90
    grad.Parent = btn
    
    -- Inner Shadow (simulated with Frame)
    local shadow = Instance.new("Frame")
    shadow.BackgroundColor3 = Color3.new(0,0,0)
    shadow.BackgroundTransparency = 0.8
    shadow.Size = UDim2.new(1, 0, 0.2, 0)
    shadow.Position = UDim2.new(0, 0, 0.8, 0)
    shadow.BorderSizePixel = 0
    shadow.Parent = btn
    Instance.new("UICorner", shadow).CornerRadius = UDim.new(0, 8)
    
    -- Label
    local label = Axiora.UI.Primitives.CreateNeonText(btn, text, 14, theme.Primary)
    label.Size = UDim2.new(1, 0, 1, 0)
    label.ZIndex = 2
    
    -- Interaction
    btn.MouseButton1Down:Connect(function()
        TweenService:Create(btn, TweenInfo.new(0.1), {Size = UDim2.new(1, -4, 0, 41)}):Play()
        if Axiora.Haptics then Axiora.Haptics.Pulse("Small") end
    end)
    
    btn.MouseButton1Up:Connect(function()
        TweenService:Create(btn, TweenInfo.new(0.1), {Size = UDim2.new(1, 0, 0, 45)}):Play()
        
        -- Spawn Particles
        local center = btn.AbsolutePosition + btn.AbsoluteSize/2
        for i = 1, 5 do
            Axiora.Particles.Spawn(center.X, center.Y, color)
        end
        
        if callback then callback() end
    end)
    
    return btn
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- ADVANCED UX SYSTEMS
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Haptics = {}

function Axiora.Haptics.IsSupported()
    return UserInputService.TouchEnabled and UserInputService.GyroscopeEnabled -- Proxy check for mobile
end

function Axiora.Haptics.Pulse(intensity)
    if not Axiora.Haptics.IsSupported() then return end
    -- HapticService isn't fully exposed to scripts usually, relying on camera shake fallback
    -- or if HapticService exists (some executors support it)
    pcall(function()
        if HapticService then
            HapticService:SetMotor(Enum.UserInputType.Gamepad1, Enum.VibrationMotor.Small, 0.5)
            task.delay(0.1, function() 
                HapticService:SetMotor(Enum.UserInputType.Gamepad1, Enum.VibrationMotor.Small, 0) 
            end)
        end
    end)
end

Axiora.Particles = {}

function Axiora.Particles.Spawn(x, y, color)
    if not Axiora.UI.ScreenGui then return end
    
    local p = Instance.new("Frame")
    p.BackgroundColor3 = color or Axiora.UI.Theme.Idle
    p.Size = UDim2.new(0, 10, 0, 10)
    p.Position = UDim2.new(0, x, 0, y)
    p.AnchorPoint = Vector2.new(0.5, 0.5)
    p.BorderSizePixel = 0
    p.Parent = Axiora.UI.ScreenGui
    Instance.new("UICorner", p).CornerRadius = UDim.new(1, 0)
    
    local destX = x + math.random(-50, 50)
    local destY = y + math.random(-50, 50)
    
    local tween = TweenService:Create(p, TweenInfo.new(0.5, Enum.EasingStyle.Quad), {
        Position = UDim2.new(0, destX, 0, destY),
        BackgroundTransparency = 1,
        Size = UDim2.new(0, 0, 0, 0)
    })
    tween:Play()
    tween.Completed:Connect(function() p:Destroy() end)
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- "AXIE" AI ASSISTANT
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Assistant = {
    Frame = nil,
    Visible = false,
    Messages = {
        "Recorded 50 nodes without pause! Great flow.",
        "Tip: Use 'Mark Position' to save this spot.",
        "Playing at 2.5x speed - Turbo Mode!",
        "Macro saved successfully to file.",
        "Warning: Playback drift detected (Recovered)."
    }
}

function Axiora.Assistant.Show(text, mood)
    local sg = Axiora.UI.ScreenGui
    if not sg then return end
    
    if not Axiora.Assistant.Frame then
        local frame = Instance.new("Frame")
        frame.Name = "Axie"
        frame.BackgroundColor3 = Axiora.UI.Theme.Overlay
        frame.Size = UDim2.new(0, 180, 0, 60)
        frame.Position = UDim2.new(1, -220, 0.5, -80) -- Above Orb
        frame.Parent = sg
        
        Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 30)
        
        -- Face
        local face = Instance.new("Frame")
        face.BackgroundColor3 = Axiora.UI.Theme.Idle
        face.Size = UDim2.new(0, 40, 0, 40)
        face.Position = UDim2.new(0, 10, 0.5, 0)
        face.AnchorPoint = Vector2.new(0, 0.5)
        face.Parent = frame
        Instance.new("UICorner", face).CornerRadius = UDim.new(1, 0)
        
        local eyes = Instance.new("TextLabel")
        eyes.BackgroundTransparency = 1
        eyes.Size = UDim2.new(1, 0, 1, 0)
        eyes.Text = "◉ ◉"
        eyes.TextColor3 = Axiora.UI.Theme.Deep
        eyes.TextSize = 14
        eyes.Parent = face
        
        -- Text Bubble
        local label = Instance.new("TextLabel")
        label.Name = "Message"
        label.BackgroundTransparency = 1
        label.Size = UDim2.new(1, -60, 1, 0)
        label.Position = UDim2.new(0, 55, 0, 0)
        label.TextColor3 = Axiora.UI.Theme.Primary
        label.TextSize = 11
        label.Font = Enum.Font.Gotham
        label.TextWrapped = true
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = frame
        
        Axiora.Assistant.Frame = frame
    end
    
    local f = Axiora.Assistant.Frame
    if not f then return end
    
    local msg = f:FindFirstChild("Message")
    if not msg then return end
    
    f.Visible = true
    f.BackgroundTransparency = 1
    msg.TextTransparency = 1
    msg.Text = text or Axiora.Assistant.Messages[math.random(1, #Axiora.Assistant.Messages)]
    
    -- Animate In
    TweenService:Create(f, TweenInfo.new(0.5, Enum.EasingStyle.Back), {BackgroundTransparency = 0.2}):Play()
    TweenService:Create(msg, TweenInfo.new(0.5), {TextTransparency = 0}):Play()
    
    -- Auto Hide
    task.delay(4, function()
        if not f or not f.Parent then return end
        TweenService:Create(f, TweenInfo.new(0.5), {BackgroundTransparency = 1}):Play()
        if msg and msg.Parent then
            TweenService:Create(msg, TweenInfo.new(0.5), {TextTransparency = 1}):Play()
        end
        task.wait(0.5)
        if f and f.BackgroundTransparency >= 0.9 then f.Visible = false end
    end)
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- PHASE 2: QUANTUM ORB (Persistent HUD)
-- ═══════════════════════════════════════════════════════════════════════════════

function Axiora.UI.CreateOrb()
    if Axiora.UI.Orb then Axiora.UI.Orb:Destroy() end
    
    local sg = Axiora.UI.ScreenGui or Axiora.UI.Primitives.CreateScreenGui()
    local theme = Axiora.UI.Theme
    
    local orbSize = 60
    local orb = Instance.new("Frame")
    orb.Name = "QuantumOrb"
    orb.BackgroundColor3 = theme.Deep
    orb.BackgroundTransparency = 0.2
    orb.Size = UDim2.new(0, orbSize, 0, orbSize)
    orb.Position = UDim2.new(1, -orbSize - 20, 0.5, 0) -- Right edge default
    orb.AnchorPoint = Vector2.new(0.5, 0.5)
    orb.Parent = sg
    
    Instance.new("UICorner", orb).CornerRadius = UDim.new(1, 0)
    
    -- Glow Ring
    local stroke = Instance.new("UIStroke")
    stroke.Color = theme.Idle
    stroke.Thickness = 2
    stroke.Parent = orb
    
    -- Inner Status Dot
    local dot = Instance.new("Frame")
    dot.BackgroundColor3 = theme.Idle
    dot.Size = UDim2.new(0, 10, 0, 10)
    dot.Position = UDim2.new(0.5, 0, 0.3, 0)
    dot.AnchorPoint = Vector2.new(0.5, 0.5)
    dot.Parent = orb
    Instance.new("UICorner", dot).CornerRadius = UDim.new(1, 0)
    
    -- Count
    local count = Instance.new("TextLabel")
    count.BackgroundTransparency = 1
    count.Size = UDim2.new(1, 0, 0, 20)
    count.Position = UDim2.new(0, 0, 0.6, 0)
    count.Text = "0"
    count.TextColor3 = theme.Primary
    count.Font = Enum.Font.GothamBold
    count.TextSize = 12
    count.Parent = orb
    
    -- Gestures
    local dragging = false
    local dragStart = Vector2.new()
    local startPos = UDim2.new()
    local heldTime = 0
    
    orb.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = orb.Position
            heldTime = os.clock()
            
            -- Press effect
            TweenService:Create(orb, TweenInfo.new(0.1), {Size = UDim2.new(0, orbSize*0.9, 0, orbSize*0.9)}):Play()
        end
    end)
    
    orb.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
            TweenService:Create(orb, TweenInfo.new(0.1), {Size = UDim2.new(0, orbSize, 0, orbSize)}):Play()
            
            local dragDist = (Vector2.new(input.Position.X, input.Position.Y) - Vector2.new(dragStart.X, dragStart.Y)).Magnitude
            
            -- Tap check
            if dragDist < 10 then
                if os.clock() - heldTime > 0.5 then
                    -- Long Press -> Radial Menu (TODO)
                    Axiora.Visuals.Notify("Orb", "Radial Menu (Coming Soon)", 1)
                else
                    -- Tap -> Toggle UI
                    Axiora.UI.Toggle()
                end
            else
                -- Snap to edge logic
                local screen = workspace.CurrentCamera.ViewportSize
                local endX = orb.Position.X.Offset
                local targetX = (endX < screen.X/2) and 40 or (screen.X - 40)
                
                TweenService:Create(orb, TweenInfo.new(0.3, Enum.EasingStyle.Back), {
                    Position = UDim2.new(0, targetX, 0, orb.Position.Y.Offset)
                }):Play()
            end
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            orb.Position = UDim2.new(
                startPos.X.Scale, startPos.X.Offset + delta.X,
                startPos.Y.Scale, startPos.Y.Offset + delta.Y
            )
        end
    end)
    
    -- Status Pulse
    task.spawn(function()
        while orb.Parent do
            local color = theme.Idle
            if Axiora.State.Status == "RECORDING" then color = theme.Recording
            elseif Axiora.State.Status == "PLAYING" then color = theme.Playing end
            
            TweenService:Create(stroke, TweenInfo.new(0.5), {Color = color}):Play()
            TweenService:Create(dot, TweenInfo.new(0.5), {BackgroundColor3 = color}):Play()
            count.Text = #Axiora.State.Buffer
            
            task.wait(0.5)
        end
    end)
    
    Axiora.UI.Orb = orb
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- PHASE 3: THE NEURAL HUB (Main Interface)
-- ═══════════════════════════════════════════════════════════════════════════════

function Axiora.UI.Toggle()
    if Axiora.UI.Open then
        Axiora.UI.CloseHub()
    else
        Axiora.UI.OpenHub()
    end
end

function Axiora.UI.OpenHub()
    if Axiora.UI.Hub then Axiora.UI.Hub:Destroy() end
    
    local sg = Axiora.UI.ScreenGui or Axiora.UI.Primitives.CreateScreenGui()
    local theme = Axiora.UI.Theme
    
    Axiora.UI.Open = true
    
    -- Main Container
    local hub = Instance.new("Frame")
    hub.Name = "NeuralHub"
    hub.BackgroundColor3 = theme.Deep
    hub.BackgroundTransparency = 0.05
    hub.AnchorPoint = Vector2.new(0.5, 0.5) -- Center pivot
    hub.Size = UDim2.new(0.5, 0, 0.6, 0) -- Responsive: 50% Width, 60% Height
    hub.Position = UDim2.new(0.5, 0, 1.5, 0) -- Start off screen (bottom)
    hub.Parent = sg
    
    -- Background Particles
    -- (TODO: Particle emitter inside GUI if possible, or just raw frames)
    
    -- Header
    local header = Instance.new("Frame")
    header.BackgroundColor3 = theme.Surface
    header.BackgroundTransparency = 0.2
    header.Size = UDim2.new(1, 0, 0, 60)
    header.Parent = hub
    
    Axiora.UI.Primitives.CreateNeonText(header, "AXIORA NEURAL HUB", 18, theme.Primary).Position = UDim2.new(0, 20, 0, 20)
    
    local closeBtn = Instance.new("TextButton")
    closeBtn.BackgroundTransparency = 1
    closeBtn.Size = UDim2.new(0, 50, 0, 60)
    closeBtn.Position = UDim2.new(1, -50, 0, 0)
    closeBtn.Text = "✕"
    closeBtn.TextColor3 = theme.Error
    closeBtn.TextSize = 24
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.Parent = header
    closeBtn.MouseButton1Click:Connect(function()
        Axiora.UI.CloseHub()
    end)
    
    -- Slide Up Animation
    TweenService:Create(hub, TweenInfo.new(0.4, Enum.EasingStyle.Quart), {Position = UDim2.new(0.5, 0, 0.5, 0)}):Play()
    
    Axiora.UI.Hub = hub
    
    -- Tab Container
    local contentArea = Instance.new("Frame")
    contentArea.Name = "ContentArea"
    contentArea.BackgroundTransparency = 1
    contentArea.Size = UDim2.new(1, 0, 1, -140) -- Space for Header + Nav
    contentArea.Position = UDim2.new(0, 0, 0, 60)
    contentArea.Parent = hub
    
    Axiora.UI.ContentArea = contentArea
    
    -- Bottom Navigation (Portrait Mode)
    local navBar = Instance.new("Frame")
    navBar.Name = "NavBar"
    navBar.BackgroundColor3 = theme.Surface
    navBar.BackgroundTransparency = 0.1
    navBar.Size = UDim2.new(1, -40, 0, 60)
    navBar.Position = UDim2.new(0.5, 0, 1, -20)
    navBar.AnchorPoint = Vector2.new(0.5, 1)
    navBar.Parent = hub
    
    Instance.new("UICorner", navBar).CornerRadius = UDim.new(1, 0)
    
    local navLayout = Instance.new("UIListLayout")
    navLayout.FillDirection = Enum.FillDirection.Horizontal
    navLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    navLayout.VerticalAlignment = Enum.VerticalAlignment.Center
    navLayout.Padding = UDim.new(0, 10)
    navLayout.Parent = navBar
    
    -- Tab Definitions
    local tabs = {
        {Id = 1, Icon = "📊", Name = "Home"},
        {Id = 2, Icon = "✏️", Name = "Editor"},
        {Id = 3, Icon = "📁", Name = "Files"},
        {Id = 4, Icon = "🔧", Name = "Tools"},
        {Id = 5, Icon = "⚙️", Name = "Scripts"}
    }
    
    for _, tab in ipairs(tabs) do
        local btn = Instance.new("TextButton")
        btn.Name = "Tab_" .. tab.Id
        btn.BackgroundColor3 = theme.Deep
        btn.BackgroundTransparency = 0.5
        btn.Size = UDim2.new(0, 50, 0, 50)
        btn.Text = tab.Icon
        btn.TextSize = 24
        btn.TextColor3 = theme.Secondary
        btn.AutoButtonColor = false
        btn.Parent = navBar
        
        Instance.new("UICorner", btn).CornerRadius = UDim.new(1, 0)
        
        btn.MouseButton1Click:Connect(function()
            Axiora.UI.SwitchTab(tab.Id)
        end)
    end
    
    -- Initial Tab Load
    Axiora.UI.SwitchTab(1)
end

function Axiora.UI.CloseHub()
    if not Axiora.UI.Hub then return end
    
    Axiora.UI.Open = false
    
    -- Slide Down Animation
    local tween = TweenService:Create(Axiora.UI.Hub, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
        Position = UDim2.new(0.5, 0, 1.5, 0)
    })
    tween:Play()
    
    tween.Completed:Connect(function()
        if Axiora.UI.Hub then
            Axiora.UI.Hub:Destroy()
            Axiora.UI.Hub = nil
        end
    end)
end

function Axiora.UI.SwitchTab(tabId)
    if not Axiora.UI.Hub then return end
    
    Axiora.UI.CurrentTab = tabId
    local theme = Axiora.UI.Theme
    
    -- Update Nav Buttons
    local navBar = Axiora.UI.Hub:FindFirstChild("NavBar")
    if navBar then
        for _, child in ipairs(navBar:GetChildren()) do
            if child:IsA("TextButton") then
                local id = tonumber(child.Name:match("%d+"))
                local isActive = (id == tabId)
                
                TweenService:Create(child, TweenInfo.new(0.2), {
                    BackgroundColor3 = isActive and theme.Idle or theme.Deep,
                    BackgroundTransparency = isActive and 0.1 or 0.5,
                    TextColor3 = isActive and theme.Primary or theme.Secondary
                }):Play()
            end
        end
    end
    
    -- Clear Content
    for _, child in ipairs(Axiora.UI.ContentArea:GetChildren()) do
        child:Destroy()
    end
    
    -- Build New Content
    if tabId == 1 then
        Axiora.UI.BuildCommandCenter(Axiora.UI.ContentArea)
    elseif tabId == 2 then
        Axiora.UI.BuildEditor(Axiora.UI.ContentArea)
    elseif tabId == 3 then
        Axiora.UI.BuildLibrary(Axiora.UI.ContentArea)
    elseif tabId == 4 then
        Axiora.UI.BuildUtilities(Axiora.UI.ContentArea)
    elseif tabId == 5 then
        Axiora.UI.BuildScripts(Axiora.UI.ContentArea)
    end
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- TAB 4: UTILITIES (Tools & Settings)
-- ═══════════════════════════════════════════════════════════════════════════════

function Axiora.UI.BuildUtilities(parent)
    local theme = Axiora.UI.Theme
    
    local scroll = Instance.new("ScrollingFrame")
    scroll.BackgroundTransparency = 1
    scroll.Size = UDim2.new(1, -20, 1, -10)
    scroll.Position = UDim2.new(0, 10, 0, 10)
    scroll.CanvasSize = UDim2.new(0, 0, 0, 0) -- Auto-calculated below
    scroll.ScrollBarThickness = 2
    scroll.Parent = parent
    
    local layout = Instance.new("UIListLayout")
    layout.Padding = UDim.new(0, 15)
    layout.Parent = scroll
    
    -- Helper: Section Header
    local function createSection(title)
        local frame = Instance.new("Frame")
        frame.BackgroundTransparency = 1
        frame.Size = UDim2.new(1, 0, 0, 30)
        frame.Parent = scroll
        Axiora.UI.Primitives.CreateNeonText(frame, title, 16, theme.Idle).Position = UDim2.new(0, 5, 0.5, 0)
    end
    
    -- 1. Active Features (Toggles)
    createSection("⚡ ACTIVE FEATURES")
    
    local featuresGrid = Instance.new("Frame")
    featuresGrid.BackgroundTransparency = 1
    featuresGrid.Size = UDim2.new(1, 0, 0, 120)
    featuresGrid.Parent = scroll
    
    local grid = Instance.new("UIGridLayout")
    grid.CellSize = UDim2.new(0.48, 0, 0, 55)
    grid.CellPadding = UDim2.new(0.04, 0, 0.05, 0)
    grid.Parent = featuresGrid
    
    local function createToggle(name, settingKey)
        local frame = Instance.new("TextButton")
        frame.BackgroundColor3 = theme.Surface
        frame.BackgroundTransparency = 0.2
        frame.Text = ""
        frame.Parent = featuresGrid
        Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 8)
        
        local label = Axiora.UI.Primitives.CreateNeonText(frame, name, 12, theme.Primary)
        label.Size = UDim2.new(0.6, 0, 1, 0)
        label.Position = UDim2.new(0, 10, 0, 0)
        label.TextXAlignment = Enum.TextXAlignment.Left
        
        local toggle = Instance.new("Frame")
        toggle.BackgroundColor3 = Axiora.Settings[settingKey] and theme.Success or theme.Tertiary
        toggle.Size = UDim2.new(0, 40, 0, 20)
        toggle.Position = UDim2.new(1, -50, 0.5, 0)
        toggle.AnchorPoint = Vector2.new(0, 0.5)
        toggle.Parent = frame
        Instance.new("UICorner", toggle).CornerRadius = UDim.new(1, 0)
        
        local knob = Instance.new("Frame")
        knob.BackgroundColor3 = theme.Primary
        knob.Size = UDim2.new(0, 16, 0, 16)
        knob.Position = Axiora.Settings[settingKey] and UDim2.new(1, -18, 0.5, 0) or UDim2.new(0, 2, 0.5, 0)
        knob.AnchorPoint = Vector2.new(0, 0.5)
        knob.Parent = toggle
        Instance.new("UICorner", knob).CornerRadius = UDim.new(1, 0)
        
        frame.MouseButton1Click:Connect(function()
            Axiora.Settings[settingKey] = not Axiora.Settings[settingKey]
            
            -- Animate
            local on = Axiora.Settings[settingKey]
            TweenService:Create(toggle, TweenInfo.new(0.2), {BackgroundColor3 = on and theme.Success or theme.Tertiary}):Play()
            TweenService:Create(knob, TweenInfo.new(0.2), {Position = on and UDim2.new(1, -18, 0.5, 0) or UDim2.new(0, 2, 0.5, 0)}):Play()
            
            -- Apply immediate effects
            if settingKey == "AntiAFK" then
                if on then
                    Axiora.Security.EnableAntiAFK()
                else
                    Axiora.Security.DisableAntiAFK()
                end
            end
            Axiora.Visuals.Notify("Settings", name .. (on and " Enabled" or " Disabled"), 1)
        end)
    end
    
    createToggle("Anti-AFK", "AntiAFK")
    createToggle("Auto Restart", "AutoRestartEnabled") -- Need to map to Axiora.AutoRestart.Enabled usually
    createToggle("HUD", "HUDEnabled")
    createToggle("Click Ripples", "ClickRipple")
    
    -- 2. Spatial Bookmarks
    createSection("📍 SAVED LOCATIONS")
    
    local markerList = Instance.new("Frame")
    markerList.BackgroundTransparency = 1
    markerList.Size = UDim2.new(1, 0, 0, 200) -- Dynamic height really
    markerList.Parent = scroll
    
    local mLayout = Instance.new("UIListLayout")
    mLayout.Padding = UDim.new(0, 5)
    mLayout.Parent = markerList
    
    local marks = Axiora.MarkedPositions or {}
    local markCount = 0
    for _ in pairs(marks) do markCount = markCount + 1 end

    if markCount == 0 then
        Axiora.UI.Primitives.CreateNeonText(markerList, "No marks saved yet", 12, theme.Tertiary)
    else
        -- Convert to array for sorting
        local sortedMarks = {}
        for name, data in pairs(marks) do
            table.insert(sortedMarks, {Name = name, Data = data})
        end
        table.sort(sortedMarks, function(a,b) return a.Name < b.Name end)

        for i, item in ipairs(sortedMarks) do
            local mark = item.Data
            local markName = item.Name
            
            local frame = Instance.new("Frame")
            frame.BackgroundColor3 = theme.Surface
            frame.BackgroundTransparency = 0.4
            frame.Size = UDim2.new(1, 0, 0, 40)
            frame.Parent = markerList
            Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 6)
            
            local nameLabel = Axiora.UI.Primitives.CreateNeonText(frame, markName, 12, theme.Primary)
            nameLabel.Position = UDim2.new(0, 10, 0.2, 0)
            
            local pos = Vector3.new(mark.x or 0, mark.y or 0, mark.z or 0)
            local dist = "N/A"
            local LP = getLocalPlayer()
            if LP and LP.Character and LP.Character.PrimaryPart then
                dist = math.floor((LP.Character.PrimaryPart.Position - pos).Magnitude) .. "m"
            end
            
            local distLabel = Instance.new("TextLabel")
            distLabel.BackgroundTransparency = 1
            distLabel.Size = UDim2.new(0, 50, 1, 0)
            distLabel.Position = UDim2.new(1, -60, 0, 0)
            distLabel.Text = dist
            distLabel.TextColor3 = theme.Idle
            distLabel.Font = Enum.Font.Gotham
            distLabel.TextSize = 11
            distLabel.Parent = frame
            
            -- Teleport action on click
            local btn = Instance.new("TextButton")
            btn.BackgroundTransparency = 1
            btn.Size = UDim2.new(1, 0, 1, 0)
            btn.Text = ""
            btn.Parent = frame
            btn.MouseButton1Click:Connect(function()
                Axiora.TeleportToMark(markName)
            end)
        end
    end
    
    -- Add Mark Button
    local addMarkBtn = Axiora.UI.Primitives.Create3DButton(scroll, "+ ADD MARKER", theme.Idle, function()
        Axiora.MarkPosition()
        Axiora.UI.SwitchTab(4) -- Refresh
    end)
    addMarkBtn.Size = UDim2.new(1, 0, 0, 40)
    
    -- Adjust Scroll Size
    scroll.CanvasSize = UDim2.new(0, 0, 0, 400) -- Estimate
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- TAB 1: COMMAND CENTER
-- ═══════════════════════════════════════════════════════════════════════════════

function Axiora.UI.BuildCommandCenter(parent)
    local theme = Axiora.UI.Theme
    
    -- 1. Iris Scanner (Status Ring)
    local statusPanel, _ = Axiora.UI.Primitives.CreateHoloPanel(parent, UDim2.new(0, 200, 0, 200), UDim2.new(0.5, -100, 0.05, 0))
    Instance.new("UICorner", statusPanel).CornerRadius = UDim.new(1, 0) -- Make it round
    statusPanel:FindFirstChild("GlassOverlay"):FindFirstChild("UICorner").CornerRadius = UDim.new(1, 0)
    
    local ring = Instance.new("UIStroke")
    ring.Color = theme.Idle
    ring.Thickness = 4
    ring.Transparency = 0.5
    ring.Parent = statusPanel
    
    local statusText = Axiora.UI.Primitives.CreateNeonText(statusPanel, "IDLE", 24, theme.Idle)
    statusText.Size = UDim2.new(1, 0, 0, 30)
    statusText.Position = UDim2.new(0, 0, 0.4, 0)
    
    local nodeCountText = Axiora.UI.Primitives.CreateNeonText(statusPanel, #Axiora.State.Buffer .. " NODES", 14, theme.Secondary)
    nodeCountText.Size = UDim2.new(1, 0, 0, 20)
    nodeCountText.Position = UDim2.new(0, 0, 0.6, 0)
    
    -- Status Loop
    task.spawn(function()
        while statusPanel.Parent do
            local status = Axiora.State.Status
            local color = theme.Idle
            local text = "IDLE"
            
            if status == "RECORDING" then
                color = theme.Recording
                text = "REC " .. Axiora.Recording.NodeCount
            elseif status == "PLAYING" then
                color = theme.Playing
                text = "PLAY " .. math.floor((Axiora.Playback.CurrentIndex / (#Axiora.State.Buffer + 1)) * 100) .. "%"
            elseif status == "PAUSED" then
                color = theme.Paused
                text = "PAUSED"
            end
            
            statusText.Text = text
            statusText.TextColor3 = color
            nodeCountText.Text = #Axiora.State.Buffer .. " NODES"
            ring.Color = color
            
            task.wait(0.2)
        end
    end)
    
    -- 2. Gesture Pad (Control Matrix)
    local pad = Instance.new("Frame")
    pad.BackgroundTransparency = 1
    pad.Size = UDim2.new(0.9, 0, 0.4, 0)
    pad.Position = UDim2.new(0.05, 0, 0.55, 0)
    pad.Parent = parent
    
    local grid = Instance.new("UIGridLayout")
    grid.CellSize = UDim2.new(0.48, 0, 0.45, 0)
    grid.CellPadding = UDim2.new(0.04, 0, 0.05, 0)
    grid.Parent = pad
    
    -- Record Btn
    Axiora.UI.Primitives.Create3DButton(pad, "⏺ RECORD", theme.Recording, function()
        if Axiora.State.Status == "RECORDING" then Axiora.Stop() else Axiora.Record() end
    end)
    
    -- Play Btn
    Axiora.UI.Primitives.Create3DButton(pad, "▶ PLAY", theme.Playing, function()
        if Axiora.State.Status == "PLAYING" then Axiora.Pause() else Axiora.Play(true) end
    end)
    
    -- Stop Btn
    Axiora.UI.Primitives.Create3DButton(pad, "⏹ STOP", theme.Deep, function()
        Axiora.Stop()
    end)
    
    -- Save Btn
    Axiora.UI.Primitives.Create3DButton(pad, "💾 SAVE", theme.Idle, function()
        Axiora.Save() 
    end)
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- TAB 2: TIMELINE EDITOR (Vertical Stream)
-- ═══════════════════════════════════════════════════════════════════════════════

function Axiora.UI.BuildEditor(parent)
    local theme = Axiora.UI.Theme
    local nodes = Axiora.EditBuffer()
    
    -- Auto-resize logic
    local layout = Instance.new("UIListLayout")
    layout.Padding = UDim.new(0, 8)
    layout.SortOrder = Enum.SortOrder.LayoutOrder
    layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    layout.Parent = parent
    
    local function updateSize()
        if parent.Parent and parent.Parent:IsA("ScrollingFrame") then
            parent.Parent.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 20)
        end
        parent.Size = UDim2.new(1, 0, 0, layout.AbsoluteContentSize.Y)
    end
    layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(updateSize)
    
    if #nodes == 0 then
        local emptyFrame = Instance.new("Frame")
        emptyFrame.Size = UDim2.new(1, -10, 0, 100)
        emptyFrame.BackgroundTransparency = 1
        emptyFrame.Parent = parent
        
        local empty = Axiora.UI.Primitives.CreateNeonText(emptyFrame, "Buffer Empty - Record something first", 14, theme.TextDim)
        empty.Size = UDim2.new(1,0,1,0)
        
        updateSize()
        return
    end
    
    for i, node in ipairs(nodes) do
        local color = theme.Delay
        local icon = "⏳"
        if node.Type == "Move" then color = theme.Movement; icon = "🚶"
        elseif node.Type == "Click" then color = theme.Click; icon = "👆"
        elseif node.Type == "Key" then color = theme.Key; icon = "⌨️" end
        
        local card = Instance.new("Frame")
        card.BackgroundColor3 = theme.Surface
        card.BackgroundTransparency = 0.4 -- More transparent for modern look
        card.Size = UDim2.new(0.95, 0, 0, 55)
        card.Parent = parent
        Instance.new("UICorner", card).CornerRadius = UDim.new(0, 8)
        
        -- Left Stripe
        local stripe = Instance.new("Frame")
        stripe.BackgroundColor3 = color
        stripe.Size = UDim2.new(0, 3, 1, 0)
        stripe.Parent = card
        Instance.new("UICorner", stripe).CornerRadius = UDim.new(1, 0)
        
        -- Info
        local titleText = icon .. " " .. node.Type .. " #" .. i
        local title = Instance.new("TextLabel")
        title.Text = titleText
        title.TextColor3 = theme.Text
        title.Font = Enum.Font.GothamBold
        title.TextSize = 12
        title.BackgroundTransparency = 1
        title.Size = UDim2.new(1, -60, 0, 20)
        title.Position = UDim2.new(0, 12, 0, 8)
        title.TextXAlignment = Enum.TextXAlignment.Left
        title.Parent = card
        
        local descText = "Delay: " .. string.format("%.2f", node.Delay) .. "s"
        local desc = Instance.new("TextLabel")
        desc.BackgroundTransparency = 1
        desc.Size = UDim2.new(1, -60, 0, 20)
        desc.Position = UDim2.new(0, 12, 0, 28)
        desc.Text = descText
        desc.TextColor3 = theme.Secondary
        desc.Font = Enum.Font.Gotham
        desc.TextSize = 10
        desc.TextXAlignment = Enum.TextXAlignment.Left
        desc.Parent = card
        
        -- Delete Action
        local delBtn = Instance.new("TextButton")
        delBtn.BackgroundTransparency = 1
        delBtn.Size = UDim2.new(0, 30, 1, 0)
        delBtn.Position = UDim2.new(1, -35, 0, 0)
        delBtn.Text = "🗑️"
        delBtn.TextColor3 = theme.Error
        delBtn.TextSize = 14
        delBtn.Parent = card
        
        delBtn.MouseButton1Click:Connect(function()
            Axiora.DeleteNode(i)
            card:Destroy() 
            Axiora.Visuals.Notify("Editor", "Node deleted", 1, "info")
            -- Rebuild recommended for proper indices, but simple destroy works for visuals
        end)
    end
    
    -- Initial sizing
    task.wait()
    updateSize()
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- TAB 3: LIBRARY (File Grid)
-- ═══════════════════════════════════════════════════════════════════════════════

function Axiora.UI.BuildLibrary(parent)
    local theme = Axiora.UI.Theme
    local saves = Axiora.ListSaves()
    
    -- Grid Layout
    local grid = Instance.new("UIGridLayout")
    grid.CellSize = UDim2.new(0.47, 0, 0, 100) -- Slightly smaller to fit padding
    grid.CellPadding = UDim2.new(0.04, 0, 0, 10)
    grid.HorizontalAlignment = Enum.HorizontalAlignment.Center
    grid.Parent = parent
    
    local function updateSize()
        if parent.Parent and parent.Parent:IsA("ScrollingFrame") then
             -- Grid size calculation
             local columns = 2
             local rows = math.ceil(#parent:GetChildren() / columns) -- Approximation
             -- Better: AbsoluteContentSize
             parent.Parent.CanvasSize = UDim2.new(0, 0, 0, grid.AbsoluteContentSize.Y + 20)
        end
        parent.Size = UDim2.new(1, 0, 0, grid.AbsoluteContentSize.Y)
    end
    grid:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(updateSize)
    
    if #saves == 0 then
        local empty = Axiora.UI.Primitives.CreateNeonText(parent, "No saved macros found", 14, theme.TextDim)
        empty.Size = UDim2.new(1,0,0,50)
        return
    end
    
    for i, save in ipairs(saves) do
        local card = Instance.new("TextButton")
        card.BackgroundColor3 = theme.Surface
        card.BackgroundTransparency = 0.4
        card.Text = ""
        card.Parent = parent
        Instance.new("UICorner", card).CornerRadius = UDim.new(0, 8)
        
        -- Stroke
        local s = Instance.new("UIStroke")
        s.Color = theme.Primary
        s.Transparency = 0.7
        s.Thickness = 1
        s.Parent = card
        
        -- Icon
        local icon = Instance.new("TextLabel")
        icon.BackgroundTransparency = 1
        icon.Size = UDim2.new(1, 0, 0.6, 0)
        icon.Text = "📄"
        icon.TextSize = 30
        icon.Parent = card
        
        -- Name
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Text = save
        nameLabel.Size = UDim2.new(1, -10, 0, 20)
        nameLabel.Position = UDim2.new(0, 5, 0.65, 0)
        nameLabel.BackgroundTransparency = 1
        nameLabel.TextColor3 = theme.Text
        nameLabel.Font = Enum.Font.GothamBold
        nameLabel.TextSize = 11
        nameLabel.Parent = card
        
        -- Load Action
        card.MouseButton1Click:Connect(function()
            Axiora.Load(save)
            Axiora.Visuals.Notify("Library", "Loaded " .. save, 2, "success")
            -- In new GUI, we might want to switch to Control tab?
            -- But for now just load.
        end)
    end
    
    task.wait()
    updateSize()
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- TAB 5: SCRIPTS (Automation Rules + URL Loader)
-- ═══════════════════════════════════════════════════════════════════════════════

function Axiora.UI.BuildScripts(parent)
    local theme = Axiora.UI.Theme
    
    local scroll = Instance.new("ScrollingFrame")
    scroll.BackgroundTransparency = 1
    scroll.Size = UDim2.new(1, -20, 1, -10)
    scroll.Position = UDim2.new(0, 10, 0, 5)
    scroll.CanvasSize = UDim2.new(0, 0, 0, 600)
    scroll.ScrollBarThickness = 2
    scroll.Parent = parent
    
    local layout = Instance.new("UIListLayout")
    layout.Padding = UDim.new(0, 10)
    layout.Parent = scroll
    
    -- ═══════════════════════════════════════════════════════════════════════
    -- SECTION 1: URL LOADER
    -- ═══════════════════════════════════════════════════════════════════════
    
    local urlSection = Instance.new("Frame")
    urlSection.BackgroundColor3 = theme.Surface
    urlSection.BackgroundTransparency = 0.3
    urlSection.Size = UDim2.new(1, 0, 0, 100)
    urlSection.Parent = scroll
    Instance.new("UICorner", urlSection).CornerRadius = UDim.new(0, 10)
    
    local urlTitle = Axiora.UI.Primitives.CreateNeonText(urlSection, "🌐 LOAD FROM URL", 14, theme.Idle)
    urlTitle.Position = UDim2.new(0, 10, 0, 8)
    
    -- URL Input Box
    local urlInput = Instance.new("TextBox")
    urlInput.BackgroundColor3 = theme.Deep
    urlInput.BackgroundTransparency = 0.3
    urlInput.Size = UDim2.new(1, -20, 0, 35)
    urlInput.Position = UDim2.new(0, 10, 0, 35)
    urlInput.PlaceholderText = "Enter macro URL (pastebin, github raw, etc.)"
    urlInput.PlaceholderColor3 = theme.Tertiary or theme.TextDim or Color3.fromRGB(150, 150, 150)
    urlInput.Text = ""
    urlInput.TextColor3 = theme.Primary
    urlInput.Font = Enum.Font.Gotham
    urlInput.TextSize = 12
    urlInput.ClearTextOnFocus = false
    urlInput.Parent = urlSection
    Instance.new("UICorner", urlInput).CornerRadius = UDim.new(0, 6)
    Instance.new("UIPadding", urlInput).PaddingLeft = UDim.new(0, 10)
    
    -- Load URL Button
    local loadUrlBtn = Instance.new("TextButton")
    loadUrlBtn.BackgroundColor3 = theme.Playing
    loadUrlBtn.Size = UDim2.new(1, -20, 0, 30)
    loadUrlBtn.Position = UDim2.new(0, 10, 0, 75)
    loadUrlBtn.Text = "⬇️ LOAD FROM URL"
    loadUrlBtn.TextColor3 = Color3.new(1, 1, 1)
    loadUrlBtn.Font = Enum.Font.GothamBold
    loadUrlBtn.TextSize = 12
    loadUrlBtn.Parent = urlSection
    Instance.new("UICorner", loadUrlBtn).CornerRadius = UDim.new(0, 6)
    
    loadUrlBtn.MouseButton1Click:Connect(function()
        local url = urlInput.Text
        if url == "" or not url:match("^https?://") then
            Axiora.Visuals.Notify("URL Loader", "Please enter a valid URL", 2, "error")
            return
        end
        
        loadUrlBtn.Text = "⏳ LOADING..."
        
        task.spawn(function()
            local success, result = pcall(function()
                return game:HttpGet(url)
            end)
            
            if success and result then
                local decoded = pcall(function()
                    local data = HttpService:JSONDecode(result)
                    if data and (data.buffer or data.b) then
                        Axiora.State.Buffer = data.buffer or data.b
                        Axiora.Visuals.Notify("URL Loader", "Loaded " .. #Axiora.State.Buffer .. " nodes!", 3, "success")
                        return true
                    end
                end)
                
                if not decoded then
                    Axiora.Visuals.Notify("URL Loader", "Invalid macro format", 2, "error")
                end
            else
                Axiora.Visuals.Notify("URL Loader", "Failed to fetch URL", 2, "error")
            end
            
            loadUrlBtn.Text = "⬇️ LOAD FROM URL"
        end)
    end)
    
    -- ═══════════════════════════════════════════════════════════════════════
    -- SECTION 2: AUTOMATION RULES
    -- ═══════════════════════════════════════════════════════════════════════
    
    local rulesSection = Instance.new("Frame")
    rulesSection.BackgroundTransparency = 1
    rulesSection.Size = UDim2.new(1, 0, 0, 40)
    rulesSection.Parent = scroll
    
    local rulesTitle = Axiora.UI.Primitives.CreateNeonText(rulesSection, "⚡ AUTOMATION RULES", 14, theme.Idle)
    rulesTitle.Position = UDim2.new(0, 0, 0.3, 0)
    
    -- Add Rule Button
    local addRuleBtn = Instance.new("TextButton")
    addRuleBtn.BackgroundColor3 = theme.Success
    addRuleBtn.Size = UDim2.new(0, 80, 0, 28)
    addRuleBtn.Position = UDim2.new(1, -85, 0.5, 0)
    addRuleBtn.AnchorPoint = Vector2.new(0, 0.5)
    addRuleBtn.Text = "+ NEW"
    addRuleBtn.TextColor3 = Color3.new(1, 1, 1)
    addRuleBtn.Font = Enum.Font.GothamBold
    addRuleBtn.TextSize = 11
    addRuleBtn.Parent = rulesSection
    Instance.new("UICorner", addRuleBtn).CornerRadius = UDim.new(0, 6)
    
    addRuleBtn.MouseButton1Click:Connect(function()
        if Axiora.Automation and Axiora.Automation.ShowRuleCreationModal then
            Axiora.Automation.ShowRuleCreationModal(Axiora.UI.ScreenGui, function()
                -- Refresh the list after creation
                Axiora.UI.SwitchTab(5)
            end)
        else
            Axiora.Visuals.Notify("Scripts", "Rule creation modal not available", 2, "warning")
        end
    end)
    
    -- List existing rules
    local rules = Axiora.Automation and Axiora.Automation.Rules or {}
    
    if #rules == 0 then
        local emptyLabel = Axiora.UI.Primitives.CreateNeonText(scroll, "No automation rules yet. Tap + NEW to create one!", 12, theme.Tertiary)
        emptyLabel.Size = UDim2.new(1, 0, 0, 40)
        emptyLabel.TextWrapped = true
    else
        for i, rule in ipairs(rules) do
            local ruleCard = Instance.new("Frame")
            ruleCard.BackgroundColor3 = theme.Surface
            ruleCard.BackgroundTransparency = 0.2
            ruleCard.Size = UDim2.new(1, 0, 0, 60)
            ruleCard.Parent = scroll
            Instance.new("UICorner", ruleCard).CornerRadius = UDim.new(0, 8)
            
            -- Rule name/trigger
            local ruleName = Axiora.UI.Primitives.CreateNeonText(ruleCard, 
                (rule.trigger and rule.trigger.type or "Unknown") .. " → " .. (rule.action and rule.action.type or "Unknown"), 
                12, theme.Primary)
            ruleName.Position = UDim2.new(0, 10, 0, 10)
            ruleName.Size = UDim2.new(0.7, 0, 0, 20)
            ruleName.TextXAlignment = Enum.TextXAlignment.Left
            
            -- Mode label
            local modeLabel = Axiora.UI.Primitives.CreateNeonText(ruleCard, 
                rule.mode or "always", 
                10, rule.enabled and theme.Success or theme.Tertiary)
            modeLabel.Position = UDim2.new(0, 10, 0, 32)
            modeLabel.Size = UDim2.new(0.5, 0, 0, 16)
            modeLabel.TextXAlignment = Enum.TextXAlignment.Left
            
            -- Toggle button
            local toggleBtn = Instance.new("TextButton")
            toggleBtn.BackgroundColor3 = rule.enabled and theme.Success or theme.Error
            toggleBtn.Size = UDim2.new(0, 50, 0, 24)
            toggleBtn.Position = UDim2.new(1, -110, 0.5, 0)
            toggleBtn.AnchorPoint = Vector2.new(0, 0.5)
            toggleBtn.Text = rule.enabled and "ON" or "OFF"
            toggleBtn.TextColor3 = Color3.new(1, 1, 1)
            toggleBtn.Font = Enum.Font.GothamBold
            toggleBtn.TextSize = 10
            toggleBtn.Parent = ruleCard
            Instance.new("UICorner", toggleBtn).CornerRadius = UDim.new(0, 4)
            
            toggleBtn.MouseButton1Click:Connect(function()
                if Axiora.Automation.ToggleRule then
                    local newState = Axiora.Automation.ToggleRule(rule.id)
                    toggleBtn.BackgroundColor3 = newState and theme.Success or theme.Error
                    toggleBtn.Text = newState and "ON" or "OFF"
                end
            end)
            
            -- Delete button
            local deleteBtn = Instance.new("TextButton")
            deleteBtn.BackgroundColor3 = theme.Error
            deleteBtn.BackgroundTransparency = 0.5
            deleteBtn.Size = UDim2.new(0, 40, 0, 24)
            deleteBtn.Position = UDim2.new(1, -50, 0.5, 0)
            deleteBtn.AnchorPoint = Vector2.new(0, 0.5)
            deleteBtn.Text = "🗑️"
            deleteBtn.TextSize = 14
            deleteBtn.Parent = ruleCard
            Instance.new("UICorner", deleteBtn).CornerRadius = UDim.new(0, 4)
            
            deleteBtn.MouseButton1Click:Connect(function()
                if Axiora.Automation.DeleteRule then
                    Axiora.Automation.DeleteRule(rule.id)
                    ruleCard:Destroy()
                    Axiora.Visuals.Notify("Scripts", "Rule deleted", 2, "info")
                end
            end)
        end
    end
    
    -- Update canvas size
    layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        scroll.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 20)
    end)
end

-- Helper to refresh scripts tab
function Axiora.UI.RefreshScripts()
    if Axiora.UI.MainPanel then
        -- Find the scripts container efficiently
        local contentContainer = Axiora.UI.MainPanel:FindFirstChild("ContentContainer")
        if contentContainer then
            local scriptsTab = contentContainer:FindFirstChild("Scripts")
            if scriptsTab then
                scriptsTab:ClearAllChildren()
                Axiora.UI.BuildScripts(scriptsTab)
            end
        end
    end
end

-- Helper to refresh library tab
function Axiora.UI.RefreshLibrary()
     if Axiora.UI.MainPanel then
        local contentContainer = Axiora.UI.MainPanel:FindFirstChild("ContentContainer")
        if contentContainer then
            local filesTab = contentContainer:FindFirstChild("Files")
            if filesTab then
                 filesTab:ClearAllChildren()
                 Axiora.UI.BuildLibrary(filesTab)
            end
        end
    end
end

-- Settings Builder
function Axiora.UI.BuildSettings(parent)
    local theme = Axiora.UI.Theme
    
    local list = Instance.new("UIListLayout")
    list.Padding = UDim.new(0, 10)
    list.Parent = parent
    
    local function addToggle(text, configKey)
        local frame = Instance.new("Frame")
        frame.BackgroundColor3 = theme.Surface
        frame.BackgroundTransparency = 0.4
        frame.Size = UDim2.new(1, 0, 0, 40)
        frame.Parent = parent
        Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 8)
        
        local label = Instance.new("TextLabel")
        label.Text = text
        label.TextColor3 = theme.Text
        label.Font = Enum.Font.GothamBold
        label.TextSize = 12
        label.BackgroundTransparency = 1
        label.Size = UDim2.new(0.7, 0, 1, 0)
        label.Position = UDim2.new(0, 10, 0, 0)
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = frame
        
        local btn = Instance.new("TextButton")
        local val = Axiora.Settings[configKey]
        btn.Text = val and "ON" or "OFF"
        btn.BackgroundColor3 = val and theme.Success or theme.Error
        btn.Size = UDim2.new(0, 50, 0, 24)
        btn.Position = UDim2.new(1, -60, 0.5, 0)
        btn.AnchorPoint = Vector2.new(0, 0.5)
        btn.TextColor3 = Color3.new(1,1,1)
        btn.Font = Enum.Font.GothamBold
        btn.TextSize = 10
        btn.Parent = frame
        Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)
        
        btn.MouseButton1Click:Connect(function()
            Axiora.Settings[configKey] = not Axiora.Settings[configKey]
            local newVal = Axiora.Settings[configKey]
            btn.Text = newVal and "ON" or "OFF"
            btn.BackgroundColor3 = newVal and theme.Success or theme.Error
        end)
    end
    
    addToggle("Mobile Mode", "IsMobile")
    addToggle("Debug Info", "DebugMode")
    addToggle("Auto Save", "AutoSave")
    addToggle("Loop Playback", "LoopPlayback")
    addToggle("Click Recovery", "ClickRecovery")
    addToggle("3D Path Viz", "VisualizePath")
end

function Axiora.UI.CloseHub()
    if Axiora.UI.Hub then
        TweenService:Create(Axiora.UI.Hub, TweenInfo.new(0.3, Enum.EasingStyle.Quad), {Position = UDim2.new(0,0,1,0)}):Play()
        task.wait(0.3)
        Axiora.UI.Hub:Destroy()
        Axiora.UI.Hub = nil
    end
    Axiora.UI.Open = false
end

-- Initialize
function Axiora.UI.Init()
    Axiora.UI.Primitives.CreateScreenGui()
    Axiora.UI.CreateOrb()
end


-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 20: INITIALIZATION & EXPORTS
-- ═══════════════════════════════════════════════════════════════════════════════

-- Helper: Add glow effect
local function addGlow(parent, color, size)
    local glow = Instance.new("ImageLabel")
    glow.Name = "Glow"
    glow.BackgroundTransparency = 1
    glow.Image = "rbxassetid://5028857084" -- Radial blur
    glow.ImageColor3 = color
    glow.ImageTransparency = 0.7
    glow.Size = UDim2.new(1, size or 40, 1, size or 40)
    glow.Position = UDim2.new(0.5, 0, 0.5, 0)
    glow.AnchorPoint = Vector2.new(0.5, 0.5)
    glow.ZIndex = parent.ZIndex - 1
    glow.Parent = parent
    return glow
end

-- Helper: Create gradient effect on UI element
local function createGradient(parent, startColor, endColor, rotation)
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, startColor),
        ColorSequenceKeypoint.new(1, endColor)
    })
    gradient.Rotation = rotation or 0
    gradient.Parent = parent
    return gradient
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- TAB 1: COMMAND CENTER (Home)
-- ═══════════════════════════════════════════════════════════════════════════════

-- Obsolete BuildCommandCenter removed.


function Axiora.UI.Create()
    -- Cleanup previous
    if Axiora.UI.ScreenGui then
        pcall(function() Axiora.UI.ScreenGui:Destroy() end)
    end

    local Players = game:GetService("Players")
    local TweenService = game:GetService("TweenService")
    local LP = getLocalPlayer()

    -- Color utilities
    local function rgb(r, g, b)
        return Color3.fromRGB(r, g, b)
    end

    -- Create ScreenGui
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "AxioraGUI"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.Parent = LP and LP:FindFirstChild("PlayerGui") or game:GetService("CoreGui")
    Axiora.UI.ScreenGui = screenGui

    -- Main Frame (equivalent to the outer div)
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(1, 0, 1, 0)
    mainFrame.Position = UDim2.new(0, 0, 0, 0)
    mainFrame.BackgroundTransparency = 1
    mainFrame.BorderSizePixel = 0
    mainFrame.Parent = screenGui

    -- Container (max-width equivalent) - 400x310
    local container = Instance.new("Frame")
    container.Name = "Container"
    container.Size = UDim2.new(0, 400, 0, 310)
    container.Position = UDim2.new(0.5, 0, 0.5, 0)
    container.AnchorPoint = Vector2.new(0.5, 0.5)
    container.BackgroundColor3 = rgb(2, 6, 23) -- slate-950
    container.BorderSizePixel = 0
    container.Parent = mainFrame

    Axiora.UI.MainPanel = container

    -- Gradient background for container
    local containerGradient = Instance.new("UIGradient")
    containerGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, rgb(2, 6, 23)),
        ColorSequenceKeypoint.new(0.5, rgb(59, 7, 100)),
        ColorSequenceKeypoint.new(1, rgb(2, 6, 23))
    }
    containerGradient.Rotation = 135
    containerGradient.Parent = container

    local containerCorner = Instance.new("UICorner")
    containerCorner.CornerRadius = UDim.new(0, 16)
    containerCorner.Parent = container

    -- Status Bar
    local statusBar = Instance.new("Frame")
    statusBar.Name = "StatusBar"
    statusBar.Size = UDim2.new(1, -10, 0, 32)
    statusBar.Position = UDim2.new(0, 5, 0, 5)
    statusBar.BackgroundColor3 = rgb(15, 23, 42)
    statusBar.BackgroundTransparency = 0.4
    statusBar.BorderSizePixel = 0
    statusBar.Parent = container

    local statusCorner = Instance.new("UICorner")
    statusCorner.CornerRadius = UDim.new(0, 8)
    statusCorner.Parent = statusBar

    local statusStroke = Instance.new("UIStroke")
    statusStroke.Color = rgb(51, 65, 85)
    statusStroke.Transparency = 0.5
    statusStroke.Thickness = 1
    statusStroke.Parent = statusBar

    -- Status indicator
    local statusIndicator = Instance.new("Frame")
    statusIndicator.Name = "StatusIndicator"
    statusIndicator.Size = UDim2.new(0, 65, 0, 22)
    statusIndicator.Position = UDim2.new(0, 5, 0.5, 0)
    statusIndicator.AnchorPoint = Vector2.new(0, 0.5)
    statusIndicator.BackgroundColor3 = rgb(51, 65, 85)
    statusIndicator.BackgroundTransparency = 0.7
    statusIndicator.BorderSizePixel = 0
    statusIndicator.Parent = statusBar

    local statusIndCorner = Instance.new("UICorner")
    statusIndCorner.CornerRadius = UDim.new(0, 6)
    statusIndCorner.Parent = statusIndicator

    local statusIndStroke = Instance.new("UIStroke")
    statusIndStroke.Color = rgb(71, 85, 105)
    statusIndStroke.Transparency = 0.5
    statusIndStroke.Thickness = 1
    statusIndStroke.Parent = statusIndicator

    -- Status dot
    local statusDot = Instance.new("Frame")
    statusDot.Name = "StatusDot"
    statusDot.Size = UDim2.new(0, 5, 0, 5)
    statusDot.Position = UDim2.new(0, 5, 0.5, 0)
    statusDot.AnchorPoint = Vector2.new(0, 0.5)
    statusDot.BackgroundColor3 = rgb(148, 163, 184)
    statusDot.BorderSizePixel = 0
    statusDot.Parent = statusIndicator
    Instance.new("UICorner", statusDot).CornerRadius = UDim.new(1, 0)

    -- Status text
    local statusText = Instance.new("TextLabel")
    statusText.Name = "StatusText"
    statusText.Size = UDim2.new(1, -15, 1, 0)
    statusText.Position = UDim2.new(0, 15, 0, 0)
    statusText.BackgroundTransparency = 1
    statusText.Text = "IDLE"
    statusText.Font = Enum.Font.GothamBold
    statusText.TextSize = 8
    statusText.TextColor3 = rgb(226, 232, 240)
    statusText.TextXAlignment = Enum.TextXAlignment.Left
    statusText.Parent = statusIndicator

    -- Node count
    local nodeCountLabel = Instance.new("TextLabel")
    nodeCountLabel.Name = "NodeCount"
    nodeCountLabel.Size = UDim2.new(0, 60, 1, 0)
    nodeCountLabel.Position = UDim2.new(0, 75, 0, 0)
    nodeCountLabel.BackgroundTransparency = 1
    nodeCountLabel.Text = "0 nodes"
    nodeCountLabel.Font = Enum.Font.Code
    nodeCountLabel.TextSize = 7
    nodeCountLabel.TextColor3 = rgb(203, 213, 225)
    nodeCountLabel.TextXAlignment = Enum.TextXAlignment.Left
    nodeCountLabel.Parent = statusBar

    -- Executor badges
    local executorBadge = Instance.new("TextLabel")
    executorBadge.Name = "ExecutorBadge"
    executorBadge.Size = UDim2.new(0, 75, 0, 18)
    executorBadge.Position = UDim2.new(1, -140, 0.5, 0)
    executorBadge.AnchorPoint = Vector2.new(0, 0.5)
    executorBadge.BackgroundColor3 = rgb(51, 65, 85)
    executorBadge.BackgroundTransparency = 0.7
    executorBadge.Text = "Delta Executor"
    executorBadge.Font = Enum.Font.Code
    executorBadge.TextSize = 7
    executorBadge.TextColor3 = rgb(34, 211, 238)
    executorBadge.BorderSizePixel = 0
    executorBadge.Parent = statusBar
    Instance.new("UICorner", executorBadge).CornerRadius = UDim.new(0, 4)

    local readyBadge = Instance.new("TextLabel")
    readyBadge.Name = "ReadyBadge"
    readyBadge.Size = UDim2.new(0, 50, 0, 18)
    readyBadge.Position = UDim2.new(1, -55, 0.5, 0)
    readyBadge.AnchorPoint = Vector2.new(0, 0.5)
    readyBadge.BackgroundColor3 = rgb(34, 197, 94)
    readyBadge.BackgroundTransparency = 0.9
    readyBadge.Text = "READY"
    readyBadge.Font = Enum.Font.GothamBold
    readyBadge.TextSize = 7
    readyBadge.TextColor3 = rgb(74, 222, 128)
    readyBadge.BorderSizePixel = 0
    readyBadge.Parent = statusBar
    Instance.new("UICorner", readyBadge).CornerRadius = UDim.new(0, 4)
    local readyStroke = Instance.new("UIStroke")
    readyStroke.Color = rgb(34, 197, 94)
    readyStroke.Transparency = 0.7
    readyStroke.Thickness = 1
    readyStroke.Parent = readyBadge

    -- Sidebar
    local sidebar = Instance.new("Frame")
    sidebar.Name = "Sidebar"
    sidebar.Size = UDim2.new(0, 90, 0, 258)
    sidebar.Position = UDim2.new(0, 5, 0, 42)
    sidebar.BackgroundColor3 = rgb(15, 23, 42)
    sidebar.BackgroundTransparency = 0.4
    sidebar.BorderSizePixel = 0
    sidebar.Parent = container

    local sidebarCorner = Instance.new("UICorner")
    sidebarCorner.CornerRadius = UDim.new(0, 8)
    sidebarCorner.Parent = sidebar

    local sidebarStroke = Instance.new("UIStroke")
    sidebarStroke.Color = rgb(51, 65, 85)
    sidebarStroke.Transparency = 0.5
    sidebarStroke.Thickness = 1
    sidebarStroke.Parent = sidebar

    -- Forward declare mainContent
    local mainContent

    -- Navigation buttons
    local activeTab = "control"
    local navButtons = {
        {id = "control", label = "Control", yPos = 5},
        {id = "editor", label = "Editor", yPos = 32},
        {id = "library", label = "Library", yPos = 59},
        {id = "automation", label = "Auto", yPos = 86},
        {id = "settings", label = "Settings", yPos = 113}
    }

    local function updateNavButtons()
        for _, btnData in ipairs(navButtons) do
            local btn = sidebar:FindFirstChild(btnData.id .. "Btn")
            if btn then
                if btnData.id == activeTab then
                    btn.BackgroundColor3 = rgb(147, 51, 234)
                    btn.BackgroundTransparency = 0
                    btn.TextColor3 = rgb(255, 255, 255)
                    local gradient = btn:FindFirstChild("UIGradient")
                    if gradient then gradient.Enabled = true end
                else
                    btn.BackgroundColor3 = rgb(51, 65, 85)
                    btn.BackgroundTransparency = 0.5
                    btn.TextColor3 = rgb(148, 163, 184)
                    local gradient = btn:FindFirstChild("UIGradient")
                    if gradient then gradient.Enabled = false end
                end
            end
        end
        -- Update content panels
        for _, child in pairs(mainContent:GetChildren()) do
            if child:IsA("Frame") then
                child.Visible = (child.Name == activeTab .. "Panel")
            end
        end
    end

    for _, btnData in ipairs(navButtons) do
        local navBtn = Instance.new("TextButton")
        navBtn.Name = btnData.id .. "Btn"
        navBtn.Size = UDim2.new(1, -10, 0, 24)
        navBtn.Position = UDim2.new(0, 5, 0, btnData.yPos)
        navBtn.BackgroundColor3 = rgb(51, 65, 85)
        navBtn.BackgroundTransparency = 0.5
        navBtn.Text = btnData.label
        navBtn.Font = Enum.Font.GothamBold
        navBtn.TextSize = 8
        navBtn.TextColor3 = rgb(148, 163, 184)
        navBtn.BorderSizePixel = 0
        navBtn.Parent = sidebar

        local btnCorner = Instance.new("UICorner")
        btnCorner.CornerRadius = UDim.new(0, 6)
        btnCorner.Parent = navBtn

        local btnGradient = Instance.new("UIGradient")
        btnGradient.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, rgb(147, 51, 234)),
            ColorSequenceKeypoint.new(1, rgb(8, 145, 178))
        }
        btnGradient.Rotation = 90
        btnGradient.Enabled = false
        btnGradient.Parent = navBtn

        navBtn.MouseButton1Click:Connect(function()
            activeTab = btnData.id
            updateNavButtons()
        end)
    end

    -- Main Content Area
    mainContent = Instance.new("Frame")
    mainContent.Name = "MainContent"
    mainContent.Size = UDim2.new(0, 295, 0, 258)
    mainContent.Position = UDim2.new(0, 100, 0, 42)
    mainContent.BackgroundColor3 = rgb(15, 23, 42)
    mainContent.BackgroundTransparency = 0.4
    mainContent.BorderSizePixel = 0
    mainContent.Parent = container

    local contentCorner = Instance.new("UICorner")
    contentCorner.CornerRadius = UDim.new(0, 8)
    contentCorner.Parent = mainContent

    local contentStroke = Instance.new("UIStroke")
    contentStroke.Color = rgb(51, 65, 85)
    contentStroke.Transparency = 0.5
    contentStroke.Thickness = 1
    contentStroke.Parent = mainContent

    -- Control Panel
    local controlPanel = Instance.new("Frame")
    controlPanel.Name = "controlPanel"
    controlPanel.Size = UDim2.new(1, 0, 1, 0)
    controlPanel.BackgroundTransparency = 1
    controlPanel.Visible = true
    controlPanel.Parent = mainContent

    local controlTitle = Instance.new("TextLabel")
    controlTitle.Name = "ControlTitle"
    controlTitle.Size = UDim2.new(1, -10, 0, 18)
    controlTitle.Position = UDim2.new(0, 5, 0, 5)
    controlTitle.BackgroundTransparency = 1
    controlTitle.Text = "Control Center"
    controlTitle.Font = Enum.Font.GothamBold
    controlTitle.TextSize = 11
    controlTitle.TextColor3 = rgb(255, 255, 255)
    controlTitle.TextXAlignment = Enum.TextXAlignment.Left
    controlTitle.Parent = controlPanel

    -- Record Button
    local recordBtn = Instance.new("TextButton")
    recordBtn.Name = "RecordBtn"
    recordBtn.Size = UDim2.new(0, 138, 0, 45)
    recordBtn.Position = UDim2.new(0, 5, 0, 28)
    recordBtn.BackgroundColor3 = rgb(239, 68, 68)
    recordBtn.BackgroundTransparency = 0.8
    recordBtn.Text = "RECORD"
    recordBtn.Font = Enum.Font.GothamBold
    recordBtn.TextSize = 9
    recordBtn.TextColor3 = rgb(252, 165, 165)
    recordBtn.BorderSizePixel = 0
    recordBtn.Parent = controlPanel
    Instance.new("UICorner", recordBtn).CornerRadius = UDim.new(0, 8)
    local recordStroke = Instance.new("UIStroke")
    recordStroke.Color = rgb(239, 68, 68)
    recordStroke.Transparency = 0.5
    recordStroke.Thickness = 1
    recordStroke.Parent = recordBtn

    -- Play Button
    local playBtn = Instance.new("TextButton")
    playBtn.Name = "PlayBtn"
    playBtn.Size = UDim2.new(0, 138, 0, 45)
    playBtn.Position = UDim2.new(0, 152, 0, 28)
    playBtn.BackgroundColor3 = rgb(34, 197, 94)
    playBtn.BackgroundTransparency = 0.8
    playBtn.Text = "PLAY"
    playBtn.Font = Enum.Font.GothamBold
    playBtn.TextSize = 9
    playBtn.TextColor3 = rgb(134, 239, 172)
    playBtn.BorderSizePixel = 0
    playBtn.Parent = controlPanel
    Instance.new("UICorner", playBtn).CornerRadius = UDim.new(0, 8)
    local playStroke = Instance.new("UIStroke")
    playStroke.Color = rgb(34, 197, 94)
    playStroke.Transparency = 0.5
    playStroke.Thickness = 1
    playStroke.Parent = playBtn

    -- Speed Control Label
    local speedLabel = Instance.new("TextLabel")
    speedLabel.Name = "SpeedLabel"
    speedLabel.Size = UDim2.new(1, -10, 0, 12)
    speedLabel.Position = UDim2.new(0, 5, 0, 80)
    speedLabel.BackgroundTransparency = 1
    speedLabel.Text = "Playback Speed"
    speedLabel.Font = Enum.Font.GothamBold
    speedLabel.TextSize = 8
    speedLabel.TextColor3 = rgb(203, 213, 225)
    speedLabel.TextXAlignment = Enum.TextXAlignment.Left
    speedLabel.Parent = controlPanel

    -- Speed buttons
    local speeds = {"0.5x", "1.0x", "1.5x", "2.0x"}
    local selectedSpeedBtn = nil
    for i, speed in ipairs(speeds) do
        local speedBtn = Instance.new("TextButton")
        speedBtn.Name = "Speed" .. speed
        speedBtn.Size = UDim2.new(0, 68, 0, 24)
        speedBtn.Position = UDim2.new(0, 5 + (i-1) * 73, 0, 95)
        if speed == "1.0x" then
            speedBtn.BackgroundColor3 = rgb(147, 51, 234)
            speedBtn.BackgroundTransparency = 0
            speedBtn.TextColor3 = rgb(255, 255, 255)
            selectedSpeedBtn = speedBtn
            local speedGradient = Instance.new("UIGradient")
            speedGradient.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, rgb(147, 51, 234)),
                ColorSequenceKeypoint.new(1, rgb(8, 145, 178))
            }
            speedGradient.Rotation = 135
            speedGradient.Parent = speedBtn
        else
            speedBtn.BackgroundColor3 = rgb(51, 65, 85)
            speedBtn.BackgroundTransparency = 0.7
            speedBtn.TextColor3 = rgb(203, 213, 225)
            local speedStroke = Instance.new("UIStroke")
            speedStroke.Color = rgb(71, 85, 105)
            speedStroke.Transparency = 0.5
            speedStroke.Thickness = 1
            speedStroke.Parent = speedBtn
        end
        speedBtn.Text = speed
        speedBtn.Font = Enum.Font.GothamBold
        speedBtn.TextSize = 9
        speedBtn.BorderSizePixel = 0
        speedBtn.Parent = controlPanel
        Instance.new("UICorner", speedBtn).CornerRadius = UDim.new(0, 6)

        speedBtn.MouseButton1Click:Connect(function()
            local val = tonumber(speed:sub(1,-2))
            Axiora.SetSpeed(val)
        end)
    end

    -- Save/Load buttons
    local saveBtn = Instance.new("TextButton")
    saveBtn.Name = "SaveBtn"
    saveBtn.Size = UDim2.new(0, 138, 0, 28)
    saveBtn.Position = UDim2.new(0, 5, 0, 125)
    saveBtn.BackgroundColor3 = rgb(51, 65, 85)
    saveBtn.BackgroundTransparency = 0.7
    saveBtn.Text = "Save"
    saveBtn.Font = Enum.Font.GothamBold
    saveBtn.TextSize = 9
    saveBtn.TextColor3 = rgb(226, 232, 240)
    saveBtn.BorderSizePixel = 0
    saveBtn.Parent = controlPanel
    Instance.new("UICorner", saveBtn).CornerRadius = UDim.new(0, 6)
    local saveStroke = Instance.new("UIStroke")
    saveStroke.Color = rgb(71, 85, 105)
    saveStroke.Transparency = 0.5
    saveStroke.Thickness = 1
    saveStroke.Parent = saveBtn
    saveBtn.MouseButton1Click:Connect(function() Axiora.Save() end)

    local loadBtn = Instance.new("TextButton")
    loadBtn.Name = "LoadBtn"
    loadBtn.Size = UDim2.new(0, 138, 0, 28)
    loadBtn.Position = UDim2.new(0, 152, 0, 125)
    loadBtn.BackgroundColor3 = rgb(51, 65, 85)
    loadBtn.BackgroundTransparency = 0.7
    loadBtn.Text = "Load"
    loadBtn.Font = Enum.Font.GothamBold
    loadBtn.TextSize = 9
    loadBtn.TextColor3 = rgb(226, 232, 240)
    loadBtn.BorderSizePixel = 0
    loadBtn.Parent = controlPanel
    Instance.new("UICorner", loadBtn).CornerRadius = UDim.new(0, 6)
    local loadStroke = Instance.new("UIStroke")
    loadStroke.Color = rgb(71, 85, 105)
    loadStroke.Transparency = 0.5
    loadStroke.Thickness = 1
    loadStroke.Parent = loadBtn
    loadBtn.MouseButton1Click:Connect(function() Axiora.UI.ShowLoadPicker() end)

    -- Advanced Options
    local advancedBox = Instance.new("Frame")
    advancedBox.Name = "AdvancedBox"
    advancedBox.Size = UDim2.new(1, -10, 0, 85)
    advancedBox.Position = UDim2.new(0, 5, 0, 165)
    advancedBox.BackgroundColor3 = rgb(30, 41, 59)
    advancedBox.BackgroundTransparency = 0.7
    advancedBox.BorderSizePixel = 0
    advancedBox.Parent = controlPanel
    Instance.new("UICorner", advancedBox).CornerRadius = UDim.new(0, 6)
    local advStroke = Instance.new("UIStroke")
    advStroke.Color = rgb(51, 65, 85)
    advStroke.Transparency = 0.5
    advStroke.Thickness = 1
    advStroke.Parent = advancedBox

    local advLabel = Instance.new("TextLabel")
    advLabel.Name = "AdvLabel"
    advLabel.Size = UDim2.new(1, -10, 0, 12)
    advLabel.Position = UDim2.new(0, 5, 0, 3)
    advLabel.BackgroundTransparency = 1
    advLabel.Text = "ADVANCED OPTIONS"
    advLabel.Font = Enum.Font.GothamBold
    advLabel.TextSize = 7
    advLabel.TextColor3 = rgb(148, 163, 184)
    advLabel.TextXAlignment = Enum.TextXAlignment.Left
    advLabel.Parent = advancedBox

    -- Toggle switches
    local toggles = {"Loop Playback", "Click Recovery", "3D Path Visualization"}
    local toggleStates = {false, true, false}
    for i, toggleName in ipairs(toggles) do
        local toggleLabel = Instance.new("TextLabel")
        toggleLabel.Name = toggleName:gsub(" ", "")
        toggleLabel.Size = UDim2.new(1, -40, 0, 14)
        toggleLabel.Position = UDim2.new(0, 5, 0, 18 + (i-1) * 22)
        toggleLabel.BackgroundTransparency = 1
        toggleLabel.Text = toggleName
        toggleLabel.Font = Enum.Font.Gotham
        toggleLabel.TextSize = 8
        toggleLabel.TextColor3 = rgb(203, 213, 225)
        toggleLabel.TextXAlignment = Enum.TextXAlignment.Left
        toggleLabel.Parent = advancedBox

        local toggleSwitch = Instance.new("Frame")
        toggleSwitch.Name = toggleName:gsub(" ", "") .. "Switch"
        toggleSwitch.Size = UDim2.new(0, 28, 0, 14)
        toggleSwitch.Position = UDim2.new(1, -33, 0, 18 + (i-1) * 22)
        toggleSwitch.BackgroundColor3 = toggleStates[i] and rgb(147, 51, 234) or rgb(51, 65, 85)
        toggleSwitch.BorderSizePixel = 0
        toggleSwitch.Parent = advancedBox
        Instance.new("UICorner", toggleSwitch).CornerRadius = UDim.new(1, 0)

        if toggleStates[i] then
            local switchGradient = Instance.new("UIGradient")
            switchGradient.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, rgb(147, 51, 234)),
                ColorSequenceKeypoint.new(1, rgb(8, 145, 178))
            }
            switchGradient.Rotation = 90
            switchGradient.Parent = toggleSwitch
        end

        local switchKnob = Instance.new("Frame")
        switchKnob.Name = "Knob"
        switchKnob.Size = UDim2.new(0, 12, 0, 12)
        switchKnob.Position = toggleStates[i] and UDim2.new(0, 15, 0, 1) or UDim2.new(0, 1, 0, 1)
        switchKnob.BackgroundColor3 = rgb(255, 255, 255)
        switchKnob.BorderSizePixel = 0
        switchKnob.Parent = toggleSwitch
        Instance.new("UICorner", switchKnob).CornerRadius = UDim.new(1, 0)
    end

    -- Other panels
    local editorPanel = Instance.new("Frame")
    editorPanel.Name = "editorPanel"
    editorPanel.Size = UDim2.new(1, 0, 1, 0)
    editorPanel.BackgroundTransparency = 1
    editorPanel.Visible = false
    editorPanel.Parent = mainContent

    local editorTitle = Instance.new("TextLabel")
    editorTitle.Size = UDim2.new(1, -10, 0, 18)
    editorTitle.Position = UDim2.new(0, 5, 0, 5)
    editorTitle.BackgroundTransparency = 1
    editorTitle.Text = "Macro Editor"
    editorTitle.Font = Enum.Font.GothamBold
    editorTitle.TextSize = 11
    editorTitle.TextColor3 = rgb(255, 255, 255)
    editorTitle.TextXAlignment = Enum.TextXAlignment.Left
    editorTitle.Parent = editorPanel

    local editorPlaceholder = Instance.new("Frame")
    editorPlaceholder.Size = UDim2.new(1, -10, 0, 200)
    editorPlaceholder.Position = UDim2.new(0, 5, 0, 30)
    editorPlaceholder.BackgroundColor3 = rgb(30, 41, 59)
    editorPlaceholder.BackgroundTransparency = 0.5
    editorPlaceholder.BorderSizePixel = 0
    editorPlaceholder.Parent = editorPanel
    Instance.new("UICorner", editorPlaceholder).CornerRadius = UDim.new(0, 6)
    local editorStroke = Instance.new("UIStroke")
    editorStroke.Color = rgb(51, 65, 85)
    editorStroke.Transparency = 0.5
    editorStroke.Thickness = 1
    editorStroke.Parent = editorPlaceholder

    local editorText = Instance.new("TextLabel")
    editorText.Size = UDim2.new(1, 0, 1, 0)
    editorText.BackgroundTransparency = 1
    editorText.Text = "Node editor interface here"
    editorText.Font = Enum.Font.Gotham
    editorText.TextSize = 10
    editorText.TextColor3 = rgb(148, 163, 184)
    editorText.Parent = editorPlaceholder

    -- Library Panel
    local libraryPanel = Instance.new("Frame")
    libraryPanel.Name = "libraryPanel"
    libraryPanel.Size = UDim2.new(1, 0, 1, 0)
    libraryPanel.BackgroundTransparency = 1
    libraryPanel.Visible = false
    libraryPanel.Parent = mainContent

    local libraryTitle = Instance.new("TextLabel")
    libraryTitle.Size = UDim2.new(1, -10, 0, 18)
    libraryTitle.Position = UDim2.new(0, 5, 0, 5)
    libraryTitle.BackgroundTransparency = 1
    libraryTitle.Text = "Macro Library"
    libraryTitle.Font = Enum.Font.GothamBold
    libraryTitle.TextSize = 11
    libraryTitle.TextColor3 = rgb(255, 255, 255)
    libraryTitle.TextXAlignment = Enum.TextXAlignment.Left
    libraryTitle.Parent = libraryPanel

    local macros = {"Farming Route", "PvP Combo", "Auto Craft", "Boss Fight"}
    for i, macroName in ipairs(macros) do
        local row = math.floor((i-1) / 2)
        local col = (i-1) % 2
        local macroCard = Instance.new("Frame")
        macroCard.Name = macroName:gsub(" ", "")
        macroCard.Size = UDim2.new(0, 138, 0, 55)
        macroCard.Position = UDim2.new(0, 5 + col * 147, 0, 28 + row * 65)
        macroCard.BackgroundColor3 = rgb(30, 41, 59)
        macroCard.BackgroundTransparency = 0.7
        macroCard.BorderSizePixel = 0
        macroCard.Parent = libraryPanel
        Instance.new("UICorner", macroCard).CornerRadius = UDim.new(0, 6)
        local macroStroke = Instance.new("UIStroke")
        macroStroke.Color = rgb(51, 65, 85)
        macroStroke.Transparency = 0.5
        macroStroke.Thickness = 1
        macroStroke.Parent = macroCard

        local macroTitle = Instance.new("TextLabel")
        macroTitle.Size = UDim2.new(1, -10, 0, 16)
        macroTitle.Position = UDim2.new(0, 5, 0, 32)
        macroTitle.BackgroundTransparency = 1
        macroTitle.Text = macroName
        macroTitle.Font = Enum.Font.GothamBold
        macroTitle.TextSize = 9
        macroTitle.TextColor3 = rgb(255, 255, 255)
        macroTitle.TextXAlignment = Enum.TextXAlignment.Left
        macroTitle.Parent = macroCard

        local macroInfo = Instance.new("TextLabel")
        macroInfo.Size = UDim2.new(1, -10, 0, 10)
        macroInfo.Position = UDim2.new(0, 5, 0, 46)
        macroInfo.BackgroundTransparency = 1
        macroInfo.Text = "Last modified: 2h ago"
        macroInfo.Font = Enum.Font.Gotham
        macroInfo.TextSize = 7
        macroInfo.TextColor3 = rgb(148, 163, 184)
        macroInfo.TextXAlignment = Enum.TextXAlignment.Left
        macroInfo.Parent = macroCard
    end

    -- Automation Panel
    local automationPanel = Instance.new("Frame")
    automationPanel.Name = "automationPanel"
    automationPanel.Size = UDim2.new(1, 0, 1, 0)
    automationPanel.BackgroundTransparency = 1
    automationPanel.Visible = false
    automationPanel.Parent = mainContent

    local autoTitle = Instance.new("TextLabel")
    autoTitle.Size = UDim2.new(0, 180, 0, 18)
    autoTitle.Position = UDim2.new(0, 5, 0, 5)
    autoTitle.BackgroundTransparency = 1
    autoTitle.Text = "Automation Rules"
    autoTitle.Font = Enum.Font.GothamBold
    autoTitle.TextSize = 11
    autoTitle.TextColor3 = rgb(255, 255, 255)
    autoTitle.TextXAlignment = Enum.TextXAlignment.Left
    autoTitle.Parent = automationPanel

    local newRuleBtn = Instance.new("TextButton")
    newRuleBtn.Size = UDim2.new(0, 70, 0, 22)
    newRuleBtn.Position = UDim2.new(1, -75, 0, 5)
    newRuleBtn.BackgroundColor3 = rgb(147, 51, 234)
    newRuleBtn.Text = "+ New Rule"
    newRuleBtn.Font = Enum.Font.GothamBold
    newRuleBtn.TextSize = 8
    newRuleBtn.TextColor3 = rgb(255, 255, 255)
    newRuleBtn.BorderSizePixel = 0
    newRuleBtn.Parent = automationPanel
    Instance.new("UICorner", newRuleBtn).CornerRadius = UDim.new(0, 5)
    local newRuleGradient = Instance.new("UIGradient")
    newRuleGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, rgb(147, 51, 234)),
        ColorSequenceKeypoint.new(1, rgb(8, 145, 178))
    }
    newRuleGradient.Rotation = 90
    newRuleGradient.Parent = newRuleBtn

    -- Settings Panel
    local settingsPanel = Instance.new("Frame")
    settingsPanel.Name = "settingsPanel"
    settingsPanel.Size = UDim2.new(1, 0, 1, 0)
    settingsPanel.BackgroundTransparency = 1
    settingsPanel.Visible = false
    settingsPanel.Parent = mainContent

    local settingsTitle = Instance.new("TextLabel")
    settingsTitle.Size = UDim2.new(1, -10, 0, 18)
    settingsTitle.Position = UDim2.new(0, 5, 0, 5)
    settingsTitle.BackgroundTransparency = 1
    settingsTitle.Text = "Settings"
    settingsTitle.Font = Enum.Font.GothamBold
    settingsTitle.TextSize = 11
    settingsTitle.TextColor3 = rgb(255, 255, 255)
    settingsTitle.TextXAlignment = Enum.TextXAlignment.Left
    settingsTitle.Parent = settingsPanel

    -- Footer
    local footer = Instance.new("TextLabel")
    footer.Name = "Footer"
    footer.Size = UDim2.new(1, 0, 0, 16)
    footer.Position = UDim2.new(0, 0, 1, -20)
    footer.BackgroundTransparency = 1
    footer.Text = "Axiora v6.0 • Idle • Uptime: 0m"
    footer.Font = Enum.Font.Code
    footer.TextSize = 7
    footer.TextColor3 = rgb(100, 116, 139)
    footer.Parent = container

    -- Button Functionality
    local function updateStatus()
        local isRecording = Axiora.State.Status == "RECORDING"
        local isPlaying = Axiora.State.Status == "PLAYING"

        if isRecording then
            statusText.Text = "RECORDING"
            statusIndicator.BackgroundColor3 = rgb(239, 68, 68)
            statusIndicator.BackgroundTransparency = 0.8
            statusDot.BackgroundColor3 = rgb(248, 113, 113)
            recordBtn.Text = "STOP REC"
            recordBtn.BackgroundColor3 = rgb(220, 38, 38)
            recordBtn.BackgroundTransparency = 0
        elseif isPlaying then
            statusText.Text = "PLAYING"
            statusIndicator.BackgroundColor3 = rgb(34, 197, 94)
            statusIndicator.BackgroundTransparency = 0.8
            statusDot.BackgroundColor3 = rgb(74, 222, 128)
            playBtn.Text = "STOP"
            playBtn.BackgroundColor3 = rgb(21, 128, 61)
            playBtn.BackgroundTransparency = 0
        else
            statusText.Text = "IDLE"
            statusIndicator.BackgroundColor3 = rgb(51, 65, 85)
            statusIndicator.BackgroundTransparency = 0.7
            statusDot.BackgroundColor3 = rgb(148, 163, 184)
            recordBtn.Text = "RECORD"
            recordBtn.BackgroundColor3 = rgb(239, 68, 68)
            recordBtn.BackgroundTransparency = 0.8
            playBtn.Text = "PLAY"
            playBtn.BackgroundColor3 = rgb(34, 197, 94)
            playBtn.BackgroundTransparency = 0.8
        end

        nodeCountLabel.Text = #Axiora.State.Buffer .. " nodes"
    end

    recordBtn.MouseButton1Click:Connect(function()
        if Axiora.State.Status == "RECORDING" then
            Axiora.Stop()
        else
            Axiora.Record()
        end
        updateStatus()
    end)

    playBtn.MouseButton1Click:Connect(function()
        if Axiora.State.Status == "PLAYING" then
            Axiora.Pause()
        elseif Axiora.State.Status == "PAUSED" then
            Axiora.Resume()
        else
            Axiora.Play(true)
        end
        updateStatus()
    end)

    -- Initialize
    updateNavButtons()
    updateStatus()

    -- Toggle Button
    local toggleButton = Instance.new("TextButton")
    toggleButton.Name = "ToggleButton"
    toggleButton.Size = UDim2.new(0, 50, 0, 50)
    toggleButton.Position = UDim2.new(0, 10, 0, 10)
    toggleButton.BackgroundColor3 = rgb(15, 23, 42)
    toggleButton.BackgroundTransparency = 0.3
    toggleButton.Text = "✕"
    toggleButton.Font = Enum.Font.GothamBold
    toggleButton.TextSize = 24
    toggleButton.TextColor3 = rgb(167, 139, 250)
    toggleButton.BorderSizePixel = 0
    toggleButton.Parent = screenGui
    Instance.new("UICorner", toggleButton).CornerRadius = UDim.new(0, 12)
    Axiora.UI.ToggleButton = toggleButton

    local toggleStroke = Instance.new("UIStroke")
    toggleStroke.Color = rgb(168, 85, 247)
    toggleStroke.Transparency = 0.3
    toggleStroke.Thickness = 2
    toggleStroke.Parent = toggleButton

    local toggleGradient = Instance.new("UIGradient")
    toggleGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, rgb(2, 6, 23)),
        ColorSequenceKeypoint.new(0.5, rgb(59, 7, 100)),
        ColorSequenceKeypoint.new(1, rgb(2, 6, 23))
    }
    toggleGradient.Rotation = 135
    toggleGradient.Parent = toggleButton

    local isGuiVisible = true
    toggleButton.MouseButton1Click:Connect(function()
        isGuiVisible = not isGuiVisible
        container.Visible = isGuiVisible
        if isGuiVisible then
            toggleButton.Text = "✕"
            toggleButton.TextSize = 24
        else
            toggleButton.Text = "☰"
            toggleButton.TextSize = 20
        end
        Axiora.UI.Open = isGuiVisible
    end)

    -- Make GUI Draggable
    local dragging = false
    local dragInput
    local dragStart
    local startPos

    local function update(input)
        local delta = input.Position - dragStart
        container.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end

    statusBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = container.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    statusBar.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    game:GetService("UserInputService").InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            update(input)
        end
    end)

    -- Status update loop
    task.spawn(function()
        while screenGui.Parent do
            updateStatus()
            task.wait(0.2)
        end
    end)

    return screenGui
end


-- Speed preset function
function Axiora.UI.SetSpeed(preset)
    -- Fixed: Use Settings.SpeedPresets instead of UI.SpeedPresets
    local presets = Axiora.Settings.SpeedPresets or {
        careful = 0.5,
        normal = 1.0,
        fast = 1.5,
        turbo = 2.0
    }
    
    if presets[preset] then
        Axiora.Settings.TimeScale = presets[preset]
        Axiora.UI.CurrentSpeed = preset
        if Axiora.Visuals and Axiora.Visuals.Notify then
            pcall(function()
                Axiora.Visuals.Notify("Speed", "Playback: " .. preset .. " (" .. presets[preset] .. "x)", 2, "info")
            end)
        end
    end
end

-- Also add global shorthand
function Axiora.SetSpeed(preset)
    Axiora.UI.SetSpeed(preset)
end

-- PlayTimes shorthand
function Axiora.PlayTimes(count)
    return Axiora.Play(count)
end

-- Export macro as shareable code
function Axiora.Export(name)
    if #Axiora.State.Buffer == 0 then
        Axiora.Visuals.Notify("Export", "No macro to export", 2, "warning")
        return nil
    end
    
    local data = {
        name = name or "exported_macro",
        version = Axiora._VERSION,
        buffer = Axiora.State.Buffer
    }
    
    local json = HttpService:JSONEncode(data)
    
    if Axiora.Capabilities.SetClipboard then
        pcall(function()
            setclipboard(json)
        end)
        Axiora.Visuals.Notify("Export", "Macro copied to clipboard!", 3, "success")
    else
        Axiora.Visuals.Notify("Export", "Clipboard not available - check console", 3, "warning")
    end
    
    print("=== EXPORTED MACRO ===")
    print(json)
    print("======================")
    
    return json
end






-- ═══════════════════════════════════════════════════════════════════════════════
-- QUICK LOAD PICKER UI
-- ═══════════════════════════════════════════════════════════════════════════════

function Axiora.UI.ShowLoadPicker()
    if not Axiora.UI.ScreenGui then return end
    
    local theme = Axiora.Visuals.GetTheme()
    local saves = Axiora.ListSaves()
    
    if #saves == 0 then
        Axiora.Visuals.Notify("Load", "No saved macros found", 2, "warning")
        return
    end
    
    -- Create overlay
    local overlay = Instance.new("Frame")
    overlay.Name = "LoadPickerOverlay"
    overlay.BackgroundColor3 = Color3.new(0, 0, 0)
    overlay.BackgroundTransparency = 0.5
    overlay.Size = UDim2.new(1, 0, 1, 0)
    overlay.ZIndex = 200
    overlay.Parent = Axiora.UI.ScreenGui
    
    -- Create picker panel
    local picker = Instance.new("Frame")
    picker.Name = "LoadPicker"
    picker.BackgroundColor3 = theme.Background
    picker.BackgroundTransparency = 0.05
    picker.Size = UDim2.new(0, 300, 0, math.min(400, 80 + #saves * 45))
    picker.Position = UDim2.new(0.5, 0, 0.5, 0)
    picker.AnchorPoint = Vector2.new(0.5, 0.5)
    picker.BorderSizePixel = 0
    picker.ZIndex = 201
    picker.Parent = overlay
    
    Instance.new("UICorner", picker).CornerRadius = UDim.new(0, 12)
    
    local pickerStroke = Instance.new("UIStroke")
    pickerStroke.Color = theme.Primary
    pickerStroke.Transparency = 0.3
    pickerStroke.Thickness = 2
    pickerStroke.Parent = picker
    
    -- Title
    local title = Instance.new("TextLabel")
    title.BackgroundTransparency = 1
    title.Size = UDim2.new(1, -20, 0, 35)
    title.Position = UDim2.new(0, 10, 0, 10)
    title.Text = "📂 LOAD MACRO"
    title.TextColor3 = theme.Primary
    title.Font = Enum.Font.GothamBlack
    title.TextSize = 16
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.Parent = picker
    
    -- Scrolling list
    local scroll = Instance.new("ScrollingFrame")
    scroll.BackgroundTransparency = 1
    scroll.Size = UDim2.new(1, -20, 1, -100)
    scroll.Position = UDim2.new(0, 10, 0, 50)
    scroll.CanvasSize = UDim2.new(0, 0, 0, #saves * 45)
    scroll.ScrollBarThickness = 4
    scroll.ScrollBarImageColor3 = theme.Primary
    scroll.BorderSizePixel = 0
    scroll.Parent = picker
    
    local listLayout = Instance.new("UIListLayout")
    listLayout.Padding = UDim.new(0, 5)
    listLayout.Parent = scroll
    
    -- Create macro buttons
    for i, saveName in ipairs(saves) do
        local btn = Instance.new("TextButton")
        btn.Name = saveName
        btn.BackgroundColor3 = theme.Surface
        btn.BackgroundTransparency = 0.3
        btn.Size = UDim2.new(1, -10, 0, 40)
        btn.Text = "  📄 " .. saveName
        btn.TextColor3 = theme.Text
        btn.Font = Enum.Font.GothamBold
        btn.TextSize = 13
        btn.TextXAlignment = Enum.TextXAlignment.Left
        btn.AutoButtonColor = false
        btn.BorderSizePixel = 0
        btn.Parent = scroll
        
        Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 8)
        
        btn.MouseEnter:Connect(function()
            TweenService:Create(btn, TweenInfo.new(0.15), {
                BackgroundColor3 = theme.Primary,
                BackgroundTransparency = 0.2
            }):Play()
        end)
        btn.MouseLeave:Connect(function()
            TweenService:Create(btn, TweenInfo.new(0.15), {
                BackgroundColor3 = theme.Surface,
                BackgroundTransparency = 0.3
            }):Play()
        end)
        btn.MouseButton1Click:Connect(function()
            overlay:Destroy()
            Axiora.Load(saveName)
        end)
    end
    
    -- Cancel button
    local cancelBtn = Instance.new("TextButton")
    cancelBtn.BackgroundColor3 = theme.Error
    cancelBtn.BackgroundTransparency = 0.6
    cancelBtn.Size = UDim2.new(1, -20, 0, 35)
    cancelBtn.Position = UDim2.new(0, 10, 1, -45)
    cancelBtn.Text = "✕ CANCEL"
    cancelBtn.TextColor3 = theme.Text
    cancelBtn.Font = Enum.Font.GothamBold
    cancelBtn.TextSize = 12
    cancelBtn.AutoButtonColor = false
    cancelBtn.BorderSizePixel = 0
    cancelBtn.Parent = picker
    Instance.new("UICorner", cancelBtn).CornerRadius = UDim.new(0, 8)
    
    cancelBtn.MouseButton1Click:Connect(function()
        overlay:Destroy()
    end)
    
    -- Click overlay to close
    overlay.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            local mousePos = UserInputService:GetMouseLocation()
            local pickerPos = picker.AbsolutePosition
            local pickerSize = picker.AbsoluteSize
            if mousePos.X < pickerPos.X or mousePos.X > pickerPos.X + pickerSize.X or
               mousePos.Y < pickerPos.Y or mousePos.Y > pickerPos.Y + pickerSize.Y then
                overlay:Destroy()
            end
        end
    end)
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- MACRO EDITOR PANEL UI
-- ═══════════════════════════════════════════════════════════════════════════════

function Axiora.UI.ShowEditorPanel()
    if not Axiora.UI.ScreenGui then return end
    
    local theme = Axiora.Visuals.GetTheme()
    local nodes = Axiora.EditBuffer()
    
    if #nodes == 0 then
        Axiora.Visuals.Notify("Editor", "No macro loaded to edit", 2, "warning")
        return
    end
    
    -- Create overlay
    local overlay = Instance.new("Frame")
    overlay.Name = "EditorOverlay"
    overlay.BackgroundColor3 = Color3.new(0, 0, 0)
    overlay.BackgroundTransparency = 0.5
    overlay.Size = UDim2.new(1, 0, 1, 0)
    overlay.ZIndex = 200
    overlay.Parent = Axiora.UI.ScreenGui
    
    -- Create editor panel
    local editor = Instance.new("Frame")
    editor.Name = "EditorPanel"
    editor.BackgroundColor3 = theme.Background
    editor.BackgroundTransparency = 0.05
    editor.Size = UDim2.new(0, 450, 0, 500)
    editor.Position = UDim2.new(0.5, 0, 0.5, 0)
    editor.AnchorPoint = Vector2.new(0.5, 0.5)
    editor.BorderSizePixel = 0
    editor.ZIndex = 201
    editor.Parent = overlay
    
    Instance.new("UICorner", editor).CornerRadius = UDim.new(0, 12)
    
    local editorStroke = Instance.new("UIStroke")
    editorStroke.Color = theme.Warning
    editorStroke.Transparency = 0.3
    editorStroke.Thickness = 2
    editorStroke.Parent = editor
    
    -- Title
    local title = Instance.new("TextLabel")
    title.BackgroundTransparency = 1
    title.Size = UDim2.new(1, -100, 0, 35)
    title.Position = UDim2.new(0, 15, 0, 10)
    title.Text = "✏️ MACRO EDITOR (" .. #nodes .. " nodes)"
    title.TextColor3 = theme.Warning
    title.Font = Enum.Font.GothamBlack
    title.TextSize = 16
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.Parent = editor
    
    -- Close button
    local closeBtn = Instance.new("TextButton")
    closeBtn.BackgroundColor3 = theme.Error
    closeBtn.BackgroundTransparency = 0.7
    closeBtn.Size = UDim2.new(0, 30, 0, 30)
    closeBtn.Position = UDim2.new(1, -40, 0, 10)
    closeBtn.Text = "✕"
    closeBtn.TextColor3 = theme.Text
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.TextSize = 14
    closeBtn.AutoButtonColor = false
    closeBtn.BorderSizePixel = 0
    closeBtn.Parent = editor
    Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0, 6)
    closeBtn.MouseButton1Click:Connect(function()
        overlay:Destroy()
    end)
    
    -- Scrolling list of nodes
    local scroll = Instance.new("ScrollingFrame")
    scroll.BackgroundColor3 = theme.Surface
    scroll.BackgroundTransparency = 0.7
    scroll.Size = UDim2.new(1, -30, 1, -100)
    scroll.Position = UDim2.new(0, 15, 0, 50)
    scroll.CanvasSize = UDim2.new(0, 0, 0, #nodes * 50)
    scroll.ScrollBarThickness = 5
    scroll.ScrollBarImageColor3 = theme.Primary
    scroll.BorderSizePixel = 0
    scroll.Parent = editor
    Instance.new("UICorner", scroll).CornerRadius = UDim.new(0, 8)
    
    local listLayout = Instance.new("UIListLayout")
    listLayout.Padding = UDim.new(0, 3)
    listLayout.Parent = scroll
    
    local function refreshNodeList()
        for _, child in ipairs(scroll:GetChildren()) do
            if child:IsA("Frame") then child:Destroy() end
        end
        
        local updatedNodes = Axiora.EditBuffer()
        scroll.CanvasSize = UDim2.new(0, 0, 0, #updatedNodes * 50)
        title.Text = "✏️ MACRO EDITOR (" .. #updatedNodes .. " nodes)"
        
        for i, node in ipairs(updatedNodes) do
            local row = Instance.new("Frame")
            row.Name = "Node_" .. i
            row.BackgroundColor3 = i % 2 == 0 and theme.Surface or theme.Background
            row.BackgroundTransparency = 0.5
            row.Size = UDim2.new(1, -10, 0, 45)
            row.BorderSizePixel = 0
            row.Parent = scroll
            Instance.new("UICorner", row).CornerRadius = UDim.new(0, 6)
            
            -- Index
            local idxLabel = Instance.new("TextLabel")
            idxLabel.BackgroundTransparency = 1
            idxLabel.Size = UDim2.new(0, 35, 1, 0)
            idxLabel.Position = UDim2.new(0, 5, 0, 0)
            idxLabel.Text = "#" .. i
            idxLabel.TextColor3 = theme.TextDim
            idxLabel.Font = Enum.Font.GothamBold
            idxLabel.TextSize = 10
            idxLabel.Parent = row
            
            -- Type icon
            local typeIcon = node.Type == "Move" and "🚶" or node.Type == "Click" and "👆" or node.Type == "Key" and "⌨️" or "?"
            local typeLabel = Instance.new("TextLabel")
            typeLabel.BackgroundTransparency = 1
            typeLabel.Size = UDim2.new(0, 30, 1, 0)
            typeLabel.Position = UDim2.new(0, 40, 0, 0)
            typeLabel.Text = typeIcon
            typeLabel.TextColor3 = theme.Text
            typeLabel.Font = Enum.Font.Gotham
            typeLabel.TextSize = 16
            typeLabel.Parent = row
            
            -- Details
            local details = ""
            if node.Type == "Move" then
                local p = node.Position or {0,0,0}
                details = string.format("Pos: %.0f, %.0f, %.0f", p[1] or 0, p[2] or 0, p[3] or 0)
            elseif node.Type == "Click" then
                details = string.format("Click: %.2f, %.2f", node.X or 0, node.Y or 0)
            elseif node.Type == "Key" then
                details = "Key: " .. (node.Key or "?")
            end
            
            local detailLabel = Instance.new("TextLabel")
            detailLabel.BackgroundTransparency = 1
            detailLabel.Size = UDim2.new(0, 200, 1, 0)
            detailLabel.Position = UDim2.new(0, 75, 0, 0)
            detailLabel.Text = details
            detailLabel.TextColor3 = theme.Text
            detailLabel.Font = Enum.Font.Gotham
            detailLabel.TextSize = 11
            detailLabel.TextXAlignment = Enum.TextXAlignment.Left
            detailLabel.TextTruncate = Enum.TextTruncate.AtEnd
            detailLabel.Parent = row
            
            -- Delay
            local delayLabel = Instance.new("TextLabel")
            delayLabel.BackgroundTransparency = 1
            delayLabel.Size = UDim2.new(0, 50, 1, 0)
            delayLabel.Position = UDim2.new(0, 280, 0, 0)
            delayLabel.Text = string.format("%.2fs", node.Delay or 0)
            delayLabel.TextColor3 = theme.TextDim
            delayLabel.Font = Enum.Font.Gotham
            delayLabel.TextSize = 10
            delayLabel.Parent = row
            
            -- Delete button
            local delBtn = Instance.new("TextButton")
            delBtn.BackgroundColor3 = theme.Error
            delBtn.BackgroundTransparency = 0.6
            delBtn.Size = UDim2.new(0, 55, 0, 28)
            delBtn.Position = UDim2.new(1, -65, 0.5, 0)
            delBtn.AnchorPoint = Vector2.new(0, 0.5)
            delBtn.Text = "🗑️ DEL"
            delBtn.TextColor3 = theme.Text
            delBtn.Font = Enum.Font.GothamBold
            delBtn.TextSize = 10
            delBtn.AutoButtonColor = false
            delBtn.BorderSizePixel = 0
            delBtn.Parent = row
            Instance.new("UICorner", delBtn).CornerRadius = UDim.new(0, 5)
            
            local nodeIndex = i
            delBtn.MouseButton1Click:Connect(function()
                Axiora.DeleteNode(nodeIndex)
                refreshNodeList()
            end)
        end
    end
    
    refreshNodeList()
    
    -- Footer with info
    local footer = Instance.new("TextLabel")
    footer.BackgroundTransparency = 1
    footer.Size = UDim2.new(1, 0, 0, 30)
    footer.Position = UDim2.new(0, 0, 1, -40)
    footer.Text = "Click DEL to remove nodes • Changes are immediate"
    footer.TextColor3 = theme.TextDim
    footer.Font = Enum.Font.Gotham
    footer.TextSize = 10
    footer.Parent = editor
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- MACRO COMBINE PANEL UI
-- ═══════════════════════════════════════════════════════════════════════════════

function Axiora.UI.ShowCombinePanel()
    if not Axiora.UI.ScreenGui then return end
    
    local theme = Axiora.Visuals.GetTheme()
    local saves = Axiora.ListSaves()
    
    if #saves < 2 then
        Axiora.Visuals.Notify("Combine", "Need at least 2 saved macros", 2, "warning")
        return
    end
    
    -- Create overlay
    local overlay = Instance.new("Frame")
    overlay.Name = "CombineOverlay"
    overlay.BackgroundColor3 = Color3.new(0, 0, 0)
    overlay.BackgroundTransparency = 0.5
    overlay.Size = UDim2.new(1, 0, 1, 0)
    overlay.ZIndex = 200
    overlay.Parent = Axiora.UI.ScreenGui
    
    -- Create combine panel
    local panel = Instance.new("Frame")
    panel.Name = "CombinePanel"
    panel.BackgroundColor3 = theme.Background
    panel.BackgroundTransparency = 0.05
    panel.Size = UDim2.new(0, 350, 0, 320)
    panel.Position = UDim2.new(0.5, 0, 0.5, 0)
    panel.AnchorPoint = Vector2.new(0.5, 0.5)
    panel.BorderSizePixel = 0
    panel.ZIndex = 201
    panel.Parent = overlay
    
    Instance.new("UICorner", panel).CornerRadius = UDim.new(0, 12)
    
    local panelStroke = Instance.new("UIStroke")
    panelStroke.Color = theme.Secondary
    panelStroke.Transparency = 0.3
    panelStroke.Thickness = 2
    panelStroke.Parent = panel
    
    -- Title
    local title = Instance.new("TextLabel")
    title.BackgroundTransparency = 1
    title.Size = UDim2.new(1, -20, 0, 35)
    title.Position = UDim2.new(0, 15, 0, 10)
    title.Text = "🔗 COMBINE MACROS"
    title.TextColor3 = theme.Secondary
    title.Font = Enum.Font.GothamBlack
    title.TextSize = 16
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.Parent = panel
    
    local selectedMacro1 = nil
    local selectedMacro2 = nil
    
    local function createDropdown(yPos, labelText, onSelect)
        local label = Instance.new("TextLabel")
        label.BackgroundTransparency = 1
        label.Size = UDim2.new(0, 100, 0, 25)
        label.Position = UDim2.new(0, 15, 0, yPos)
        label.Text = labelText
        label.TextColor3 = theme.TextDim
        label.Font = Enum.Font.GothamBold
        label.TextSize = 11
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = panel
        
        local dropdown = Instance.new("TextButton")
        dropdown.BackgroundColor3 = theme.Surface
        dropdown.BackgroundTransparency = 0.3
        dropdown.Size = UDim2.new(1, -130, 0, 35)
        dropdown.Position = UDim2.new(0, 115, 0, yPos - 5)
        dropdown.Text = "  Select macro..."
        dropdown.TextColor3 = theme.Text
        dropdown.Font = Enum.Font.Gotham
        dropdown.TextSize = 12
        dropdown.TextXAlignment = Enum.TextXAlignment.Left
        dropdown.AutoButtonColor = false
        dropdown.BorderSizePixel = 0
        dropdown.Parent = panel
        Instance.new("UICorner", dropdown).CornerRadius = UDim.new(0, 6)
        
        dropdown.MouseButton1Click:Connect(function()
            -- Create dropdown list
            local ddList = Instance.new("ScrollingFrame")
            ddList.BackgroundColor3 = theme.Surface
            ddList.Size = UDim2.new(0, dropdown.AbsoluteSize.X, 0, math.min(150, #saves * 30))
            ddList.Position = UDim2.new(0, 115, 0, yPos + 30)
            ddList.CanvasSize = UDim2.new(0, 0, 0, #saves * 30)
            ddList.ScrollBarThickness = 3
            ddList.BorderSizePixel = 0
            ddList.ZIndex = 210
            ddList.Parent = panel
            Instance.new("UICorner", ddList).CornerRadius = UDim.new(0, 6)
            
            local ddLayout = Instance.new("UIListLayout")
            ddLayout.Parent = ddList
            
            for _, saveName in ipairs(saves) do
                local opt = Instance.new("TextButton")
                opt.BackgroundColor3 = theme.Surface
                opt.BackgroundTransparency = 0.2
                opt.Size = UDim2.new(1, 0, 0, 28)
                opt.Text = "  " .. saveName
                opt.TextColor3 = theme.Text
                opt.Font = Enum.Font.Gotham
                opt.TextSize = 11
                opt.TextXAlignment = Enum.TextXAlignment.Left
                opt.BorderSizePixel = 0
                opt.ZIndex = 211
                opt.Parent = ddList
                
                opt.MouseEnter:Connect(function()
                    opt.BackgroundColor3 = theme.Primary
                end)
                opt.MouseLeave:Connect(function()
                    opt.BackgroundColor3 = theme.Surface
                end)
                opt.MouseButton1Click:Connect(function()
                    dropdown.Text = "  " .. saveName
                    onSelect(saveName)
                    ddList:Destroy()
                end)
            end
            
            -- Close on click outside
            task.delay(0.1, function()
                local conn
                conn = UserInputService.InputBegan:Connect(function(input)
                    if input.UserInputType == Enum.UserInputType.MouseButton1 then
                        task.wait(0.1)
                        if ddList and ddList.Parent then
                            ddList:Destroy()
                        end
                        if conn then conn:Disconnect() end
                    end
                end)
            end)
        end)
        
        return dropdown
    end
    
    createDropdown(55, "First Macro:", function(name) selectedMacro1 = name end)
    createDropdown(105, "Second Macro:", function(name) selectedMacro2 = name end)
    
    -- Output name
    local outputLabel = Instance.new("TextLabel")
    outputLabel.BackgroundTransparency = 1
    outputLabel.Size = UDim2.new(0, 100, 0, 25)
    outputLabel.Position = UDim2.new(0, 15, 0, 155)
    outputLabel.Text = "Output Name:"
    outputLabel.TextColor3 = theme.TextDim
    outputLabel.Font = Enum.Font.GothamBold
    outputLabel.TextSize = 11
    outputLabel.TextXAlignment = Enum.TextXAlignment.Left
    outputLabel.Parent = panel
    
    local outputBox = Instance.new("TextBox")
    outputBox.BackgroundColor3 = theme.Surface
    outputBox.BackgroundTransparency = 0.3
    outputBox.Size = UDim2.new(1, -130, 0, 35)
    outputBox.Position = UDim2.new(0, 115, 0, 150)
    outputBox.Text = ""
    outputBox.PlaceholderText = "combined_macro"
    outputBox.TextColor3 = theme.Text
    outputBox.PlaceholderColor3 = theme.TextDim
    outputBox.Font = Enum.Font.Gotham
    outputBox.TextSize = 12
    outputBox.ClearTextOnFocus = false
    outputBox.BorderSizePixel = 0
    outputBox.Parent = panel
    Instance.new("UICorner", outputBox).CornerRadius = UDim.new(0, 6)
    
    -- Combine button
    local combineBtn = Instance.new("TextButton")
    combineBtn.BackgroundColor3 = theme.Success
    combineBtn.BackgroundTransparency = 0.2
    combineBtn.Size = UDim2.new(1, -30, 0, 45)
    combineBtn.Position = UDim2.new(0, 15, 0, 205)
    combineBtn.Text = "🔗 COMBINE MACROS"
    combineBtn.TextColor3 = Color3.new(1, 1, 1)
    combineBtn.Font = Enum.Font.GothamBlack
    combineBtn.TextSize = 14
    combineBtn.AutoButtonColor = false
    combineBtn.BorderSizePixel = 0
    combineBtn.Parent = panel
    Instance.new("UICorner", combineBtn).CornerRadius = UDim.new(0, 8)
    
    combineBtn.MouseButton1Click:Connect(function()
        if not selectedMacro1 or not selectedMacro2 then
            Axiora.Visuals.Notify("Combine", "Select both macros", 2, "error")
            return
        end
        if selectedMacro1 == selectedMacro2 then
            Axiora.Visuals.Notify("Combine", "Select two different macros", 2, "error")
            return
        end
        
        local outputName = outputBox.Text
        if outputName == "" then
            outputName = selectedMacro1 .. "_" .. selectedMacro2
        end
        
        local success = Axiora.Combine(selectedMacro1, selectedMacro2, outputName)
        if success then
            overlay:Destroy()
        end
    end)
    
    -- Cancel button
    local cancelBtn = Instance.new("TextButton")
    cancelBtn.BackgroundColor3 = theme.Error
    cancelBtn.BackgroundTransparency = 0.6
    cancelBtn.Size = UDim2.new(1, -30, 0, 35)
    cancelBtn.Position = UDim2.new(0, 15, 1, -50)
    cancelBtn.Text = "✕ CANCEL"
    cancelBtn.TextColor3 = theme.Text
    cancelBtn.Font = Enum.Font.GothamBold
    cancelBtn.TextSize = 12
    cancelBtn.AutoButtonColor = false
    cancelBtn.BorderSizePixel = 0
    cancelBtn.Parent = panel
    Instance.new("UICorner", cancelBtn).CornerRadius = UDim.new(0, 8)
    
    cancelBtn.MouseButton1Click:Connect(function()
        overlay:Destroy()
    end)
end

-- Rule creation modal for automation
function Axiora.UI.CreateRuleModal(parentGui, onComplete)
    local theme = Axiora.UI.Theme or {
        Background = Color3.fromRGB(18, 18, 25),
        Surface = Color3.fromRGB(28, 28, 38),
        Primary = Color3.fromRGB(120, 90, 255),
        Success = Color3.fromRGB(40, 200, 100),
        Error = Color3.fromRGB(255, 80, 80),
        Text = Color3.fromRGB(240, 240, 255),
        TextDim = Color3.fromRGB(140, 140, 160)
    }
    
    local triggers = {"interval", "playerJoin", "playerLeave", "chatReceived", "macroComplete", "always", "keyPressed", "healthLow", "onDeath", "loopCount"}
    local conditions = {"always", "playerCount", "playerDistance", "positionY", "sessionTime", "playerName", "chatContains", "randomChance", "healthBelow", "isMoving", "bufferSize"}
    local actions = {"playMacro", "stopMacro", "wait", "sendChat", "leaveServer", "rejoinServer", "notify", "jump", "pauseMacro", "resumeMacro", "resetMacro"}
    
    local selectedTrigger = triggers[1]
    local selectedCondition = conditions[1]
    local selectedAction = actions[1]
    local selectedMode = Axiora.Automation.MODE_PLAYBACK
    
    -- Overlay
    local overlay = Instance.new("Frame")
    overlay.BackgroundColor3 = Color3.new(0, 0, 0)
    overlay.BackgroundTransparency = 0.5
    overlay.Size = UDim2.new(1, 0, 1, 0)
    overlay.BorderSizePixel = 0
    overlay.ZIndex = 200
    overlay.Parent = parentGui
    
    -- Modal panel
    local panel = Instance.new("Frame")
    panel.BackgroundColor3 = theme.Background
    panel.Size = UDim2.new(0, 280, 0, 340)
    panel.Position = UDim2.new(0.5, 0, 0.5, 0)
    panel.AnchorPoint = Vector2.new(0.5, 0.5)
    panel.BorderSizePixel = 0
    panel.ZIndex = 201
    panel.Parent = overlay
    Instance.new("UICorner", panel).CornerRadius = UDim.new(0, 10)
    
    -- Title
    local title = Instance.new("TextLabel")
    title.BackgroundTransparency = 1
    title.Size = UDim2.new(1, 0, 0, 30)
    title.Text = "✨ CREATE RULE"
    title.TextColor3 = theme.Primary
    title.Font = Enum.Font.GothamBlack
    title.TextSize = 14
    title.ZIndex = 202
    title.Parent = panel
    
    local yPos = 35
    
    -- Helper to create dropdown
    local function createDropdown(labelText, options, defaultValue, onSelect)
        local container = Instance.new("Frame")
        container.BackgroundTransparency = 1
        container.Size = UDim2.new(1, -20, 0, 40)
        container.Position = UDim2.new(0, 10, 0, yPos)
        container.ZIndex = 202
        container.Parent = panel
        
        local label = Instance.new("TextLabel")
        label.BackgroundTransparency = 1
        label.Size = UDim2.new(1, 0, 0, 14)
        label.Text = labelText
        label.TextColor3 = theme.TextDim
        label.Font = Enum.Font.GothamBold
        label.TextSize = 9
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.ZIndex = 202
        label.Parent = container
        
        local btn = Instance.new("TextButton")
        btn.BackgroundColor3 = theme.Surface
        btn.Size = UDim2.new(1, 0, 0, 24)
        btn.Position = UDim2.new(0, 0, 0, 14)
        btn.Text = defaultValue .. " ▼"
        btn.TextColor3 = theme.Text
        btn.Font = Enum.Font.Gotham
        btn.TextSize = 10
        btn.AutoButtonColor = false
        btn.BorderSizePixel = 0
        btn.ZIndex = 202
        btn.Parent = container
        Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 5)
        
        local currentIndex = 1
        for i, v in ipairs(options) do
            if v == defaultValue then currentIndex = i break end
        end
        
        btn.MouseButton1Click:Connect(function()
            currentIndex = (currentIndex % #options) + 1
            local newVal = options[currentIndex]
            btn.Text = newVal .. " ▼"
            onSelect(newVal)
        end)
        
        yPos = yPos + 44
        return btn
    end
    
    -- Trigger dropdown
    createDropdown("TRIGGER (When)", triggers, selectedTrigger, function(v) selectedTrigger = v end)
    
    -- Condition dropdown
    createDropdown("CONDITION (If)", conditions, selectedCondition, function(v) selectedCondition = v end)
    
    -- Action dropdown
    createDropdown("ACTION (Do)", actions, selectedAction, function(v) selectedAction = v end)
    
    -- Mode dropdown
    local modes = {"playback", "always", "disabled"}
    createDropdown("MODE", modes, selectedMode, function(v) selectedMode = v end)
    
    -- Param input (for macro name, seconds, etc)
    local paramLabel = Instance.new("TextLabel")
    paramLabel.BackgroundTransparency = 1
    paramLabel.Size = UDim2.new(1, -20, 0, 14)
    paramLabel.Position = UDim2.new(0, 10, 0, yPos)
    paramLabel.Text = "PARAMETER (name, seconds, etc)"
    paramLabel.TextColor3 = theme.TextDim
    paramLabel.Font = Enum.Font.GothamBold
    paramLabel.TextSize = 9
    paramLabel.TextXAlignment = Enum.TextXAlignment.Left
    paramLabel.ZIndex = 202
    paramLabel.Parent = panel
    
    local paramInput = Instance.new("TextBox")
    paramInput.BackgroundColor3 = theme.Surface
    paramInput.Size = UDim2.new(1, -20, 0, 26)
    paramInput.Position = UDim2.new(0, 10, 0, yPos + 14)
    paramInput.Text = ""
    paramInput.PlaceholderText = "e.g., MyMacro, 60, Hello"
    paramInput.TextColor3 = theme.Text
    paramInput.PlaceholderColor3 = theme.TextDim
    paramInput.Font = Enum.Font.Gotham
    paramInput.TextSize = 10
    paramInput.ClearTextOnFocus = false
    paramInput.BorderSizePixel = 0
    paramInput.ZIndex = 202
    paramInput.Parent = panel
    Instance.new("UICorner", paramInput).CornerRadius = UDim.new(0, 5)
    
    yPos = yPos + 48
    
    -- Create button
    local createBtn = Instance.new("TextButton")
    createBtn.BackgroundColor3 = theme.Success
    createBtn.BackgroundTransparency = 0.2
    createBtn.Size = UDim2.new(0.48, 0, 0, 36)
    createBtn.Position = UDim2.new(0, 10, 0, yPos)
    createBtn.Text = "✓ CREATE"
    createBtn.TextColor3 = Color3.new(1, 1, 1)
    createBtn.Font = Enum.Font.GothamBold
    createBtn.TextSize = 11
    createBtn.AutoButtonColor = false
    createBtn.BorderSizePixel = 0
    createBtn.ZIndex = 202
    createBtn.Parent = panel
    Instance.new("UICorner", createBtn).CornerRadius = UDim.new(0, 6)
    
    -- Cancel button
    local cancelBtn = Instance.new("TextButton")
    cancelBtn.BackgroundColor3 = theme.Error
    cancelBtn.BackgroundTransparency = 0.5
    cancelBtn.Size = UDim2.new(0.48, 0, 0, 36)
    cancelBtn.Position = UDim2.new(0.52, 0, 0, yPos)
    cancelBtn.Text = "✕ CANCEL"
    cancelBtn.TextColor3 = Color3.new(1, 1, 1)
    cancelBtn.Font = Enum.Font.GothamBold
    cancelBtn.TextSize = 11
    cancelBtn.AutoButtonColor = false
    cancelBtn.BorderSizePixel = 0
    cancelBtn.ZIndex = 202
    cancelBtn.Parent = panel
    Instance.new("UICorner", cancelBtn).CornerRadius = UDim.new(0, 6)
    
    createBtn.MouseButton1Click:Connect(function()
        local param = paramInput.Text
        
        -- Build trigger object
        local trigger = {type = selectedTrigger}
        if selectedTrigger == "interval" then
            trigger.seconds = tonumber(param) or 60
        end
        
        -- Build condition object
        local condition = {type = selectedCondition}
        if selectedCondition == "playerCount" then
            condition.operator = ">"
            condition.value = tonumber(param) or 5
        elseif selectedCondition == "playerDistance" then
            condition.operator = "<"
            condition.distance = tonumber(param) or 50
        elseif selectedCondition == "positionY" then
            condition.operator = "<"
            condition.value = tonumber(param) or -50
        elseif selectedCondition == "sessionTime" then
            condition.operator = ">"
            condition.value = tonumber(param) or 30
        elseif selectedCondition == "playerName" then
            condition.name = param or ""
        elseif selectedCondition == "chatContains" then
            condition.text = param or ""
        elseif selectedCondition == "randomChance" then
            condition.percent = tonumber(param) or 50
        end
        
        -- Build action object
        local action = {type = selectedAction}
        if selectedAction == "playMacro" then
            action.name = param or ""
        elseif selectedAction == "wait" then
            action.seconds = tonumber(param) or 1
        elseif selectedAction == "sendChat" then
            action.message = param or "Hello"
        elseif selectedAction == "notify" then
            action.title = "Automation"
            action.message = param or "Rule triggered!"
        end
        
        -- Create the rule
        local rule = Axiora.Automation.CreateRule(trigger, condition, action, selectedMode)
        if rule then
            Axiora.Visuals.Notify("Scripts", "Rule created!", 2, "success")
        end
        
        overlay:Destroy()
        if onComplete then onComplete() end
    end)
    
    cancelBtn.MouseButton1Click:Connect(function()
        overlay:Destroy()
    end)
end

function Axiora.UI.Destroy()
    if Axiora.UI.ScreenGui then
        pcall(function() Axiora.UI.ScreenGui:Destroy() end)
        Axiora.UI.ScreenGui = nil
        Axiora.UI.MainFrame = nil
        Axiora.UI.ToggleButton = nil
        Axiora.UI.IsOpen = false
    end
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 21: ENHANCED PATHFINDING SYSTEM
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Pathfinding = {
    -- FIX: Increased thresholds to reduce false positives during slow movement/cutscenes
    StuckThreshold = 0.5,       -- Relaxed from 1.5 to 0.5 (smaller move required to be valid)
    StuckCheckInterval = 2.0,   -- Time between stuck checks (slower check)
    MaxStuckRecoveries = 5,     -- Max recovery attempts before giving up
    WaypointTolerance = 3.0,    -- Arrival tolerance in studs
    DynamicObstacles = true,    -- Track moving obstacles
    PathSmoothingEnabled = true,
    
    -- Internal state
    _lastPosition = nil,
    _lastCheckTime = 0,
    _stuckCount = 0,
    _recoveryIndex = 1
}

-- Check if character is stuck with hysteresis to prevent false positives
function Axiora.Pathfinding.IsStuck(currentPos)
    local now = os.clock()
    
    if now - Axiora.Pathfinding._lastCheckTime < Axiora.Pathfinding.StuckCheckInterval then
        return false
    end
    
    Axiora.Pathfinding._lastCheckTime = now
    
    -- Smart Check: Are we even trying to move?
    local LP = getLocalPlayer()
    if LP and LP.Character then
        local hum = LP.Character:FindFirstChildOfClass("Humanoid")
        if hum and hum.MoveDirection.Magnitude < 0.1 then
            -- Not trying to move, so we can't be stuck
            Axiora.Pathfinding._lastPosition = currentPos
            Axiora.Pathfinding._stuckCount = 0
            return false
        end
    end
    
    if not Axiora.Pathfinding._lastPosition then
        Axiora.Pathfinding._lastPosition = currentPos
        return false
    end
    
    local distance = (currentPos - Axiora.Pathfinding._lastPosition).Magnitude
    Axiora.Pathfinding._lastPosition = currentPos
    
    if distance < Axiora.Pathfinding.StuckThreshold then
        Axiora.Pathfinding._stuckCount = Axiora.Pathfinding._stuckCount + 1
        return Axiora.Pathfinding._stuckCount >= 2  -- Require 2 consecutive stuck checks
    else
        Axiora.Pathfinding._stuckCount = 0
        return false
    end
end

-- Multiple recovery strategies for when character gets stuck
function Axiora.Pathfinding.RecoverFromStuck(character)
    if not character then return false end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not hrp then return false end
    
    local strategies = {
        function() -- Strategy 1: Jump
            humanoid.Jump = true
            task.wait(0.3)
        end,
        function() -- Strategy 2: Move sideways (right)
            humanoid:Move(Vector3.new(1, 0, 0))
            task.wait(0.4)
            humanoid:Move(Vector3.zero)
        end,
        function() -- Strategy 3: Move sideways (left)
            humanoid:Move(Vector3.new(-1, 0, 0))
            task.wait(0.4)
            humanoid:Move(Vector3.zero)
        end,
        function() -- Strategy 4: Move backwards
            humanoid:Move(Vector3.new(0, 0, -1))
            task.wait(0.4)
            humanoid:Move(Vector3.zero)
        end,
        function() -- Strategy 5: Jump + diagonal
            humanoid.Jump = true
            humanoid:Move(Vector3.new(0.7, 0, 0.7))
            task.wait(0.5)
            humanoid:Move(Vector3.zero)
        end
    }
    
    local strategyIndex = Axiora.Pathfinding._recoveryIndex
    if strategyIndex > #strategies then
        strategyIndex = 1
    end
    
    pcall(strategies[strategyIndex])
    Axiora.Pathfinding._recoveryIndex = strategyIndex + 1
    
    return true
end

-- Reset pathfinding state
function Axiora.Pathfinding.Reset()
    Axiora.Pathfinding._lastPosition = nil
    Axiora.Pathfinding._lastCheckTime = 0
    Axiora.Pathfinding._stuckCount = 0
    Axiora.Pathfinding._recoveryIndex = 1
end

-- Smooth path using Catmull-Rom spline (for 3D visualization)
function Axiora.Pathfinding.SmoothPath(waypoints, segments)
    if #waypoints < 4 then return waypoints end
    segments = segments or 5
    
    local smoothed = {}
    
    for i = 2, #waypoints - 2 do
        local p0 = waypoints[i - 1]
        local p1 = waypoints[i]
        local p2 = waypoints[i + 1]
        local p3 = waypoints[i + 2]
        
        for t = 0, 1, 1 / segments do
            local t2 = t * t
            local t3 = t2 * t
            
            local x = 0.5 * ((2 * p1.X) + (-p0.X + p2.X) * t + 
                      (2 * p0.X - 5 * p1.X + 4 * p2.X - p3.X) * t2 + 
                      (-p0.X + 3 * p1.X - 3 * p2.X + p3.X) * t3)
            local y = 0.5 * ((2 * p1.Y) + (-p0.Y + p2.Y) * t + 
                      (2 * p0.Y - 5 * p1.Y + 4 * p2.Y - p3.Y) * t2 + 
                      (-p0.Y + 3 * p1.Y - 3 * p2.Y + p3.Y) * t3)
            local z = 0.5 * ((2 * p1.Z) + (-p0.Z + p2.Z) * t + 
                      (2 * p0.Z - 5 * p1.Z + 4 * p2.Z - p3.Z) * t2 + 
                      (-p0.Z + 3 * p1.Z - 3 * p2.Z + p3.Z) * t3)
            
            table.insert(smoothed, Vector3.new(x, y, z))
        end
    end
    
    return smoothed
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 22: MACRO VALIDATION & INTEGRITY
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Validation = {
    CurrentVersion = 2,
    AutoFix = true,
    StrictMode = false
}

-- Validate a single node
function Axiora.Validation.ValidateNode(node, index)
    if type(node) ~= "table" then
        return false, "Node #" .. index .. " is not a table"
    end
    
    if node.t == nil then
        if Axiora.Validation.AutoFix then
            node.t = 1  -- Default to movement
            return true, "Auto-fixed: Node #" .. index .. " missing type"
        end
        return false, "Node #" .. index .. " missing type (t)"
    end
    
    if node.d == nil then
        if Axiora.Validation.AutoFix then
            node.d = 0
        else
            return false, "Node #" .. index .. " missing delay (d)"
        end
    end
    
    -- Type-specific validation
    if node.t == 1 then -- Movement
        if not node.p and Axiora.Validation.StrictMode then
            return false, "Move node #" .. index .. " missing position"
        end
    elseif node.t == 2 then -- Click
        if (node.x == nil or node.y == nil) then
            if Axiora.Validation.AutoFix then
                node.x = node.x or 0.5
                node.y = node.y or 0.5
            else
                return false, "Click node #" .. index .. " missing coordinates"
            end
        end
    elseif node.t == 3 then -- Keyboard
        if not node.k and Axiora.Validation.StrictMode then
            return false, "Key node #" .. index .. " missing keycode"
        end
    end
    
    return true, nil
end

-- Validate entire buffer
function Axiora.Validation.ValidateBuffer(buffer)
    if type(buffer) ~= "table" then
        return false, "Buffer is not a table", {}
    end
    
    local errors = {}
    local warnings = {}
    
    for i, node in ipairs(buffer) do
        local valid, msg = Axiora.Validation.ValidateNode(node, i)
        if not valid then
            table.insert(errors, msg)
        elseif msg then
            table.insert(warnings, msg)
        end
    end
    
    if #errors > 0 then
        return false, "Validation failed: " .. errors[1], errors
    end
    
    return true, #warnings > 0 and (#warnings .. " nodes auto-fixed") or nil, warnings
end

-- Migrate old format to new
function Axiora.Validation.MigrateVersion(data)
    local version = data.version or data.v or 1
    
    if version < 2 then
        -- v1 -> v2: Ensure all nodes have delay
        for i, node in ipairs(data.buffer or data.b or {}) do
            if node.d == nil then node.d = 0 end
            -- Normalize position format
            if node.p and type(node.p) == "table" and node.p[1] then
                -- Already array format
            elseif node.p and type(node.p) == "userdata" then
                node.p = {node.p.X, node.p.Y, node.p.Z}
            end
        end
        data.version = 2
    end
    
    return data
end

-- Create backup before loading
function Axiora.Validation.CreateBackup(name)
    if not Axiora.Capabilities.WriteFile or not Axiora.Capabilities.ReadFile then
        return false
    end
    
    local sourcePath = "Axiora/saves/" .. name .. ".json"
    local backupPath = "Axiora/backups/" .. name .. "_" .. os.time() .. ".json"
    
    local success = pcall(function()
        if not isfolder("Axiora/backups") then makefolder("Axiora/backups") end
        if isfile(sourcePath) then
            writefile(backupPath, readfile(sourcePath))
        end
    end)
    
    return success
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 23: EXTENDED INPUT TYPES
-- ═══════════════════════════════════════════════════════════════════════════════

-- Extended node types
Axiora.NodeTypes = {
    MOVE = 1,
    CLICK_LEFT = 2,
    KEY = 3,
    CONDITION = 4,
    CLICK_RIGHT = 5,
    CLICK_MIDDLE = 6,
    SCROLL = 7,
    HOLD_START = 8,
    HOLD_END = 9,
    GAMEPAD = 10,
    GYRO = 11
}

-- Right-click function
function Axiora.Input.RightClick(x, y)
    if Axiora.Input.Method == "Delta" and Axiora.Input._deltaInput then
        local success = pcall(function()
            if Axiora.Input._deltaInput.mouse_move then
                Axiora.Input._deltaInput.mouse_move(x, y)
            end
            task.wait(0.01)
            if Axiora.Input._deltaInput.mouse2_click then
                Axiora.Input._deltaInput.mouse2_click()
            end
        end)
        if success then return true end
    end
    
    if VirtualInputManager then
        pcall(function()
            VirtualInputManager:SendMouseButtonEvent(x, y, 1, true, game, 1)
            task.wait(0.03)
            VirtualInputManager:SendMouseButtonEvent(x, y, 1, false, game, 1)
        end)
        return true
    end
    
    return false
end

-- Middle-click function
function Axiora.Input.MiddleClick(x, y)
    if VirtualInputManager then
        pcall(function()
            VirtualInputManager:SendMouseButtonEvent(x, y, 2, true, game, 1)
            task.wait(0.03)
            VirtualInputManager:SendMouseButtonEvent(x, y, 2, false, game, 1)
        end)
        return true
    end
    return false
end

-- Scroll wheel function
function Axiora.Input.Scroll(x, y, direction, amount)
    amount = amount or 1
    local scrollValue = direction == "up" and amount or -amount
    
    if VirtualInputManager then
        pcall(function()
            VirtualInputManager:SendMouseWheelEvent(x, y, scrollValue)
        end)
        return true
    end
    return false
end

-- Mouse hold (press without release)
function Axiora.Input.MouseDown(x, y, button)
    button = button or 0 -- 0 = left, 1 = right, 2 = middle
    
    if VirtualInputManager then
        pcall(function()
            VirtualInputManager:SendMouseButtonEvent(x, y, button, true, game, 1)
        end)
        return true
    end
    return false
end

-- Mouse release
function Axiora.Input.MouseUp(x, y, button)
    button = button or 0
    
    if VirtualInputManager then
        pcall(function()
            VirtualInputManager:SendMouseButtonEvent(x, y, button, false, game, 1)
        end)
        return true
    end
    return false
end

-- Key hold (press without release)
function Axiora.Input.KeyDown(keyCode)
    if VirtualInputManager then
        pcall(function()
            VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
        end)
        return true
    end
    
    if Axiora.Capabilities.KeyPress then
        pcall(function() keypress(keyCode) end)
        return true
    end
    
    return false
end

-- Key release
function Axiora.Input.KeyUp(keyCode)
    if VirtualInputManager then
        pcall(function()
            VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
        end)
        return true
    end
    
    if Axiora.Capabilities.KeyRelease then
        pcall(function() keyrelease(keyCode) end)
        return true
    end
    
    return false
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 24: GAME-SPECIFIC PROFILES
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Profiles = {
    Current = nil,
    List = {},
    AutoDetect = true,
    AutoLoad = true
}

function Axiora.Profiles.GetPlaceId()
    return game.PlaceId
end

function Axiora.Profiles.GetGameName()
    local success, info = pcall(function()
        return game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId)
    end)
    if success and info then
        return info.Name or "Unknown"
    end
    return "Game_" .. game.PlaceId
end

function Axiora.Profiles.LoadForCurrentGame()
    if not Axiora.Profiles.AutoDetect then return false end
    if not Axiora.Capabilities.ReadFile then return false end
    
    local placeId = Axiora.Profiles.GetPlaceId()
    local profilePath = "Axiora/profiles/" .. placeId .. ".json"
    
    local success, data = pcall(function()
        if isfile(profilePath) then
            return HttpService:JSONDecode(readfile(profilePath))
        end
        return nil
    end)
    
    if success and data then
        Axiora.Profiles.Current = data
        
        -- Apply saved settings
        for key, value in pairs(data.settings or {}) do
            if Axiora.Settings[key] ~= nil then
                Axiora.Settings[key] = value
            end
        end
        
        -- Apply calibration
        if data.calibration then
            if Axiora.Calibration and Axiora.Calibration.SetOffsets then
                Axiora.Calibration.SetOffsets(data.calibration.XOffset or 0, data.calibration.YOffset or 0)
            else
                Axiora.Settings.XOffset = data.calibration.XOffset or 0
                Axiora.Settings.YOffset = data.calibration.YOffset or 0
            end
        end
        
        Axiora.Visuals.Notify("Profile", "Loaded: " .. (data.gameName or "Game profile"), 2, "success")
        Axiora.Events:Fire("ProfileLoaded", {PlaceId = placeId, Profile = data})
        return true
    end
    
    return false
end

function Axiora.Profiles.SaveCurrentGame()
    if not Axiora.Capabilities.WriteFile then
        Axiora.Visuals.Notify("Profile", "Cannot save - no file system", 2, "error")
        return false
    end
    
    local placeId = Axiora.Profiles.GetPlaceId()
    local profilePath = "Axiora/profiles/" .. placeId .. ".json"
    
    local profile = {
        placeId = placeId,
        gameName = Axiora.Profiles.GetGameName(),
        settings = {
            XOffset = Axiora.Settings.XOffset,
            YOffset = Axiora.Settings.YOffset,
            TimeScale = Axiora.Settings.TimeScale,
            ClickRecoveryEnabled = Axiora.Settings.ClickRecoveryEnabled,
            ClickRecoveryMaxAttempts = Axiora.Settings.ClickRecoveryMaxAttempts,
            MovementSampleRate = Axiora.Settings.MovementSampleRate
        },
        calibration = {
            XOffset = Axiora.Settings.XOffset,
            YOffset = Axiora.Settings.YOffset
        },
        timestamp = os.time(),
        version = Axiora._VERSION
    }
    
    local success = pcall(function()
        if not isfolder("Axiora/profiles") then makefolder("Axiora/profiles") end
        writefile(profilePath, HttpService:JSONEncode(profile))
    end)
    
    if success then
        Axiora.Profiles.Current = profile
        Axiora.Visuals.Notify("Profile", "Saved for " .. profile.gameName, 2, "success")
        return true
    end
    
    Axiora.Visuals.Notify("Profile", "Failed to save", 2, "error")
    return false
end

function Axiora.Profiles.DeleteProfile(placeId)
    placeId = placeId or Axiora.Profiles.GetPlaceId()
    local profilePath = "Axiora/profiles/" .. placeId .. ".json"
    
    if Axiora.Capabilities.DeleteFile then
        pcall(function()
            if isfile(profilePath) then
                delfile(profilePath)
            end
        end)
        Axiora.Visuals.Notify("Profile", "Deleted profile", 2, "info")
        return true
    end
    
    return false
end

function Axiora.Profiles.ListProfiles()
    local profiles = {}
    
    if not Axiora.Capabilities.ReadFile then return profiles end
    
    pcall(function()
        if isfolder("Axiora/profiles") then
            for _, file in ipairs(listfiles("Axiora/profiles")) do
                if string.match(file, "%.json$") then
                    local data = HttpService:JSONDecode(readfile(file))
                    table.insert(profiles, {
                        placeId = data.placeId,
                        gameName = data.gameName,
                        timestamp = data.timestamp
                    })
                end
            end
        end
    end)
    
    return profiles
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 25: BIOMETRIC ANTI-AFK (Human-like Input Simulation)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.BiometricAntiAFK = {
    Enabled = false,
    _thread = nil,
    
    -- Configurable patterns
    Patterns = {
        MicroMovements = true,
        OccasionalScrolls = true,
        CameraLooks = true,
        RandomJumps = false,
        
        -- Timing (seconds)
        MinInterval = 30,
        MaxInterval = 180,
        
        -- Movement
        MouseJitter = 3  -- pixels
    }
}

-- Generate human-like random delay with gaussian distribution
function Axiora.BiometricAntiAFK.GenerateDelay()
    local min = Axiora.BiometricAntiAFK.Patterns.MinInterval
    local max = Axiora.BiometricAntiAFK.Patterns.MaxInterval
    
    -- Simulate gaussian with multiple random calls
    local sum = 0
    for i = 1, 3 do
        sum = sum + math.random()
    end
    local gaussian = sum / 3  -- 0-1 range, clustered toward 0.5
    
    return min + (max - min) * gaussian
end

-- Simulate micro mouse movement
function Axiora.BiometricAntiAFK.SimulateMicroMovement()
    local jitter = Axiora.BiometricAntiAFK.Patterns.MouseJitter
    local dx = math.random(-jitter, jitter)
    local dy = math.random(-jitter, jitter)
    
    local mousePos = UserInputService:GetMouseLocation()
    local newX = math.clamp(mousePos.X + dx, 0, Axiora.Math.Screen.Viewport.X)
    local newY = math.clamp(mousePos.Y + dy, 0, Axiora.Math.Screen.Viewport.Y)
    
    if Axiora.Input.Method == "Native" then
        pcall(function()
            mousemoveabs(newX, newY)
        end)
    end
end

-- Simulate camera look
function Axiora.BiometricAntiAFK.SimulateCameraLook()
    pcall(function()
        local cam = workspace.CurrentCamera
        if cam then
            local angleX = math.rad(math.random(-3, 3))
            local angleY = math.rad(math.random(-2, 2))
            cam.CFrame = cam.CFrame * CFrame.Angles(angleX, angleY, 0)
        end
    end)
end

-- Random action picker
function Axiora.BiometricAntiAFK.PerformRandomAction()
    local actions = {}
    local patterns = Axiora.BiometricAntiAFK.Patterns
    
    if patterns.MicroMovements then
        table.insert(actions, Axiora.BiometricAntiAFK.SimulateMicroMovement)
    end
    if patterns.CameraLooks then
        table.insert(actions, Axiora.BiometricAntiAFK.SimulateCameraLook)
    end
    if patterns.OccasionalScrolls then
        table.insert(actions, function()
            local dir = math.random() > 0.5 and "up" or "down"
            Axiora.Input.Scroll(0, 0, dir, 1)
        end)
    end
    if patterns.RandomJumps then
        table.insert(actions, function()
            local LP = getLocalPlayer()
            if LP and LP.Character then
                local hum = LP.Character:FindFirstChildOfClass("Humanoid")
                if hum then hum.Jump = true end
            end
        end)
    end
    
    if #actions > 0 then
        local action = actions[math.random(1, #actions)]
        pcall(action)
    end
end

function Axiora.BiometricAntiAFK.Start()
    if Axiora.BiometricAntiAFK.Enabled then return end
    Axiora.BiometricAntiAFK.Enabled = true
    
    Axiora.BiometricAntiAFK._thread = task.spawn(function()
        while Axiora.BiometricAntiAFK.Enabled do
            local delay = Axiora.BiometricAntiAFK.GenerateDelay()
            task.wait(delay)
            
            if Axiora.BiometricAntiAFK.Enabled then
                Axiora.BiometricAntiAFK.PerformRandomAction()
            end
        end
    end)
    
    Axiora.Visuals.Notify("Biometric", "Human-like anti-AFK started", 2, "success")
    Axiora.Events:Fire("BiometricAntiAFKStarted", {})
end

function Axiora.BiometricAntiAFK.Stop()
    Axiora.BiometricAntiAFK.Enabled = false
    Axiora.Visuals.Notify("Biometric", "Anti-AFK stopped", 2, "info")
    Axiora.Events:Fire("BiometricAntiAFKStopped", {})
end

function Axiora.BiometricAntiAFK.Toggle()
    if Axiora.BiometricAntiAFK.Enabled then
        Axiora.BiometricAntiAFK.Stop()
    else
        Axiora.BiometricAntiAFK.Start()
    end
    return Axiora.BiometricAntiAFK.Enabled
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 26: SMART BREAKPOINTS (Conditional Pause)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.SmartBreakpoints = {
    Conditions = {},
    Enabled = true
}

-- Add a conditional breakpoint
function Axiora.SmartBreakpoints.Add(nodeIndex, condition)
    --[[
    condition format:
    {
        type = "health" | "position" | "players" | "time" | "inventory",
        operator = "<" | ">" | "==" | "near" | "far",
        value = number | {x, y, z},
        radius = number (for position),
        message = "optional notification"
    }
    ]]
    
    Axiora.SmartBreakpoints.Conditions[nodeIndex] = condition
    
    -- Also set regular breakpoint
    if Axiora.SetBreakpoint then
        Axiora.SetBreakpoint(nodeIndex)
    end
    
    Axiora.Visuals.Notify("Breakpoint", "Smart breakpoint added at node #" .. nodeIndex, 2, "success")
    return true
end

-- Remove a smart breakpoint
function Axiora.SmartBreakpoints.Remove(nodeIndex)
    Axiora.SmartBreakpoints.Conditions[nodeIndex] = nil
    
    if Axiora.RemoveBreakpoint then
        Axiora.RemoveBreakpoint(nodeIndex)
    end
    
    return true
end

-- Check if smart breakpoint condition is met
function Axiora.SmartBreakpoints.Check(nodeIndex)
    if not Axiora.SmartBreakpoints.Enabled then return false end
    
    local condition = Axiora.SmartBreakpoints.Conditions[nodeIndex]
    if not condition then return false end
    
    local LP = getLocalPlayer()
    if not LP then return false end
    
    local shouldBreak = false
    
    if condition.type == "health" then
        local character = LP.Character
        if character then
            local hum = character:FindFirstChildOfClass("Humanoid")
            if hum and hum.MaxHealth > 0 then
                local healthPct = (hum.Health / hum.MaxHealth) * 100
                
                if condition.operator == "<" and healthPct < condition.value then
                    shouldBreak = true
                elseif condition.operator == ">" and healthPct > condition.value then
                    shouldBreak = true
                elseif condition.operator == "==" and math.abs(healthPct - condition.value) < 1 then
                    shouldBreak = true
                end
            end
        end
        
    elseif condition.type == "position" then
        local character = LP.Character
        if character then
            local pos = character:GetPivot().Position
            local target = Vector3.new(
                condition.value[1] or condition.value.x or 0,
                condition.value[2] or condition.value.y or 0,
                condition.value[3] or condition.value.z or 0
            )
            local distance = (pos - target).Magnitude
            local radius = condition.radius or 10
            
            if condition.operator == "near" and distance < radius then
                shouldBreak = true
            elseif condition.operator == "far" and distance > radius then
                shouldBreak = true
            end
        end
        
    elseif condition.type == "players" then
        local count = #Players:GetPlayers()
        
        if condition.operator == "<" and count < condition.value then
            shouldBreak = true
        elseif condition.operator == ">" and count > condition.value then
            shouldBreak = true
        elseif condition.operator == "==" and count == condition.value then
            shouldBreak = true
        end
        
    elseif condition.type == "time" then
        local elapsed = Axiora.Analytics and Axiora.Analytics.GetUptime() or 0
        local minutes = elapsed / 60
        
        if condition.operator == ">" and minutes > condition.value then
            shouldBreak = true
        elseif condition.operator == "<" and minutes < condition.value then
            shouldBreak = true
        end
    end
    
    if shouldBreak and condition.message then
        Axiora.Visuals.Notify("Smart Breakpoint", condition.message, 3, "warning")
    end
    
    return shouldBreak
end

-- Clear all smart breakpoints
function Axiora.SmartBreakpoints.ClearAll()
    Axiora.SmartBreakpoints.Conditions = {}
    if Axiora.ClearBreakpoints then
        Axiora.ClearBreakpoints()
    end
    Axiora.Visuals.Notify("Breakpoint", "All smart breakpoints cleared", 2, "info")
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 27: CONTROLLER & GYRO SUPPORT
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Controller = {
    Enabled = false,
    Recording = false,
    Sensitivity = 1.0,
    DeadZone = 0.1,
    _connections = {}
}

Axiora.Controller.ButtonMap = {
    [Enum.KeyCode.ButtonA] = "A",
    [Enum.KeyCode.ButtonB] = "B",
    [Enum.KeyCode.ButtonX] = "X",
    [Enum.KeyCode.ButtonY] = "Y",
    [Enum.KeyCode.ButtonL1] = "LB",
    [Enum.KeyCode.ButtonR1] = "RB",
    [Enum.KeyCode.ButtonL2] = "LT",
    [Enum.KeyCode.ButtonR2] = "RT",
    [Enum.KeyCode.ButtonL3] = "LS",
    [Enum.KeyCode.ButtonR3] = "RS",
    [Enum.KeyCode.DPadUp] = "DUp",
    [Enum.KeyCode.DPadDown] = "DDown",
    [Enum.KeyCode.DPadLeft] = "DLeft",
    [Enum.KeyCode.DPadRight] = "DRight",
    [Enum.KeyCode.ButtonStart] = "Start",
    [Enum.KeyCode.ButtonSelect] = "Select"
}

function Axiora.Controller.IsConnected()
    return UserInputService.GamepadEnabled
end

function Axiora.Controller.StartRecording()
    if not Axiora.Controller.IsConnected() then
        Axiora.Visuals.Notify("Controller", "No gamepad detected", 2, "error")
        return false
    end
    
    Axiora.Controller.Recording = true
    Axiora.Controller.Enabled = true
    
    -- Button press listener
    local buttonConn = UserInputService.InputBegan:Connect(function(input, processed)
        if not Axiora.Controller.Recording then return end
        if Axiora.State.Status ~= "RECORDING" then return end
        
        local buttonName = Axiora.Controller.ButtonMap[input.KeyCode]
        if buttonName then
            local node = {
                t = Axiora.NodeTypes.GAMEPAD,
                d = Axiora.Recording.GetElapsedTime and Axiora.Recording.GetElapsedTime() or 0,
                button = buttonName,
                pressed = true
            }
            table.insert(Axiora.State.Buffer, node)
            Axiora.Recording.NodeCount = (Axiora.Recording.NodeCount or 0) + 1
        end
    end)
    table.insert(Axiora.Controller._connections, buttonConn)
    
    -- Button release listener
    local releaseConn = UserInputService.InputEnded:Connect(function(input, processed)
        if not Axiora.Controller.Recording then return end
        if Axiora.State.Status ~= "RECORDING" then return end
        
        local buttonName = Axiora.Controller.ButtonMap[input.KeyCode]
        if buttonName then
            local node = {
                t = Axiora.NodeTypes.GAMEPAD,
                d = Axiora.Recording.GetElapsedTime and Axiora.Recording.GetElapsedTime() or 0,
                button = buttonName,
                pressed = false
            }
            table.insert(Axiora.State.Buffer, node)
        end
    end)
    table.insert(Axiora.Controller._connections, releaseConn)
    
    Axiora.Visuals.Notify("Controller", "Gamepad recording started", 2, "success")
    return true
end

function Axiora.Controller.StopRecording()
    Axiora.Controller.Recording = false
    
    for _, conn in ipairs(Axiora.Controller._connections) do
        pcall(function() conn:Disconnect() end)
    end
    Axiora.Controller._connections = {}
    
    Axiora.Visuals.Notify("Controller", "Gamepad recording stopped", 2, "info")
end

-- Simulate gamepad button press
function Axiora.Controller.SimulateButton(buttonName, pressed)
    -- Find the KeyCode for the button
    local keyCode = nil
    for code, name in pairs(Axiora.Controller.ButtonMap) do
        if name == buttonName then
            keyCode = code
            break
        end
    end
    
    if keyCode and VirtualInputManager then
        pcall(function()
            VirtualInputManager:SendKeyEvent(pressed, keyCode, false, game)
        end)
        return true
    end
    
    return false
end

-- Gyroscope support (mobile)
Axiora.Gyro = {
    Enabled = false,
    Recording = false,
    Sensitivity = 1.0,
    SampleRate = 0.1, -- Sample every N seconds
    _connection = nil,
    _lastSample = 0
}

function Axiora.Gyro.IsSupported()
    return UserInputService.GyroscopeEnabled
end

function Axiora.Gyro.StartTracking()
    if not Axiora.Gyro.IsSupported() then
        Axiora.Visuals.Notify("Gyro", "Device doesn't support gyroscope", 2, "error")
        return false
    end
    
    Axiora.Gyro.Enabled = true
    Axiora.Gyro.Recording = true
    Axiora.Gyro._lastSample = os.clock()  -- FIX: Initialize to current time to prevent first sample delay
    
    Axiora.Gyro._connection = UserInputService.DeviceRotationChanged:Connect(function(rotation, cframe)
        if not Axiora.Gyro.Recording then return end
        if Axiora.State.Status ~= "RECORDING" then return end
        
        local now = os.clock()
        if now - Axiora.Gyro._lastSample < Axiora.Gyro.SampleRate then
            return
        end
        Axiora.Gyro._lastSample = now
        
        local node = {
            t = Axiora.NodeTypes.GYRO,
            d = Axiora.Recording.GetElapsedTime and Axiora.Recording.GetElapsedTime() or 0,
            rotation = {
                x = rotation.X,
                y = rotation.Y,
                z = rotation.Z,
                w = rotation.W
            }
        }
        table.insert(Axiora.State.Buffer, node)
    end)
    
    Axiora.Visuals.Notify("Gyro", "Gyroscope tracking started", 2, "success")
    return true
end

function Axiora.Gyro.StopTracking()
    Axiora.Gyro.Recording = false
    Axiora.Gyro.Enabled = false
    
    if Axiora.Gyro._connection then
        pcall(function() Axiora.Gyro._connection:Disconnect() end)
        Axiora.Gyro._connection = nil
    end
    
    Axiora.Visuals.Notify("Gyro", "Gyroscope tracking stopped", 2, "info")
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 28: 3D VISUALIZATION
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.Visualization3D = {
    Enabled = false,
    ShowPath = true,
    ShowClicks = true,
    ShowVelocity = false,
    ShowJumpArcs = true,
    
    PathColor = Color3.fromRGB(100, 200, 255),
    ClickColor = Color3.fromRGB(255, 100, 150),
    JumpColor = Color3.fromRGB(150, 255, 100),
    
    _parts = {},
    _folder = nil
}

function Axiora.Visualization3D.Init()
    if Axiora.Visualization3D._folder then
        pcall(function() Axiora.Visualization3D._folder:Destroy() end)
    end
    
    Axiora.Visualization3D._folder = Instance.new("Folder")
    Axiora.Visualization3D._folder.Name = "AxioraViz3D"
    Axiora.Visualization3D._folder.Parent = workspace
    Axiora.Visualization3D._parts = {}
end

function Axiora.Visualization3D.CreatePathLine(from, to, color)
    local distance = (to - from).Magnitude
    local mid = (from + to) / 2
    
    local part = Instance.new("Part")
    part.Anchored = true
    part.CanCollide = false
    part.Material = Enum.Material.Neon
    part.Color = color or Axiora.Visualization3D.PathColor
    part.Size = Vector3.new(0.2, 0.2, distance)
    part.CFrame = CFrame.lookAt(mid, to)
    part.Transparency = 0.3
    part.Parent = Axiora.Visualization3D._folder
    
    table.insert(Axiora.Visualization3D._parts, part)
    return part
end

function Axiora.Visualization3D.CreateClickMarker(position, color)
    local part = Instance.new("Part")
    part.Anchored = true
    part.CanCollide = false
    part.Material = Enum.Material.Neon
    part.Color = color or Axiora.Visualization3D.ClickColor
    part.Shape = Enum.PartType.Ball
    part.Size = Vector3.new(0.8, 0.8, 0.8)
    part.Position = position
    part.Transparency = 0.2
    part.Parent = Axiora.Visualization3D._folder
    
    -- Add billboard for visibility
    local billboard = Instance.new("BillboardGui")
    billboard.Size = UDim2.new(0, 30, 0, 30)
    billboard.AlwaysOnTop = true
    billboard.Parent = part
    
    local icon = Instance.new("TextLabel")
    icon.Size = UDim2.new(1, 0, 1, 0)
    icon.BackgroundTransparency = 1
    icon.Text = "👆"
    icon.TextSize = 20
    icon.Parent = billboard
    
    table.insert(Axiora.Visualization3D._parts, part)
    return part
end

function Axiora.Visualization3D.CreateJumpArc(startPos, peakHeight, endPos, color)
    local segments = 10
    local points = {}
    
    for i = 0, segments do
        local t = i / segments
        local x = startPos.X + (endPos.X - startPos.X) * t
        local z = startPos.Z + (endPos.Z - startPos.Z) * t
        -- Parabolic arc
        local y = startPos.Y + (peakHeight * 4 * t * (1 - t))
        table.insert(points, Vector3.new(x, y, z))
    end
    
    for i = 1, #points - 1 do
        Axiora.Visualization3D.CreatePathLine(points[i], points[i + 1], color or Axiora.Visualization3D.JumpColor)
    end
end

function Axiora.Visualization3D.RenderBuffer(buffer)
    Axiora.Visualization3D.Clear()
    Axiora.Visualization3D.Init()
    
    if not buffer or #buffer == 0 then return end
    
    local lastPos = nil
    local lastWasJump = false
    
    for i, node in ipairs(buffer) do
        if node.t == 1 then -- Movement
            local pos = Axiora.Math.DeserializeVec(node.p)
            
            if Axiora.Visualization3D.ShowPath and lastPos then
                if lastWasJump and Axiora.Visualization3D.ShowJumpArcs then
                    Axiora.Visualization3D.CreateJumpArc(lastPos, 3, pos)
                else
                    Axiora.Visualization3D.CreatePathLine(lastPos, pos)
                end
            end
            
            lastPos = pos
            lastWasJump = node.j == true
            
        elseif node.t == 2 and Axiora.Visualization3D.ShowClicks then -- Click
            if lastPos then
                -- Create click marker at last known position (3D representation)
                Axiora.Visualization3D.CreateClickMarker(lastPos + Vector3.new(0, 2, 0))
            end
        end
    end
    
    Axiora.Visuals.Notify("3D Viz", "Rendered " .. #Axiora.Visualization3D._parts .. " elements", 2, "success")
end

function Axiora.Visualization3D.Clear()
    for _, part in ipairs(Axiora.Visualization3D._parts) do
        pcall(function() part:Destroy() end)
    end
    Axiora.Visualization3D._parts = {}
    
    if Axiora.Visualization3D._folder then
        pcall(function() Axiora.Visualization3D._folder:ClearAllChildren() end)
    end
end

function Axiora.Visualization3D.Toggle()
    Axiora.Visualization3D.Enabled = not Axiora.Visualization3D.Enabled
    
    if Axiora.Visualization3D.Enabled then
        Axiora.Visualization3D.RenderBuffer(Axiora.State.Buffer)
    else
        Axiora.Visualization3D.Clear()
    end
    
    return Axiora.Visualization3D.Enabled
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 29: MULTI-INSTANCE ORCHESTRATION
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.MultiInstance = {
    Enabled = false,
    Role = "standalone", -- standalone, leader, follower
    InstanceId = tostring(math.random(100000, 999999)),
    StaggerDelay = 0.5, -- Delay between instances
    SyncEnabled = false,
    
    _channel = nil,
    _connections = {}
}

-- Generate unique instance ID
function Axiora.MultiInstance.GetInstanceId()
    return Axiora.MultiInstance.InstanceId
end

-- Set instance role
function Axiora.MultiInstance.SetRole(role)
    if role ~= "leader" and role ~= "follower" and role ~= "standalone" then
        role = "standalone"
    end
    Axiora.MultiInstance.Role = role
    Axiora.Visuals.Notify("Multi-Instance", "Role set to: " .. role, 2, "info")
end

-- Start synchronized playback (leader broadcasts, followers listen)
function Axiora.MultiInstance.StartSyncPlayback()
    if Axiora.MultiInstance.Role == "leader" then
        -- Leader starts and broadcasts
        Axiora.Play(true)
        Axiora.MultiInstance.BroadcastCommand("PLAY")
    elseif Axiora.MultiInstance.Role == "follower" then
        -- Follower waits for stagger delay then plays
        task.delay(Axiora.MultiInstance.StaggerDelay, function()
            Axiora.Play(true)
        end)
    else
        -- Standalone just plays normally
        Axiora.Play(true)
    end
end

-- Broadcast command to other instances (via shared attribute if possible)
function Axiora.MultiInstance.BroadcastCommand(command)
    -- This uses a shared workspace attribute for cross-instance communication
    -- Note: This only works if instances share the same server
    pcall(function()
        -- Clean up old sync attributes to prevent spam (Limit to 50 checks)
        local checks = 0
        for _, attr in ipairs(workspace:GetAttributes()) do
            checks = checks + 1
            if checks > 50 then break end
            
            if string.match(tostring(attr), "^AxioraSync_") then
                local attrAge = os.time() - tonumber(string.match(tostring(attr), "AxioraSync_(%d+)") or "0")
                if attrAge > 10 then  -- Remove attributes older than 10 seconds
                    workspace:SetAttribute(attr, nil)
                end
            end
        end
        
        workspace:SetAttribute("AxioraSync_" .. os.time(), command .. "_" .. Axiora.MultiInstance.InstanceId)
    end)
end

-- Listen for sync commands
function Axiora.MultiInstance.StartListening()
    if Axiora.MultiInstance.Role ~= "follower" then return end
    
    local conn = workspace.AttributeChanged:Connect(function(attr)
        if string.match(attr, "^AxioraSync_") then
            local value = workspace:GetAttribute(attr)
            if value and string.match(value, "^PLAY_") then
                -- Check it's not from ourselves
                if not string.match(value, Axiora.MultiInstance.InstanceId) then
                    task.delay(Axiora.MultiInstance.StaggerDelay, function()
                        Axiora.Play(true)
                    end)
                end
            elseif value and string.match(value, "^STOP_") then
                Axiora.Stop()
            end
        end
    end)
    
    table.insert(Axiora.MultiInstance._connections, conn)
    Axiora.Visuals.Notify("Multi-Instance", "Listening for sync commands", 2, "info")
end

function Axiora.MultiInstance.StopListening()
    for _, conn in ipairs(Axiora.MultiInstance._connections) do
        pcall(function() conn:Disconnect() end)
    end
    Axiora.MultiInstance._connections = {}
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 30: AI-ASSISTED CLICK RECOVERY (Enhanced)
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.AIClickRecovery = {
    Enabled = false,
    LearnedOffsets = {},
    MaxLearnedOffsets = 100,
    ConfidenceThreshold = 0.7
}

-- Enhanced spiral with fibonacci-based pattern for better coverage
function Axiora.AIClickRecovery.GetFibonacciSpiral(baseOffset, maxAttempts)
    local offsets = {{0, 0}}  -- Start at center
    local phi = (1 + math.sqrt(5)) / 2  -- Golden ratio
    
    for i = 1, maxAttempts - 1 do
        local angle = i * phi * math.pi * 2
        local radius = baseOffset * math.sqrt(i) / 2
        local x = math.cos(angle) * radius
        local y = math.sin(angle) * radius
        table.insert(offsets, {math.floor(x), math.floor(y)})
    end
    
    return offsets
end

-- Learn from successful recovery
function Axiora.AIClickRecovery.Learn(originalX, originalY, successX, successY)
    local offsetX = successX - originalX
    local offsetY = successY - originalY
    
    -- Create location key (rounded to 10px grid)
    local key = math.floor(originalX / 10) .. "_" .. math.floor(originalY / 10)
    
    if not Axiora.AIClickRecovery.LearnedOffsets[key] then
        Axiora.AIClickRecovery.LearnedOffsets[key] = {
            offsets = {},
            successCount = 0
        }
    end
    
    local entry = Axiora.AIClickRecovery.LearnedOffsets[key]
    table.insert(entry.offsets, {offsetX, offsetY})
    entry.successCount = entry.successCount + 1
    
    -- Limit stored offsets
    if #entry.offsets > 10 then
        table.remove(entry.offsets, 1)
    end
    
    -- Cleanup old entries if we have too many
    local count = 0
    for _ in pairs(Axiora.AIClickRecovery.LearnedOffsets) do
        count = count + 1
    end
    
    -- FIX: Remove entries UNTIL under limit (not just one)
    while count > Axiora.AIClickRecovery.MaxLearnedOffsets do
        for k, _ in pairs(Axiora.AIClickRecovery.LearnedOffsets) do
            if k ~= key then  -- Don't remove the one we just added
                Axiora.AIClickRecovery.LearnedOffsets[k] = nil
                count = count - 1
                break
            end
        end
        if count <= Axiora.AIClickRecovery.MaxLearnedOffsets then break end
    end
end

-- Get predicted offset based on learned data
function Axiora.AIClickRecovery.GetPredictedOffset(x, y)
    local key = math.floor(x / 10) .. "_" .. math.floor(y / 10)
    local entry = Axiora.AIClickRecovery.LearnedOffsets[key]
    
    if not entry or #entry.offsets == 0 then
        return nil
    end
    
    -- Average the learned offsets
    local avgX, avgY = 0, 0
    for _, offset in ipairs(entry.offsets) do
        avgX = avgX + offset[1]
        avgY = avgY + offset[2]
    end
    avgX = avgX / #entry.offsets
    avgY = avgY / #entry.offsets
    
    return {math.floor(avgX), math.floor(avgY)}
end

-- Enhanced click with AI assistance
function Axiora.AIClickRecovery.SmartClick(x, y, validator)
    if not Axiora.AIClickRecovery.Enabled then
        return Axiora.ClickRecovery.ClickWithRetry(x, y, validator)
    end
    
    -- First, try predicted offset if we have learned data
    local predicted = Axiora.AIClickRecovery.GetPredictedOffset(x, y)
    if predicted then
        local predictedX = x + predicted[1]
        local predictedY = y + predicted[2]
        
        Axiora.Input.Click(predictedX, predictedY)
        
        if validator then
            task.wait(0.05)
            local success = pcall(function() return validator() end)
            if success then
                return true, 1
            end
        else
            return true, 1
        end
    end
    
    -- Fall back to fibonacci spiral
    local offsets = Axiora.AIClickRecovery.GetFibonacciSpiral(
        Axiora.Settings.ClickRecoveryOffsetPixels or 5,
        Axiora.Settings.ClickRecoveryMaxAttempts or 9
    )
    
    for attempt, offset in ipairs(offsets) do
        local clickX = x + offset[1]
        local clickY = y + offset[2]
        
        Axiora.Input.Click(clickX, clickY)
        
        if not validator then
            return true, attempt
        end
        
        task.wait(Axiora.Settings.ClickRecoveryDelay or 0.05)
        
        local success = pcall(function() return validator() end)
        if success then
            -- Learn from this success
            if attempt > 1 then
                Axiora.AIClickRecovery.Learn(x, y, clickX, clickY)
            end
            return true, attempt
        end
    end
    
    return false, #offsets
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 31: ENHANCED CALIBRATION (Y-Axis + DPI + Test Click)
-- ═══════════════════════════════════════════════════════════════════════════════

-- Extend existing calibration with Y-axis support
Axiora.Calibration.DPIScale = 1.0
Axiora.Calibration.TestClickEnabled = true

-- DPI detection (estimate based on screen size)
-- Interactive calibration for X/Y offsets
function Axiora.Calibration.StartInteractiveCalibration()
    -- Hide main panel if open
    if Axiora.UI.ScreenGui and Axiora.UI.MainPanel and Axiora.UI.MainPanel.Visible then
        Axiora.UI.TogglePanel()
    end
    
    local theme = Axiora.UI.Theme or {Primary = Color3.fromRGB(0, 255, 100)}
    
    -- Create overlay
    local sg = Instance.new("ScreenGui")
    sg.Name = "CalibrationOverlay"
    sg.IgnoreGuiInset = true
    sg.DisplayOrder = 10000
    if getLocalPlayer() and getLocalPlayer().PlayerGui then
        sg.Parent = getLocalPlayer().PlayerGui
    else
        pcall(function() sg.Parent = game:GetService("CoreGui") end)
    end
    
    local bg = Instance.new("Frame")
    bg.BackgroundColor3 = Color3.new(0,0,0)
    bg.BackgroundTransparency = 0.3
    bg.Size = UDim2.new(1,0,1,0)
    bg.Parent = sg
    
    local msg = Instance.new("TextLabel")
    msg.Text = "CLICK THE CENTER OF THE TARGET"
    msg.Size = UDim2.new(1,0,0,50)
    msg.Position = UDim2.new(0,0,0,100)
    msg.BackgroundTransparency = 1
    msg.TextColor3 = Color3.new(1,1,1)
    msg.Font = Enum.Font.GothamBold
    msg.TextSize = 24
    msg.Parent = bg
    
    -- Spawn target at known location (center of screen)
    local vp = workspace.CurrentCamera.ViewportSize
    local targetX, targetY = vp.X / 2, vp.Y / 2
    
    local target = Instance.new("ImageButton")
    target.BackgroundColor3 = theme.Primary
    target.BackgroundTransparency = 0.5
    target.Size = UDim2.new(0, 40, 0, 40)
    target.Position = UDim2.fromOffset(targetX - 20, targetY - 20)
    target.Parent = bg
    Instance.new("UICorner", target).CornerRadius = UDim.new(1,0)
    
    local crosshair = Instance.new("TextLabel")
    crosshair.BackgroundTransparency = 1
    crosshair.Size = UDim2.new(1,0,1,0)
    crosshair.Text = "+"
    crosshair.TextColor3 = Color3.new(1,1,1)
    crosshair.TextSize = 24
    crosshair.Parent = target
    
    target.MouseButton1Click:Connect(function()
        local mouse = UserInputService:GetMouseLocation()
        
        -- Calculate difference between where we put the button and where the mouse reported being
        -- Ideally they are identical. If mouse reports (500, 500) but button is at (500, 500), offset is 0.
        -- If mouse reports (500, 536) [topbar offset?] but button is visual at 500,500...
        
        local offsetX = mouse.X - targetX
        local offsetY = mouse.Y - targetY
        
        -- Save settings
        Axiora.Settings.XOffset = math.floor(offsetX)
        Axiora.Settings.YOffset = math.floor(offsetY)
        
        if Axiora.Save then Axiora.Save() end
        
        if Axiora.Visuals and Axiora.Visuals.Notify then
            Axiora.Visuals.Notify("Calibration", 
                string.format("Offsets saved: X=%d, Y=%d", offsetX, offsetY), 
                3, "success")
        end
        
        sg:Destroy()
        task.wait(0.5)
        -- Reopen panel
        if Axiora.UI.TogglePanel then Axiora.UI.TogglePanel() end
    end)
    
    -- Cancel button
    local cancelBtn = Instance.new("TextButton")
    cancelBtn.Text = "CANCEL"
    cancelBtn.Size = UDim2.new(0, 100, 0, 40)
    cancelBtn.Position = UDim2.new(0.5, -50, 0.8, 0)
    cancelBtn.BackgroundColor3 = theme.Primary
    cancelBtn.Parent = bg
    Instance.new("UICorner", cancelBtn).CornerRadius = UDim.new(0,8)
    
    cancelBtn.MouseButton1Click:Connect(function()
        sg:Destroy()
        if Axiora.UI.TogglePanel then Axiora.UI.TogglePanel() end
    end)
end

-- DPI detection (estimate based on screen size)
function Axiora.Calibration.DetectDPI()
    local viewport = Axiora.Math.Screen.Viewport
    
    -- Common resolutions and their typical DPI scales
    if viewport.X >= 3840 then  -- 4K
        return 2.0
    elseif viewport.X >= 2560 then  -- 1440p
        return 1.5
    elseif viewport.X >= 1920 then  -- 1080p
        return 1.0
    elseif viewport.X >= 1366 then  -- Common laptop
        return 1.0
    else
        return 1.0
    end
end

-- Test click at specific position with visual feedback
function Axiora.Calibration.PerformTestClick(relX, relY)
    relX = relX or 0.5
    relY = relY or 0.5
    
    -- Get absolute position with current offsets
    local abs = Axiora.Math.GetAbsoluteInput(relX, relY)
    
    -- Visual indicator
    if Axiora.Visuals and Axiora.Visuals.Ripple then
        Axiora.Visuals.Ripple(abs.X, abs.Y, Color3.fromRGB(255, 200, 50))
    end
    
    -- Perform click
    Axiora.Input.Click(abs.X, abs.Y)
    
    Axiora.Visuals.Notify("Test Click", 
        string.format("Clicked at (%.0f, %.0f)", abs.X, abs.Y), 
        2, "info")
    
    return abs
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 32: MOBILE CALIBRATION ARCHITECTURE
-- ═══════════════════════════════════════════════════════════════════════════════

Axiora.MobileCalibration = {
    Enabled = false,
    Profiles = {}, 
    CurrentOrientation = "portrait",
    ScreenGrid = {},
    SafeZones = {},
    Overlay = nil,
    IsCalibrating = false,
    OverrideOffsets = nil, -- Runtime offsets from calibration
    RuntimeValidation = {
        Active = false,
        Failures = 0,
        LastClick = 0
    }
}

-- PHASE 1: AUTOMATIC ENVIRONMENT PROFILING
function Axiora.MobileCalibration.GetDeviceFingerprint()
    local viewport = workspace.CurrentCamera.ViewportSize
    local orientation = viewport.X > viewport.Y and "landscape" or "portrait"
    
    local safeInsets = {Top=0, Bottom=0, Left=0, Right=0}
    pcall(function()
        local guiService = game:GetService("GuiService")
        local insets = guiService:GetGuiInset() 
        safeInsets.Top = insets.Y
    end)
    
    return {
        ScreenSize = {X = viewport.X, Y = viewport.Y},
        Orientation = orientation,
        SafeInsets = safeInsets,
        Timestamp = os.time(),
        RobloxControls = { -- Approximate
            Jump = {X = viewport.X - 100, Y = viewport.Y - 100},
            Stick = {X = 100, Y = viewport.Y - 100}
        }
    }
end

function Axiora.MobileCalibration.GenerateGrid()
    local vp = workspace.CurrentCamera.ViewportSize
    local safe = {Top=50, Bottom=50, Left=20, Right=20}
    
    local width = vp.X - safe.Left - safe.Right
    local height = vp.Y - safe.Top - safe.Bottom
    
    local colW = width / 3
    local rowH = height / 3
    
    local zones = {}
    local rows = {"T", "M", "B"} 
    local cols = {"L", "C", "R"} 
    
    for r, rowName in ipairs(rows) do
        for c, colName in ipairs(cols) do
            local zoneName = rowName .. colName
            local CenterX = safe.Left + (c-1)*colW + colW/2
            local CenterY = safe.Top + (r-1)*rowH + rowH/2
            
            -- Exclusion Logic
            local isExcluded = false
            if zoneName == "BL" or zoneName == "BR" then isExcluded = true end -- Stick/Jump
            if zoneName == "TL" then isExcluded = true end -- Chat
            
            zones[zoneName] = {
                Center = Vector2.new(CenterX, CenterY),
                Excluded = isExcluded
            }
        end
    end
    Axiora.MobileCalibration.ScreenGrid = zones
end

-- PHASE 2: VISUAL TOUCH FEEDBACK CALIBRATION
function Axiora.MobileCalibration.CreateOverlay()
    if Axiora.MobileCalibration.Overlay then Axiora.MobileCalibration.Overlay:Destroy() end
    
    local sg = Instance.new("ScreenGui")
    sg.Name = "AxioraCalibration"
    sg.DisplayOrder = 10000
    if getLocalPlayer() and getLocalPlayer().PlayerGui then
        sg.Parent = getLocalPlayer().PlayerGui
    else
        pcall(function() sg.Parent = game:GetService("CoreGui") end)
    end
    
    local bg = Instance.new("Frame")
    bg.Name = "Overlay"
    bg.BackgroundColor3 = Color3.new(0,0,0)
    bg.BackgroundTransparency = 0.3
    bg.Size = UDim2.new(1,0,1,0)
    bg.Parent = sg
    
    local msg = Instance.new("TextLabel")
    msg.Name = "StatusMessage"
    msg.Text = "DON'T TOUCH - Calibrating..."
    msg.Size = UDim2.new(1,0,0,50)
    msg.Position = UDim2.new(0,0,0,50)
    msg.BackgroundTransparency = 1
    msg.TextColor3 = Color3.new(1,1,1)
    msg.Font = Enum.Font.GothamBold
    msg.TextSize = 24
    msg.Parent = bg
    
    Axiora.MobileCalibration.Overlay = sg
    return bg, msg
end

function Axiora.MobileCalibration.SpawnTarget(posS, size)
    local target = Instance.new("Frame")
    target.Name = "Target"
    target.Size = UDim2.new(0, size, 0, size)
    target.Position = UDim2.new(0, posS.X - size/2, 0, posS.Y - size/2)
    target.BackgroundColor3 = Color3.fromRGB(150, 50, 255)
    target.Parent = Axiora.MobileCalibration.Overlay:FindFirstChild("Overlay")
    
    Instance.new("UICorner", target).CornerRadius = UDim.new(1,0)
    
    -- Pulse Animation
    task.spawn(function()
        local ts = game:GetService("TweenService")
        local t = ts:Create(target, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, -1, true), {BackgroundColor3 = Color3.fromRGB(200, 100, 255)})
        t:Play()
    end)
    return target
end

function Axiora.MobileCalibration.RunCalibration()
    if Axiora.MobileCalibration.IsCalibrating then return end
    Axiora.MobileCalibration.IsCalibrating = true
    
    local profile = Axiora.MobileCalibration.GetDeviceFingerprint()
    Axiora.MobileCalibration.GenerateGrid()
    local bg, msg = Axiora.MobileCalibration.CreateOverlay()
    
    -- PHASE 2B: AUTO-TOUCH SEQUENCE
    local zonesToTest = {"MC", "TC", "BC", "ML", "MR"} -- Priority order
    local results = {}
    local offsetSumX, offsetSumY, count = 0, 0, 0
    
    local VIM = game:GetService("VirtualInputManager")
    if not VIM then
        Axiora.Visuals.Notify("Calibration", "VirtualInputManager missing", 3, "error")
        Axiora.MobileCalibration.IsCalibrating = false
        Axiora.MobileCalibration.Overlay:Destroy()
        return
    end
    
    for _, zoneName in ipairs(zonesToTest) do
        local zone = Axiora.MobileCalibration.ScreenGrid[zoneName]
        if zone and not zone.Excluded then
            local targetPos = zone.Center
            local targetVis = Axiora.MobileCalibration.SpawnTarget(targetPos, 100)
            
            task.wait(0.5) -- Wait for visual
            
            -- Spiral Search: (0,0), (0,-20), (0,20), (-20,0), (20,0), (-20,-20)...
            local offsets = {
                Vector2.new(0,0), Vector2.new(0,-20), Vector2.new(0,20), 
                Vector2.new(-20,0), Vector2.new(20,0), Vector2.new(-20,-20)
            }
            local bestOffset = nil
            
            for _, off in ipairs(offsets) do
                local hit = false
                local conn = targetVis.InputBegan:Connect(function(input)
                    if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
                        hit = true
                    end
                end)
                
                -- Send Touch at Target + Offset
                pcall(function()
                    VIM:SendMouseButtonEvent(targetPos.X + off.X, targetPos.Y + off.Y, 0, true, game, 1)
                    task.wait(0.05)
                    VIM:SendMouseButtonEvent(targetPos.X + off.X, targetPos.Y + off.Y, 0, false, game, 1)
                end)
                task.wait(0.1)
                conn:Disconnect()
                
                if hit then
                    -- If we touched (X+Off) and hit Target (X), then Input system is shifted by -Off?
                    -- Actually we simply record the offset that worked.
                    -- To hit X, we need to add Off.
                    bestOffset = off
                    targetVis.BackgroundColor3 = Color3.new(0,1,0) -- Green
                    break
                end
            end
            
            if not bestOffset then
                targetVis.BackgroundColor3 = Color3.new(1,0,0) -- Red
            else
                results[zoneName] = bestOffset
                offsetSumX = offsetSumX + bestOffset.X
                offsetSumY = offsetSumY + bestOffset.Y
                count = count + 1
            end
            
            task.wait(0.5)
            targetVis:Destroy()
        end
    end
    
    local avgX = count > 0 and (offsetSumX/count) or 0
    local avgY = count > 0 and (offsetSumY/count) or 0
    
    -- PHASE 3: VERIFICATION
    -- Create 3 Buttons
    local verifyFrame = Instance.new("Frame", bg)
    verifyFrame.Size = UDim2.new(0, 300, 0, 100)
    verifyFrame.Position = UDim2.new(0.5, -150, 0.5, -50)
    verifyFrame.BackgroundTransparency = 1
    
    local btn1 = Instance.new("TextButton", verifyFrame)
    btn1.Size = UDim2.new(0,80,0,80) 
    btn1.Position = UDim2.new(0,0,0,10)
    btn1.BackgroundColor3 = Color3.fromRGB(50,50,50)
    btn1.Text = "1"
    
    local btn2 = Instance.new("TextButton", verifyFrame)
    btn2.Size = UDim2.new(0,80,0,80)
    btn2.Position = UDim2.new(0.5,-40,0,10)
    btn2.BackgroundColor3 = Color3.fromRGB(50,50,50)
    btn2.Text = "2"
    
    local btn3 = Instance.new("TextButton", verifyFrame)
    btn3.Size = UDim2.new(0,80,0,80)
    btn3.Position = UDim2.new(1,-80,0,10)
    btn3.BackgroundColor3 = Color3.fromRGB(50,50,50)
    btn3.Text = "3"
    
    local info = msg
    info.Text = "Verifying: Watch Middle Button"
    
    task.wait(1)
    
    -- Auto-Touch Button 2 (using calculated avg offset)
    local b2Abs = btn2.AbsolutePosition + btn2.AbsoluteSize/2
    local touchPos = b2Abs + Vector2.new(avgX, avgY)
    
    local b2Lit = false
    btn2.InputBegan:Connect(function() b2Lit = true btn2.BackgroundColor3 = Color3.new(0,1,0) end)
    
    pcall(function()
        VIM:SendMouseButtonEvent(touchPos.X, touchPos.Y, 0, true, game, 1)
        task.wait(0.05)
        VIM:SendMouseButtonEvent(touchPos.X, touchPos.Y, 0, false, game, 1)
    end)
    task.wait(0.5)
    
    if b2Lit then
        info.Text = "Success! Saving profile..."
        task.wait(1)
        
        -- Save
        Axiora.MobileCalibration.Profiles[profile.Orientation] = {
            Offset = {X = avgX, Y = avgY},
            Timestamp = os.time(),
            Confidence = 1.0
        }
        Axiora.Calibration.SetOffsets(avgX, avgY)
        Axiora.Visuals.Notify("Calibration", "Saved " .. profile.Orientation .. " profile", 3, "success")
    else
        info.Text = "Verification Failed."
        Axiora.Visuals.Notify("Calibration", "Verification failed", 3, "error")
    end
    
    Axiora.MobileCalibration.Overlay:Destroy()
    Axiora.MobileCalibration.IsCalibrating = false
end

-- PHASE 4: ORIENTATION DETECTION
function Axiora.MobileCalibration.StartMonitoring()
    Axiora.MobileCalibration.Enabled = true
    
    -- Orientation Listener
    Axiora.State.Connections.Orientation = UserInputService.DeviceRotationChanged:Connect(function()
        local fp = Axiora.MobileCalibration.GetDeviceFingerprint()
        if fp.Orientation ~= Axiora.MobileCalibration.CurrentOrientation then
            Axiora.MobileCalibration.CurrentOrientation = fp.Orientation
            -- Swap Profile
            local prof = Axiora.MobileCalibration.Profiles[fp.Orientation]
            if prof then
                Axiora.Calibration.SetOffsets(prof.Offset.X, prof.Offset.Y)
                Axiora.Visuals.Notify("Device", "Switched to " .. fp.Orientation .. " profile", 2, "info")
            else
                Axiora.Visuals.Notify("Device", "New orientation - Please calibrate", 3, "warning")
            end
        end
    end)
    
    -- PHASE 5: KEYBOARD COMPENSATION
    Axiora.State.Connections.Keyboard = UserInputService:GetPropertyChangedSignal("OnScreenKeyboardVisible"):Connect(function()
        local visible = UserInputService.OnScreenKeyboardVisible
        if visible then
            local size = UserInputService.OnScreenKeyboardSize
            -- Adjust Y offset? Usually Roblox handles GuiInset for keyboard, but 
            -- if content is pushed up, we might need dynamic offset.
            -- Implementation pending user feedback on specific keyboard behavior.
        end
    end)
    
    -- PHASE 6: RUNTIME VALIDATION (Click Verification)
    if getLocalPlayer() and getLocalPlayer().PlayerGui then
        for _, gui in ipairs(getLocalPlayer().PlayerGui:GetDescendants()) do
            if gui:IsA("GuiButton") then
                gui.Activated:Connect(function()
                    Axiora.MobileCalibration.RuntimeValidation.LastClick = os.clock()
                end)
            end
        end
        
        getLocalPlayer().PlayerGui.DescendantAdded:Connect(function(gui)
            if gui:IsA("GuiButton") then
                gui.Activated:Connect(function()
                    Axiora.MobileCalibration.RuntimeValidation.LastClick = os.clock()
                end)
            end
        end)
    end
end

-- ═══════════════════════════════════════════════════════════════════════════════
-- SECTION 33: MAIN INITIALIZATION
-- ═══════════════════════════════════════════════════════════════════════════════

function Axiora.UI.RefreshScripts()
    if Axiora.UI.MainPanel then
        local container = Axiora.UI.MainPanel:FindFirstChild("ContentContainer")
        local tab = container and container:FindFirstChild("Scripts")
        if tab then
            tab:ClearAllChildren()
            Axiora.UI.BuildScripts(tab)
        end
    end
end

function Axiora.UI.RefreshLibrary()
    if Axiora.UI.MainPanel then
        local container = Axiora.UI.MainPanel:FindFirstChild("ContentContainer")
        local tab = container and container:FindFirstChild("Files")
        if tab then
            tab:ClearAllChildren()
            Axiora.UI.BuildLibrary(tab)
        end
    end
end

function Axiora.Init()
    -- Mark as loaded
    Axiora._LOADED = true
    
    -- Initialize screen metrics
    Axiora.Math.WaitForInit(3)
    
    -- Detect and apply DPI scale
    Axiora.Calibration.DPIScale = Axiora.Calibration.DetectDPI()
    Axiora.Settings.DPIScale = Axiora.Calibration.DPIScale  -- Make accessible from Settings
    
    -- Initialize file system
    Axiora.Files.Init()
    
    -- Check if calibration is needed (first run or environment changed)
    local needsCalibration = Axiora.Calibration.CheckNeeded()
    
    if needsCalibration then
        -- Defer calibration until after UI is ready (Robust Wait)
        task.spawn(function()
            local waitTime = 0
            while not (Axiora.UI.ScreenGui or Axiora.Visuals.ScreenGui) and waitTime < 5 do
                task.wait(0.2)
                waitTime = waitTime + 0.2
            end
            
            if Axiora.Calibration.StartInteractiveCalibration then
                Axiora.Calibration.StartInteractiveCalibration()
            end
        end)
    end
    
    -- Mobile Full Architecture
    if UserInputService.TouchEnabled then
        Axiora.MobileCalibration.StartMonitoring()
        
        -- Auto-calibrate on first run
        task.delay(2, function()
            -- Attempt to load existing calibration
            local loaded = false
            if Axiora.Calibration.LoadCalibration then
                loaded = Axiora.Calibration.LoadCalibration()
            end
            
            if not loaded and Axiora.MobileCalibration.RunCalibration then
                Axiora.Visuals.Notify("Axiora", "Mobile device detected - Starting calibration", 4, "info")
                Axiora.MobileCalibration.RunCalibration()
            end
        end)
    end
    
    -- Try to load saved markers
    Axiora.LoadMarkedPositions()
    
    -- Initialize visuals
    Axiora.Visuals.Init()
    
    -- Create HUD (Legacy HUD disabled in favor of Quantum Orb)
    -- if Axiora.Settings.HUDEnabled then
    --     task.delay(0.5, function()
    --         Axiora.Visuals.CreateHUD()
    --     end)
    -- end
    
    -- Initialize hotkeys
    Axiora.Hotkeys.Init()
    
    -- Load automation rules and start evaluator
    Axiora.Automation.LoadRules()
    Axiora.Automation.StartEvaluator()
    
    -- Enable Anti-AFK if configured
    if Axiora.Settings.AntiAFK then
        Axiora.Security.EnableAntiAFK()
    end
    
    -- Create UI (Holographic Command Center)
    task.delay(0.3, function()
        if Axiora.UI.Init then
            Axiora.UI.Init()
            Axiora.Visuals.Notify("Axiora", "HoloUI v2.0 Initialized", 4, "success")
            if Axiora.Assistant then Axiora.Assistant.Show("Neural Hub Online. Ready for input!") end
        else
            -- Fallback if something went wrong
            Axiora.Visuals.Notify("Axiora", "UI Init Failed", 4, "error")
        end
    end)
    
    -- Log capabilities
    print("═══════════════════════════════════════════")
    print("[Axiora] v" .. Axiora._VERSION .. " - " .. Axiora._BUILD .. " FULL")
    print("[Axiora] Executor: " .. Axiora.Capabilities.Executor)
    print("[Axiora] Input Method: " .. Axiora.Input.Method)
    print("[Axiora] File System: " .. (Axiora.Capabilities.FileSystemVerified and "OK" or "Limited"))
    print("[Axiora] Hotkeys: F1=Record, F2=Play, F3=Stop, F4=UI, F8=HUD")
    print("═══════════════════════════════════════════")
    print("[Axiora] Features Loaded:")
    print("  ✓ Recording & Playback")
    print("  ✓ Save/Load Macros")
    print("  ✓ Strategy Loader (URL)")
    print("  ✓ Sequence Queue Manager")
    print("  ✓ Auto-Restart System")
    print("  ✓ Conditional Playback")
    print("  ✓ Marked Positions")
    print("  ✓ Analytics Tracking")
    print("  ✓ Calibration System")
    print("  ✓ Visual HUD & Notifications")
    print("═══════════════════════════════════════════")
end

-- Export to global
Root.Axiora = Axiora

-- Auto-initialize
Axiora.Init()

return Axiora
